#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Mon Oct 27 16:35:31 2014 by generateDS.py version 2.12e.
#
# Command line options:
#   ('--namespacedef', 'xmlns:cs=http://www.chemicalsemantics.com/cs')
#   ('-o', 'csx_api.py')
#   ('-s', 'csx_sub.py')
#
# Command line arguments:
#   csx.xsd
#
# Command line:
#   /usr/local/bin/generateDS.py --namespacedef="xmlns:cs=http://www.chemicalsemantics.com/cs" -o "csx_api.py" -s "csx_sub.py" csx.xsd
#
# Current working directory (os.getcwd()):
#   CSX_ver0
#

import sys
import getopt
import re as re_
import base64
import datetime as datetime_

etree_ = None
Verbose_import_ = False
(
    XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")


def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
            'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return input_data
        def gds_validate_datetime(self, input_data, node, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class csType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, version=None, fileId=None, molecularPublication=None, molecularSystem=None, molecularCalculations=None):
        self.original_tagname_ = None
        self.version = _cast(None, version)
        self.fileId = _cast(None, fileId)
        self.molecularPublication = molecularPublication
        self.molecularSystem = molecularSystem
        self.molecularCalculations = molecularCalculations
    def factory(*args_, **kwargs_):
        if csType.subclass:
            return csType.subclass(*args_, **kwargs_)
        else:
            return csType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_molecularPublication(self): return self.molecularPublication
    def set_molecularPublication(self, molecularPublication): self.molecularPublication = molecularPublication
    def get_molecularSystem(self): return self.molecularSystem
    def set_molecularSystem(self, molecularSystem): self.molecularSystem = molecularSystem
    def get_molecularCalculations(self): return self.molecularCalculations
    def set_molecularCalculations(self, molecularCalculations): self.molecularCalculations = molecularCalculations
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_fileId(self): return self.fileId
    def set_fileId(self, fileId): self.fileId = fileId
    def hasContent_(self):
        if (
            self.molecularPublication is not None or
            self.molecularSystem is not None or
            self.molecularCalculations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='chemicalSemantics', namespacedef_='xmlns:cs="http://chemicalsemantics.com/dictionary/chemicalsemantics/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='csType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='csType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='csType'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.fileId is not None and 'fileId' not in already_processed:
            already_processed.add('fileId')
            outfile.write(' fileId=%s' % (self.gds_format_string(quote_attrib(self.fileId).encode(ExternalEncoding), input_name='fileId'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='csType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.molecularPublication is not None:
            self.molecularPublication.export(outfile, level, namespace_, name_='molecularPublication', pretty_print=pretty_print)
        if self.molecularSystem is not None:
            self.molecularSystem.export(outfile, level, namespace_, name_='molecularSystem', pretty_print=pretty_print)
        if self.molecularCalculations is not None:
            self.molecularCalculations.export(outfile, level, namespace_, name_='molecularCalculations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='csType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.fileId is not None and 'fileId' not in already_processed:
            already_processed.add('fileId')
            showIndent(outfile, level)
            outfile.write('fileId="%s",\n' % (self.fileId,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.molecularPublication is not None:
            showIndent(outfile, level)
            outfile.write('molecularPublication=model_.mpType(\n')
            self.molecularPublication.exportLiteral(outfile, level, name_='molecularPublication')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.molecularSystem is not None:
            showIndent(outfile, level)
            outfile.write('molecularSystem=model_.msType(\n')
            self.molecularSystem.exportLiteral(outfile, level, name_='molecularSystem')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.molecularCalculations is not None:
            showIndent(outfile, level)
            outfile.write('molecularCalculations=model_.mcType(\n')
            self.molecularCalculations.exportLiteral(outfile, level, name_='molecularCalculations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('fileId', node)
        if value is not None and 'fileId' not in already_processed:
            already_processed.add('fileId')
            self.fileId = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'molecularPublication':
            obj_ = mpType.factory()
            obj_.build(child_)
            self.molecularPublication = obj_
            obj_.original_tagname_ = 'molecularPublication'
        elif nodeName_ == 'molecularSystem':
            obj_ = msType.factory()
            obj_.build(child_)
            self.molecularSystem = obj_
            obj_.original_tagname_ = 'molecularSystem'
        elif nodeName_ == 'molecularCalculations':
            obj_ = mcType.factory()
            obj_.build(child_)
            self.molecularCalculations = obj_
            obj_.original_tagname_ = 'molecularCalculations'
# end class csType


class mpType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, publicationTitle=None, publicationAbstract=None, publicationSource=None, correspondingAuthor=None, submittingAuthor=None, publicationTags=None, publicationStatus=None, publicationVisibility=None, publicationCategory=None, publicationKey=None):
        self.original_tagname_ = None
        self.publicationTitle = publicationTitle
        self.publicationAbstract = publicationAbstract
        self.publicationSource = publicationSource
        self.correspondingAuthor = correspondingAuthor
        self.submittingAuthor = submittingAuthor
        self.publicationTags = publicationTags
        self.publicationStatus = publicationStatus
        self.publicationVisibility = publicationVisibility
        self.publicationCategory = publicationCategory
        self.publicationKey = publicationKey
    def factory(*args_, **kwargs_):
        if mpType.subclass:
            return mpType.subclass(*args_, **kwargs_)
        else:
            return mpType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_publicationTitle(self): return self.publicationTitle
    def set_publicationTitle(self, publicationTitle): self.publicationTitle = publicationTitle
    def get_publicationAbstract(self): return self.publicationAbstract
    def set_publicationAbstract(self, publicationAbstract): self.publicationAbstract = publicationAbstract
    def get_publicationSource(self): return self.publicationSource
    def set_publicationSource(self, publicationSource): self.publicationSource = publicationSource
    def get_correspondingAuthor(self): return self.correspondingAuthor
    def set_correspondingAuthor(self, correspondingAuthor): self.correspondingAuthor = correspondingAuthor
    def get_submittingAuthor(self): return self.submittingAuthor
    def set_submittingAuthor(self, submittingAuthor): self.submittingAuthor = submittingAuthor
    def get_publicationTags(self): return self.publicationTags
    def set_publicationTags(self, publicationTags): self.publicationTags = publicationTags
    def get_publicationStatus(self): return self.publicationStatus
    def set_publicationStatus(self, publicationStatus): self.publicationStatus = publicationStatus
    def get_publicationVisibility(self): return self.publicationVisibility
    def set_publicationVisibility(self, publicationVisibility): self.publicationVisibility = publicationVisibility
    def get_publicationCategory(self): return self.publicationCategory
    def set_publicationCategory(self, publicationCategory): self.publicationCategory = publicationCategory
    def get_publicationKey(self): return self.publicationKey
    def set_publicationKey(self, publicationKey): self.publicationKey = publicationKey
    def hasContent_(self):
        if (
            self.publicationTitle is not None or
            self.publicationAbstract is not None or
            self.publicationSource is not None or
            self.correspondingAuthor is not None or
            self.submittingAuthor is not None or
            self.publicationTags is not None or
            self.publicationStatus is not None or
            self.publicationVisibility is not None or
            self.publicationCategory is not None or
            self.publicationKey is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='mpType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mpType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='mpType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='mpType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='mpType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.publicationTitle is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spublicationTitle>%s</%spublicationTitle>%s' % (namespace_, self.gds_format_string(quote_xml(self.publicationTitle).encode(ExternalEncoding), input_name='publicationTitle'), namespace_, eol_))
        if self.publicationAbstract is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spublicationAbstract>%s</%spublicationAbstract>%s' % (namespace_, self.gds_format_string(quote_xml(self.publicationAbstract).encode(ExternalEncoding), input_name='publicationAbstract'), namespace_, eol_))
        if self.publicationSource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spublicationSource>%s</%spublicationSource>%s' % (namespace_, self.gds_format_string(quote_xml(self.publicationSource).encode(ExternalEncoding), input_name='publicationSource'), namespace_, eol_))
        if self.correspondingAuthor is not None:
            self.correspondingAuthor.export(outfile, level, namespace_, name_='correspondingAuthor', pretty_print=pretty_print)
        if self.submittingAuthor is not None:
            self.submittingAuthor.export(outfile, level, namespace_, name_='submittingAuthor', pretty_print=pretty_print)
        if self.publicationTags is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spublicationTags>%s</%spublicationTags>%s' % (namespace_, self.gds_format_string(quote_xml(self.publicationTags).encode(ExternalEncoding), input_name='publicationTags'), namespace_, eol_))
        if self.publicationStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spublicationStatus>%s</%spublicationStatus>%s' % (namespace_, self.gds_format_integer(self.publicationStatus, input_name='publicationStatus'), namespace_, eol_))
        if self.publicationVisibility is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spublicationVisibility>%s</%spublicationVisibility>%s' % (namespace_, self.gds_format_integer(self.publicationVisibility, input_name='publicationVisibility'), namespace_, eol_))
        if self.publicationCategory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spublicationCategory>%s</%spublicationCategory>%s' % (namespace_, self.gds_format_string(quote_xml(self.publicationCategory).encode(ExternalEncoding), input_name='publicationCategory'), namespace_, eol_))
        if self.publicationKey is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spublicationKey>%s</%spublicationKey>%s' % (namespace_, self.gds_format_string(quote_xml(self.publicationKey).encode(ExternalEncoding), input_name='publicationKey'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='mpType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.publicationTitle is not None:
            showIndent(outfile, level)
            outfile.write('publicationTitle=%s,\n' % quote_python(self.publicationTitle).encode(ExternalEncoding))
        if self.publicationAbstract is not None:
            showIndent(outfile, level)
            outfile.write('publicationAbstract=%s,\n' % quote_python(self.publicationAbstract).encode(ExternalEncoding))
        if self.publicationSource is not None:
            showIndent(outfile, level)
            outfile.write('publicationSource=%s,\n' % quote_python(self.publicationSource).encode(ExternalEncoding))
        if self.correspondingAuthor is not None:
            showIndent(outfile, level)
            outfile.write('correspondingAuthor=model_.authorType(\n')
            self.correspondingAuthor.exportLiteral(outfile, level, name_='correspondingAuthor')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.submittingAuthor is not None:
            showIndent(outfile, level)
            outfile.write('submittingAuthor=model_.authorType(\n')
            self.submittingAuthor.exportLiteral(outfile, level, name_='submittingAuthor')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.publicationTags is not None:
            showIndent(outfile, level)
            outfile.write('publicationTags=%s,\n' % quote_python(self.publicationTags).encode(ExternalEncoding))
        if self.publicationStatus is not None:
            showIndent(outfile, level)
            outfile.write('publicationStatus=%d,\n' % self.publicationStatus)
        if self.publicationVisibility is not None:
            showIndent(outfile, level)
            outfile.write('publicationVisibility=%d,\n' % self.publicationVisibility)
        if self.publicationCategory is not None:
            showIndent(outfile, level)
            outfile.write('publicationCategory=%s,\n' % quote_python(self.publicationCategory).encode(ExternalEncoding))
        if self.publicationKey is not None:
            showIndent(outfile, level)
            outfile.write('publicationKey=%s,\n' % quote_python(self.publicationKey).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'publicationTitle':
            publicationTitle_ = child_.text
            publicationTitle_ = self.gds_validate_string(publicationTitle_, node, 'publicationTitle')
            self.publicationTitle = publicationTitle_
        elif nodeName_ == 'publicationAbstract':
            publicationAbstract_ = child_.text
            publicationAbstract_ = self.gds_validate_string(publicationAbstract_, node, 'publicationAbstract')
            self.publicationAbstract = publicationAbstract_
        elif nodeName_ == 'publicationSource':
            publicationSource_ = child_.text
            publicationSource_ = self.gds_validate_string(publicationSource_, node, 'publicationSource')
            self.publicationSource = publicationSource_
        elif nodeName_ == 'correspondingAuthor':
            obj_ = authorType.factory()
            obj_.build(child_)
            self.correspondingAuthor = obj_
            obj_.original_tagname_ = 'correspondingAuthor'
        elif nodeName_ == 'submittingAuthor':
            obj_ = authorType.factory()
            obj_.build(child_)
            self.submittingAuthor = obj_
            obj_.original_tagname_ = 'submittingAuthor'
        elif nodeName_ == 'publicationTags':
            publicationTags_ = child_.text
            publicationTags_ = self.gds_validate_string(publicationTags_, node, 'publicationTags')
            self.publicationTags = publicationTags_
        elif nodeName_ == 'publicationStatus':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'publicationStatus')
            self.publicationStatus = ival_
        elif nodeName_ == 'publicationVisibility':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'publicationVisibility')
            self.publicationVisibility = ival_
        elif nodeName_ == 'publicationCategory':
            publicationCategory_ = child_.text
            publicationCategory_ = self.gds_validate_string(publicationCategory_, node, 'publicationCategory')
            self.publicationCategory = publicationCategory_
        elif nodeName_ == 'publicationKey':
            publicationKey_ = child_.text
            publicationKey_ = self.gds_validate_string(publicationKey_, node, 'publicationKey')
            self.publicationKey = publicationKey_
# end class mpType


class authorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, organization=None, email=None):
        self.original_tagname_ = None
        self.name = name
        self.organization = organization
        self.email = email
    def factory(*args_, **kwargs_):
        if authorType.subclass:
            return authorType.subclass(*args_, **kwargs_)
        else:
            return authorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_organization(self): return self.organization
    def set_organization(self, organization): self.organization = organization
    def get_email(self): return self.email
    def set_email(self, email): self.email = email
    def validate_emailType(self, value):
        # Validate type emailType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.name is not None or
            self.organization is not None or
            self.email is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='authorType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='authorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='authorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='authorType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='authorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.organization is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorganization>%s</%sorganization>%s' % (namespace_, self.gds_format_string(quote_xml(self.organization).encode(ExternalEncoding), input_name='organization'), namespace_, eol_))
        if self.email is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%semail>%s</%semail>%s' % (namespace_, self.gds_format_string(quote_xml(self.email).encode(ExternalEncoding), input_name='email'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='authorType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.organization is not None:
            showIndent(outfile, level)
            outfile.write('organization=%s,\n' % quote_python(self.organization).encode(ExternalEncoding))
        if self.email is not None:
            showIndent(outfile, level)
            outfile.write('email=%s,\n' % quote_python(self.email).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'organization':
            organization_ = child_.text
            organization_ = self.gds_validate_string(organization_, node, 'organization')
            self.organization = organization_
        elif nodeName_ == 'email':
            email_ = child_.text
            email_ = self.gds_validate_string(email_, node, 'email')
            self.email = email_
            self.validate_emailType(self.email)    # validate type emailType
# end class authorType


class name(GeneratedsSuper):
    """Name of the author"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if name.subclass:
            return name.subclass(*args_, **kwargs_)
        else:
            return name(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='http://chemicalsemantics.com/dictionary/chemicalsemantics/', name_='name', namespacedef_='xmlns:cs="http://chemicalsemantics.com/dictionary/chemicalsemantics/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='name')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='http://chemicalsemantics.com/dictionary/chemicalsemantics/', name_='name', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='http://chemicalsemantics.com/dictionary/chemicalsemantics/', name_='name'):
        pass
    def exportChildren(self, outfile, level, namespace_='http://chemicalsemantics.com/dictionary/chemicalsemantics/', name_='name', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='name'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class name


class organization(GeneratedsSuper):
    """Organization that employs the author"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if organization.subclass:
            return organization.subclass(*args_, **kwargs_)
        else:
            return organization(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='http://chemicalsemantics.com/dictionary/chemicalsemantics/', name_='organization', namespacedef_='xmlns:cs="http://chemicalsemantics.com/dictionary/chemicalsemantics/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='organization')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='http://chemicalsemantics.com/dictionary/chemicalsemantics/', name_='organization', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='http://chemicalsemantics.com/dictionary/chemicalsemantics/', name_='organization'):
        pass
    def exportChildren(self, outfile, level, namespace_='http://chemicalsemantics.com/dictionary/chemicalsemantics/', name_='organization', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='organization'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class organization


class msType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, systemTemperature=None, systemCharge=None, systemMultiplicity=None, molecule=None, residue=None):
        self.original_tagname_ = None
        self.systemTemperature = systemTemperature
        self.systemCharge = systemCharge
        self.systemMultiplicity = systemMultiplicity
        if molecule is None:
            self.molecule = []
        else:
            self.molecule = molecule
        if residue is None:
            self.residue = []
        else:
            self.residue = residue
    def factory(*args_, **kwargs_):
        if msType.subclass:
            return msType.subclass(*args_, **kwargs_)
        else:
            return msType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_systemTemperature(self): return self.systemTemperature
    def set_systemTemperature(self, systemTemperature): self.systemTemperature = systemTemperature
    def get_systemCharge(self): return self.systemCharge
    def set_systemCharge(self, systemCharge): self.systemCharge = systemCharge
    def get_systemMultiplicity(self): return self.systemMultiplicity
    def set_systemMultiplicity(self, systemMultiplicity): self.systemMultiplicity = systemMultiplicity
    def get_molecule(self): return self.molecule
    def set_molecule(self, molecule): self.molecule = molecule
    def add_molecule(self, value): self.molecule.append(value)
    def insert_molecule_at(self, index, value): self.molecule.insert(index, value)
    def replace_molecule_at(self, index, value): self.molecule[index] = value
    def get_residue(self): return self.residue
    def set_residue(self, residue): self.residue = residue
    def add_residue(self, value): self.residue.append(value)
    def insert_residue_at(self, index, value): self.residue.insert(index, value)
    def replace_residue_at(self, index, value): self.residue[index] = value
    def hasContent_(self):
        if (
            self.systemTemperature is not None or
            self.systemCharge is not None or
            self.systemMultiplicity is not None or
            self.molecule or
            self.residue
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='msType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='msType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='msType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='msType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='msType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.systemTemperature is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssystemTemperature>%s</%ssystemTemperature>%s' % (namespace_, self.gds_format_float(self.systemTemperature, input_name='systemTemperature'), namespace_, eol_))
        if self.systemCharge is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssystemCharge>%s</%ssystemCharge>%s' % (namespace_, self.gds_format_integer(self.systemCharge, input_name='systemCharge'), namespace_, eol_))
        if self.systemMultiplicity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssystemMultiplicity>%s</%ssystemMultiplicity>%s' % (namespace_, self.gds_format_integer(self.systemMultiplicity, input_name='systemMultiplicity'), namespace_, eol_))
        for molecule_ in self.molecule:
            molecule_.export(outfile, level, namespace_, name_='molecule', pretty_print=pretty_print)
        for residue_ in self.residue:
            residue_.export(outfile, level, namespace_, name_='residue', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='msType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.systemTemperature is not None:
            showIndent(outfile, level)
            outfile.write('systemTemperature=%f,\n' % self.systemTemperature)
        if self.systemCharge is not None:
            showIndent(outfile, level)
            outfile.write('systemCharge=%d,\n' % self.systemCharge)
        if self.systemMultiplicity is not None:
            showIndent(outfile, level)
            outfile.write('systemMultiplicity=%d,\n' % self.systemMultiplicity)
        showIndent(outfile, level)
        outfile.write('molecule=[\n')
        level += 1
        for molecule_ in self.molecule:
            showIndent(outfile, level)
            outfile.write('model_.moleculeType(\n')
            molecule_.exportLiteral(outfile, level, name_='moleculeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('residue=[\n')
        level += 1
        for residue_ in self.residue:
            showIndent(outfile, level)
            outfile.write('model_.residueType(\n')
            residue_.exportLiteral(outfile, level, name_='residueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'systemTemperature':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'systemTemperature')
            self.systemTemperature = fval_
        elif nodeName_ == 'systemCharge':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'systemCharge')
            self.systemCharge = ival_
        elif nodeName_ == 'systemMultiplicity':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'systemMultiplicity')
            self.systemMultiplicity = ival_
        elif nodeName_ == 'molecule':
            obj_ = moleculeType.factory()
            obj_.build(child_)
            self.molecule.append(obj_)
            obj_.original_tagname_ = 'molecule'
        elif nodeName_ == 'residue':
            obj_ = residueType.factory()
            obj_.build(child_)
            self.residue.append(obj_)
            obj_.original_tagname_ = 'residue'
# end class msType


class moleculeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, numberAtoms=None, id=None, inchiKey=None, atom=None):
        self.original_tagname_ = None
        self.numberAtoms = _cast(int, numberAtoms)
        self.id = _cast(None, id)
        self.inchiKey = inchiKey
        if atom is None:
            self.atom = []
        else:
            self.atom = atom
    def factory(*args_, **kwargs_):
        if moleculeType.subclass:
            return moleculeType.subclass(*args_, **kwargs_)
        else:
            return moleculeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_inchiKey(self): return self.inchiKey
    def set_inchiKey(self, inchiKey): self.inchiKey = inchiKey
    def get_atom(self): return self.atom
    def set_atom(self, atom): self.atom = atom
    def add_atom(self, value): self.atom.append(value)
    def insert_atom_at(self, index, value): self.atom.insert(index, value)
    def replace_atom_at(self, index, value): self.atom[index] = value
    def get_numberAtoms(self): return self.numberAtoms
    def set_numberAtoms(self, numberAtoms): self.numberAtoms = numberAtoms
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_inchiKeyType(self, value):
        # Validate type inchiKeyType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.inchiKey is not None or
            self.atom
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='moleculeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='moleculeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='moleculeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='moleculeType'):
        if self.numberAtoms is not None and 'numberAtoms' not in already_processed:
            already_processed.add('numberAtoms')
            outfile.write(' numberAtoms="%s"' % self.gds_format_integer(self.numberAtoms, input_name='numberAtoms'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='moleculeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.inchiKey is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinchiKey>%s</%sinchiKey>%s' % (namespace_, self.gds_format_string(quote_xml(self.inchiKey).encode(ExternalEncoding), input_name='inchiKey'), namespace_, eol_))
        for atom_ in self.atom:
            atom_.export(outfile, level, namespace_, name_='atom', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='moleculeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.numberAtoms is not None and 'numberAtoms' not in already_processed:
            already_processed.add('numberAtoms')
            showIndent(outfile, level)
            outfile.write('numberAtoms=%d,\n' % (self.numberAtoms,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.inchiKey is not None:
            showIndent(outfile, level)
            outfile.write('inchiKey=%s,\n' % quote_python(self.inchiKey).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('atom=[\n')
        level += 1
        for atom_ in self.atom:
            showIndent(outfile, level)
            outfile.write('model_.atomType(\n')
            atom_.exportLiteral(outfile, level, name_='atomType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberAtoms', node)
        if value is not None and 'numberAtoms' not in already_processed:
            already_processed.add('numberAtoms')
            try:
                self.numberAtoms = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.numberAtoms < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'inchiKey':
            inchiKey_ = child_.text
            inchiKey_ = self.gds_validate_string(inchiKey_, node, 'inchiKey')
            self.inchiKey = inchiKey_
            self.validate_inchiKeyType(self.inchiKey)    # validate type inchiKeyType
        elif nodeName_ == 'atom':
            obj_ = atomType.factory()
            obj_.build(child_)
            self.atom.append(obj_)
            obj_.original_tagname_ = 'atom'
# end class moleculeType


class residueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, numberAtoms=None, id=None, resName=None, sequence=None, insertion=None, chain=None, secStruct=None, atom=None):
        self.original_tagname_ = None
        self.numberAtoms = _cast(int, numberAtoms)
        self.id = _cast(None, id)
        self.resName = resName
        self.sequence = sequence
        self.insertion = insertion
        self.chain = chain
        self.secStruct = secStruct
        if atom is None:
            self.atom = []
        else:
            self.atom = atom
    def factory(*args_, **kwargs_):
        if residueType.subclass:
            return residueType.subclass(*args_, **kwargs_)
        else:
            return residueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resName(self): return self.resName
    def set_resName(self, resName): self.resName = resName
    def get_sequence(self): return self.sequence
    def set_sequence(self, sequence): self.sequence = sequence
    def get_insertion(self): return self.insertion
    def set_insertion(self, insertion): self.insertion = insertion
    def get_chain(self): return self.chain
    def set_chain(self, chain): self.chain = chain
    def get_secStruct(self): return self.secStruct
    def set_secStruct(self, secStruct): self.secStruct = secStruct
    def get_atom(self): return self.atom
    def set_atom(self, atom): self.atom = atom
    def add_atom(self, value): self.atom.append(value)
    def insert_atom_at(self, index, value): self.atom.insert(index, value)
    def replace_atom_at(self, index, value): self.atom[index] = value
    def get_numberAtoms(self): return self.numberAtoms
    def set_numberAtoms(self, numberAtoms): self.numberAtoms = numberAtoms
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.resName is not None or
            self.sequence is not None or
            self.insertion is not None or
            self.chain is not None or
            self.secStruct is not None or
            self.atom
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='residueType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='residueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='residueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='residueType'):
        if self.numberAtoms is not None and 'numberAtoms' not in already_processed:
            already_processed.add('numberAtoms')
            outfile.write(' numberAtoms="%s"' % self.gds_format_integer(self.numberAtoms, input_name='numberAtoms'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='residueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.resName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sresName>%s</%sresName>%s' % (namespace_, self.gds_format_string(quote_xml(self.resName).encode(ExternalEncoding), input_name='resName'), namespace_, eol_))
        if self.sequence is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssequence>%s</%ssequence>%s' % (namespace_, self.gds_format_string(quote_xml(self.sequence).encode(ExternalEncoding), input_name='sequence'), namespace_, eol_))
        if self.insertion is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinsertion>%s</%sinsertion>%s' % (namespace_, self.gds_format_string(quote_xml(self.insertion).encode(ExternalEncoding), input_name='insertion'), namespace_, eol_))
        if self.chain is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schain>%s</%schain>%s' % (namespace_, self.gds_format_string(quote_xml(self.chain).encode(ExternalEncoding), input_name='chain'), namespace_, eol_))
        if self.secStruct is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssecStruct>%s</%ssecStruct>%s' % (namespace_, self.gds_format_string(quote_xml(self.secStruct).encode(ExternalEncoding), input_name='secStruct'), namespace_, eol_))
        for atom_ in self.atom:
            atom_.export(outfile, level, namespace_, name_='atom', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='residueType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.numberAtoms is not None and 'numberAtoms' not in already_processed:
            already_processed.add('numberAtoms')
            showIndent(outfile, level)
            outfile.write('numberAtoms=%d,\n' % (self.numberAtoms,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.resName is not None:
            showIndent(outfile, level)
            outfile.write('resName=%s,\n' % quote_python(self.resName).encode(ExternalEncoding))
        if self.sequence is not None:
            showIndent(outfile, level)
            outfile.write('sequence=%s,\n' % quote_python(self.sequence).encode(ExternalEncoding))
        if self.insertion is not None:
            showIndent(outfile, level)
            outfile.write('insertion=%s,\n' % quote_python(self.insertion).encode(ExternalEncoding))
        if self.chain is not None:
            showIndent(outfile, level)
            outfile.write('chain=%s,\n' % quote_python(self.chain).encode(ExternalEncoding))
        if self.secStruct is not None:
            showIndent(outfile, level)
            outfile.write('secStruct=%s,\n' % quote_python(self.secStruct).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('atom=[\n')
        level += 1
        for atom_ in self.atom:
            showIndent(outfile, level)
            outfile.write('model_.atomType(\n')
            atom_.exportLiteral(outfile, level, name_='atomType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberAtoms', node)
        if value is not None and 'numberAtoms' not in already_processed:
            already_processed.add('numberAtoms')
            try:
                self.numberAtoms = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.numberAtoms < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'resName':
            resName_ = child_.text
            resName_ = self.gds_validate_string(resName_, node, 'resName')
            self.resName = resName_
        elif nodeName_ == 'sequence':
            sequence_ = child_.text
            sequence_ = self.gds_validate_string(sequence_, node, 'sequence')
            self.sequence = sequence_
        elif nodeName_ == 'insertion':
            insertion_ = child_.text
            insertion_ = self.gds_validate_string(insertion_, node, 'insertion')
            self.insertion = insertion_
        elif nodeName_ == 'chain':
            chain_ = child_.text
            chain_ = self.gds_validate_string(chain_, node, 'chain')
            self.chain = chain_
        elif nodeName_ == 'secStruct':
            secStruct_ = child_.text
            secStruct_ = self.gds_validate_string(secStruct_, node, 'secStruct')
            self.secStruct = secStruct_
        elif nodeName_ == 'atom':
            obj_ = atomType.factory()
            obj_.build(child_)
            self.atom.append(obj_)
            obj_.original_tagname_ = 'atom'
# end class residueType


class atomType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, element=None, atomName=None, atomMass=None, formalAtomCharge=None, calculatedAtomCharge=None, xCoord3D=None, yCoord3D=None, zCoord3D=None, basisSet=None, nmrShielding=None, coordination=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.element = element
        self.atomName = atomName
        self.atomMass = atomMass
        self.formalAtomCharge = formalAtomCharge
        self.calculatedAtomCharge = calculatedAtomCharge
        self.xCoord3D = xCoord3D
        self.yCoord3D = yCoord3D
        self.zCoord3D = zCoord3D
        self.basisSet = basisSet
        self.nmrShielding = nmrShielding
        self.coordination = coordination
    def factory(*args_, **kwargs_):
        if atomType.subclass:
            return atomType.subclass(*args_, **kwargs_)
        else:
            return atomType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_element(self): return self.element
    def set_element(self, element): self.element = element
    def get_atomName(self): return self.atomName
    def set_atomName(self, atomName): self.atomName = atomName
    def get_atomMass(self): return self.atomMass
    def set_atomMass(self, atomMass): self.atomMass = atomMass
    def get_formalAtomCharge(self): return self.formalAtomCharge
    def set_formalAtomCharge(self, formalAtomCharge): self.formalAtomCharge = formalAtomCharge
    def get_calculatedAtomCharge(self): return self.calculatedAtomCharge
    def set_calculatedAtomCharge(self, calculatedAtomCharge): self.calculatedAtomCharge = calculatedAtomCharge
    def get_xCoord3D(self): return self.xCoord3D
    def set_xCoord3D(self, xCoord3D): self.xCoord3D = xCoord3D
    def get_yCoord3D(self): return self.yCoord3D
    def set_yCoord3D(self, yCoord3D): self.yCoord3D = yCoord3D
    def get_zCoord3D(self): return self.zCoord3D
    def set_zCoord3D(self, zCoord3D): self.zCoord3D = zCoord3D
    def get_basisSet(self): return self.basisSet
    def set_basisSet(self, basisSet): self.basisSet = basisSet
    def get_nmrShielding(self): return self.nmrShielding
    def set_nmrShielding(self, nmrShielding): self.nmrShielding = nmrShielding
    def get_coordination(self): return self.coordination
    def set_coordination(self, coordination): self.coordination = coordination
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.element is not None or
            self.atomName is not None or
            self.atomMass is not None or
            self.formalAtomCharge is not None or
            self.calculatedAtomCharge is not None or
            self.xCoord3D is not None or
            self.yCoord3D is not None or
            self.zCoord3D is not None or
            self.basisSet is not None or
            self.nmrShielding is not None or
            self.coordination is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='atomType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='atomType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='atomType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='atomType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='atomType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.element is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%selement>%s</%selement>%s' % (namespace_, self.gds_format_string(quote_xml(self.element).encode(ExternalEncoding), input_name='element'), namespace_, eol_))
        if self.atomName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%satomName>%s</%satomName>%s' % (namespace_, self.gds_format_string(quote_xml(self.atomName).encode(ExternalEncoding), input_name='atomName'), namespace_, eol_))
        if self.atomMass is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%satomMass>%s</%satomMass>%s' % (namespace_, self.gds_format_float(self.atomMass, input_name='atomMass'), namespace_, eol_))
        if self.formalAtomCharge is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sformalAtomCharge>%s</%sformalAtomCharge>%s' % (namespace_, self.gds_format_float(self.formalAtomCharge, input_name='formalAtomCharge'), namespace_, eol_))
        if self.calculatedAtomCharge is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scalculatedAtomCharge>%s</%scalculatedAtomCharge>%s' % (namespace_, self.gds_format_float(self.calculatedAtomCharge, input_name='calculatedAtomCharge'), namespace_, eol_))
        if self.xCoord3D is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxCoord3D>%s</%sxCoord3D>%s' % (namespace_, self.gds_format_float(self.xCoord3D, input_name='xCoord3D'), namespace_, eol_))
        if self.yCoord3D is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%syCoord3D>%s</%syCoord3D>%s' % (namespace_, self.gds_format_float(self.yCoord3D, input_name='yCoord3D'), namespace_, eol_))
        if self.zCoord3D is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%szCoord3D>%s</%szCoord3D>%s' % (namespace_, self.gds_format_float(self.zCoord3D, input_name='zCoord3D'), namespace_, eol_))
        if self.basisSet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbasisSet>%s</%sbasisSet>%s' % (namespace_, self.gds_format_string(quote_xml(self.basisSet).encode(ExternalEncoding), input_name='basisSet'), namespace_, eol_))
        if self.nmrShielding is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snmrShielding>%s</%snmrShielding>%s' % (namespace_, self.gds_format_float(self.nmrShielding, input_name='nmrShielding'), namespace_, eol_))
        if self.coordination is not None:
            self.coordination.export(outfile, level, namespace_, name_='coordination', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='atomType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.element is not None:
            showIndent(outfile, level)
            outfile.write('element=%s,\n' % quote_python(self.element).encode(ExternalEncoding))
        if self.atomName is not None:
            showIndent(outfile, level)
            outfile.write('atomName=%s,\n' % quote_python(self.atomName).encode(ExternalEncoding))
        if self.atomMass is not None:
            showIndent(outfile, level)
            outfile.write('atomMass=%f,\n' % self.atomMass)
        if self.formalAtomCharge is not None:
            showIndent(outfile, level)
            outfile.write('formalAtomCharge=%f,\n' % self.formalAtomCharge)
        if self.calculatedAtomCharge is not None:
            showIndent(outfile, level)
            outfile.write('calculatedAtomCharge=%f,\n' % self.calculatedAtomCharge)
        if self.xCoord3D is not None:
            showIndent(outfile, level)
            outfile.write('xCoord3D=%f,\n' % self.xCoord3D)
        if self.yCoord3D is not None:
            showIndent(outfile, level)
            outfile.write('yCoord3D=%f,\n' % self.yCoord3D)
        if self.zCoord3D is not None:
            showIndent(outfile, level)
            outfile.write('zCoord3D=%f,\n' % self.zCoord3D)
        if self.basisSet is not None:
            showIndent(outfile, level)
            outfile.write('basisSet=%s,\n' % quote_python(self.basisSet).encode(ExternalEncoding))
        if self.nmrShielding is not None:
            showIndent(outfile, level)
            outfile.write('nmrShielding=%f,\n' % self.nmrShielding)
        if self.coordination is not None:
            showIndent(outfile, level)
            outfile.write('coordination=model_.coordinationType(\n')
            self.coordination.exportLiteral(outfile, level, name_='coordination')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'element':
            element_ = child_.text
            element_ = self.gds_validate_string(element_, node, 'element')
            self.element = element_
        elif nodeName_ == 'atomName':
            atomName_ = child_.text
            atomName_ = self.gds_validate_string(atomName_, node, 'atomName')
            self.atomName = atomName_
        elif nodeName_ == 'atomMass':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'atomMass')
            self.atomMass = fval_
        elif nodeName_ == 'formalAtomCharge':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'formalAtomCharge')
            self.formalAtomCharge = fval_
        elif nodeName_ == 'calculatedAtomCharge':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'calculatedAtomCharge')
            self.calculatedAtomCharge = fval_
        elif nodeName_ == 'xCoord3D':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'xCoord3D')
            self.xCoord3D = fval_
        elif nodeName_ == 'yCoord3D':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'yCoord3D')
            self.yCoord3D = fval_
        elif nodeName_ == 'zCoord3D':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'zCoord3D')
            self.zCoord3D = fval_
        elif nodeName_ == 'basisSet':
            basisSet_ = child_.text
            basisSet_ = self.gds_validate_string(basisSet_, node, 'basisSet')
            self.basisSet = basisSet_
        elif nodeName_ == 'nmrShielding':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'nmrShielding')
            self.nmrShielding = fval_
        elif nodeName_ == 'coordination':
            obj_ = coordinationType.factory()
            obj_.build(child_)
            self.coordination = obj_
            obj_.original_tagname_ = 'coordination'
# end class atomType


class coordinationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, bondCount=None, bond=None, valueOf_=None):
        self.original_tagname_ = None
        self.bondCount = _cast(int, bondCount)
        self.valueOf_ = valueOf_
        if bond is None:
            self.bond = []
        else:
            self.bond = bond
    def factory(*args_, **kwargs_):
        if coordinationType.subclass:
            return coordinationType.subclass(*args_, **kwargs_)
        else:
            return coordinationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bond(self): return self.bond
    def set_bond(self, bond): self.bond = bond
    def add_bond(self, value): self.bond.append(value)
    def insert_bond_at(self, index, value): self.bond.insert(index, value)
    def replace_bond_at(self, index, value): self.bond[index] = value
    def get_bondCount(self): return self.bondCount
    def set_bondCount(self, bondCount): self.bondCount = bondCount
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='coordinationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='coordinationType')
        if self.hasContent_():
            outfile.write('>%s%s' % (self.gds_format_integer(self.valueOf_), eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='coordinationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='coordinationType'):
        if self.bondCount is not None and 'bondCount' not in already_processed:
            already_processed.add('bondCount')
            outfile.write(' bondCount="%s"' % self.gds_format_integer(self.bondCount, input_name='bondCount'))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='coordinationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for bond_ in self.bond:
            bond_.export(outfile, level, namespace_, name_='bond', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='coordinationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.bondCount is not None and 'bondCount' not in already_processed:
            already_processed.add('bondCount')
            showIndent(outfile, level)
            outfile.write('bondCount=%d,\n' % (self.bondCount,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('bond=[\n')
        level += 1
        for bond_ in self.bond:
            showIndent(outfile, level)
            outfile.write('model_.bondType(\n')
            bond_.exportLiteral(outfile, level, name_='bondType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('bondCount', node)
        if value is not None and 'bondCount' not in already_processed:
            already_processed.add('bondCount')
            try:
                self.bondCount = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.bondCount < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'bond':
            obj_ = bondType.factory()
            obj_.build(child_)
            self.bond.append(obj_)
            obj_.original_tagname_ = 'bond'
# end class coordinationType


class bondType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id2=None, id1=None, valueOf_=None):
        self.original_tagname_ = None
        self.id2 = _cast(None, id2)
        self.id1 = _cast(None, id1)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if bondType.subclass:
            return bondType.subclass(*args_, **kwargs_)
        else:
            return bondType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id2(self): return self.id2
    def set_id2(self, id2): self.id2 = id2
    def get_id1(self): return self.id1
    def set_id1(self, id1): self.id1 = id1
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='bondType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='bondType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='bondType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='bondType'):
        if self.id2 is not None and 'id2' not in already_processed:
            already_processed.add('id2')
            outfile.write(' id2=%s' % (self.gds_format_string(quote_attrib(self.id2).encode(ExternalEncoding), input_name='id2'), ))
        if self.id1 is not None and 'id1' not in already_processed:
            already_processed.add('id1')
            outfile.write(' id1=%s' % (self.gds_format_string(quote_attrib(self.id1).encode(ExternalEncoding), input_name='id1'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='bondType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='bondType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id2 is not None and 'id2' not in already_processed:
            already_processed.add('id2')
            showIndent(outfile, level)
            outfile.write('id2="%s",\n' % (self.id2,))
        if self.id1 is not None and 'id1' not in already_processed:
            already_processed.add('id1')
            showIndent(outfile, level)
            outfile.write('id1="%s",\n' % (self.id1,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id2', node)
        if value is not None and 'id2' not in already_processed:
            already_processed.add('id2')
            self.id2 = value
        value = find_attr_value_('id1', node)
        if value is not None and 'id1' not in already_processed:
            already_processed.add('id1')
            self.id1 = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class bondType


class mcType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mmCalculation=None, scfCalculation=None, kineticRateConstants=None, equilibriumConstants=None, mmMolecularDynamics=None, scfMolecularDynamics=None):
        self.original_tagname_ = None
        self.mmCalculation = mmCalculation
        self.scfCalculation = scfCalculation
        self.kineticRateConstants = kineticRateConstants
        self.equilibriumConstants = equilibriumConstants
        self.mmMolecularDynamics = mmMolecularDynamics
        self.scfMolecularDynamics = scfMolecularDynamics
    def factory(*args_, **kwargs_):
        if mcType.subclass:
            return mcType.subclass(*args_, **kwargs_)
        else:
            return mcType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mmCalculation(self): return self.mmCalculation
    def set_mmCalculation(self, mmCalculation): self.mmCalculation = mmCalculation
    def get_scfCalculation(self): return self.scfCalculation
    def set_scfCalculation(self, scfCalculation): self.scfCalculation = scfCalculation
    def get_kineticRateConstants(self): return self.kineticRateConstants
    def set_kineticRateConstants(self, kineticRateConstants): self.kineticRateConstants = kineticRateConstants
    def get_equilibriumConstants(self): return self.equilibriumConstants
    def set_equilibriumConstants(self, equilibriumConstants): self.equilibriumConstants = equilibriumConstants
    def get_mmMolecularDynamics(self): return self.mmMolecularDynamics
    def set_mmMolecularDynamics(self, mmMolecularDynamics): self.mmMolecularDynamics = mmMolecularDynamics
    def get_scfMolecularDynamics(self): return self.scfMolecularDynamics
    def set_scfMolecularDynamics(self, scfMolecularDynamics): self.scfMolecularDynamics = scfMolecularDynamics
    def hasContent_(self):
        if (
            self.mmCalculation is not None or
            self.scfCalculation is not None or
            self.kineticRateConstants is not None or
            self.equilibriumConstants is not None or
            self.mmMolecularDynamics is not None or
            self.scfMolecularDynamics is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='mcType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mcType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='mcType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='mcType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='mcType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mmCalculation is not None:
            self.mmCalculation.export(outfile, level, namespace_, name_='mmCalculation', pretty_print=pretty_print)
        if self.scfCalculation is not None:
            self.scfCalculation.export(outfile, level, namespace_, name_='scfCalculation', pretty_print=pretty_print)
        if self.kineticRateConstants is not None:
            self.kineticRateConstants.export(outfile, level, namespace_, name_='kineticRateConstants', pretty_print=pretty_print)
        if self.equilibriumConstants is not None:
            self.equilibriumConstants.export(outfile, level, namespace_, name_='equilibriumConstants', pretty_print=pretty_print)
        if self.mmMolecularDynamics is not None:
            self.mmMolecularDynamics.export(outfile, level, namespace_, name_='mmMolecularDynamics', pretty_print=pretty_print)
        if self.scfMolecularDynamics is not None:
            self.scfMolecularDynamics.export(outfile, level, namespace_, name_='scfMolecularDynamics', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='mcType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.mmCalculation is not None:
            showIndent(outfile, level)
            outfile.write('mmCalculation=model_.mmCalcType(\n')
            self.mmCalculation.exportLiteral(outfile, level, name_='mmCalculation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.scfCalculation is not None:
            showIndent(outfile, level)
            outfile.write('scfCalculation=model_.scfCalcType(\n')
            self.scfCalculation.exportLiteral(outfile, level, name_='scfCalculation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.kineticRateConstants is not None:
            showIndent(outfile, level)
            outfile.write('kineticRateConstants=model_.rateConsType(\n')
            self.kineticRateConstants.exportLiteral(outfile, level, name_='kineticRateConstants')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.equilibriumConstants is not None:
            showIndent(outfile, level)
            outfile.write('equilibriumConstants=model_.eqmConsType(\n')
            self.equilibriumConstants.exportLiteral(outfile, level, name_='equilibriumConstants')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.mmMolecularDynamics is not None:
            showIndent(outfile, level)
            outfile.write('mmMolecularDynamics=model_.molDynamType(\n')
            self.mmMolecularDynamics.exportLiteral(outfile, level, name_='mmMolecularDynamics')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.scfMolecularDynamics is not None:
            showIndent(outfile, level)
            outfile.write('scfMolecularDynamics=model_.molDynamType(\n')
            self.scfMolecularDynamics.exportLiteral(outfile, level, name_='scfMolecularDynamics')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mmCalculation':
            obj_ = mmCalcType.factory()
            obj_.build(child_)
            self.mmCalculation = obj_
            obj_.original_tagname_ = 'mmCalculation'
        elif nodeName_ == 'scfCalculation':
            obj_ = scfCalcType.factory()
            obj_.build(child_)
            self.scfCalculation = obj_
            obj_.original_tagname_ = 'scfCalculation'
        elif nodeName_ == 'kineticRateConstants':
            obj_ = rateConsType.factory()
            obj_.build(child_)
            self.kineticRateConstants = obj_
            obj_.original_tagname_ = 'kineticRateConstants'
        elif nodeName_ == 'equilibriumConstants':
            obj_ = eqmConsType.factory()
            obj_.build(child_)
            self.equilibriumConstants = obj_
            obj_.original_tagname_ = 'equilibriumConstants'
        elif nodeName_ == 'mmMolecularDynamics':
            obj_ = molDynamType.factory()
            obj_.build(child_)
            self.mmMolecularDynamics = obj_
            obj_.original_tagname_ = 'mmMolecularDynamics'
        elif nodeName_ == 'scfMolecularDynamics':
            obj_ = molDynamType.factory()
            obj_.build(child_)
            self.scfMolecularDynamics = obj_
            obj_.original_tagname_ = 'scfMolecularDynamics'
# end class mcType


class mmCalcType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, parameterSet=None, technology=None, forceField=None, mmEnergies=None, scfWaveFunction=None, scfVibrationalAnalysis=None, scfElectronicSpectra=None):
        self.original_tagname_ = None
        self.parameterSet = _cast(None, parameterSet)
        self.technology = _cast(None, technology)
        self.forceField = _cast(None, forceField)
        self.mmEnergies = mmEnergies
        self.scfWaveFunction = scfWaveFunction
        self.scfVibrationalAnalysis = scfVibrationalAnalysis
        self.scfElectronicSpectra = scfElectronicSpectra
    def factory(*args_, **kwargs_):
        if mmCalcType.subclass:
            return mmCalcType.subclass(*args_, **kwargs_)
        else:
            return mmCalcType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mmEnergies(self): return self.mmEnergies
    def set_mmEnergies(self, mmEnergies): self.mmEnergies = mmEnergies
    def get_scfWaveFunction(self): return self.scfWaveFunction
    def set_scfWaveFunction(self, scfWaveFunction): self.scfWaveFunction = scfWaveFunction
    def get_scfVibrationalAnalysis(self): return self.scfVibrationalAnalysis
    def set_scfVibrationalAnalysis(self, scfVibrationalAnalysis): self.scfVibrationalAnalysis = scfVibrationalAnalysis
    def get_scfElectronicSpectra(self): return self.scfElectronicSpectra
    def set_scfElectronicSpectra(self, scfElectronicSpectra): self.scfElectronicSpectra = scfElectronicSpectra
    def get_parameterSet(self): return self.parameterSet
    def set_parameterSet(self, parameterSet): self.parameterSet = parameterSet
    def get_technology(self): return self.technology
    def set_technology(self, technology): self.technology = technology
    def get_forceField(self): return self.forceField
    def set_forceField(self, forceField): self.forceField = forceField
    def hasContent_(self):
        if (
            self.mmEnergies is not None or
            self.scfWaveFunction is not None or
            self.scfVibrationalAnalysis is not None or
            self.scfElectronicSpectra is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='mmCalcType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mmCalcType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='mmCalcType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='mmCalcType'):
        if self.parameterSet is not None and 'parameterSet' not in already_processed:
            already_processed.add('parameterSet')
            outfile.write(' parameterSet=%s' % (self.gds_format_string(quote_attrib(self.parameterSet).encode(ExternalEncoding), input_name='parameterSet'), ))
        if self.technology is not None and 'technology' not in already_processed:
            already_processed.add('technology')
            outfile.write(' technology=%s' % (self.gds_format_string(quote_attrib(self.technology).encode(ExternalEncoding), input_name='technology'), ))
        if self.forceField is not None and 'forceField' not in already_processed:
            already_processed.add('forceField')
            outfile.write(' forceField=%s' % (self.gds_format_string(quote_attrib(self.forceField).encode(ExternalEncoding), input_name='forceField'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='mmCalcType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mmEnergies is not None:
            self.mmEnergies.export(outfile, level, namespace_, name_='mmEnergies', pretty_print=pretty_print)
        if self.scfWaveFunction is not None:
            self.scfWaveFunction.export(outfile, level, namespace_, name_='scfWaveFunction', pretty_print=pretty_print)
        if self.scfVibrationalAnalysis is not None:
            self.scfVibrationalAnalysis.export(outfile, level, namespace_, name_='scfVibrationalAnalysis', pretty_print=pretty_print)
        if self.scfElectronicSpectra is not None:
            self.scfElectronicSpectra.export(outfile, level, namespace_, name_='scfElectronicSpectra', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='mmCalcType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.parameterSet is not None and 'parameterSet' not in already_processed:
            already_processed.add('parameterSet')
            showIndent(outfile, level)
            outfile.write('parameterSet="%s",\n' % (self.parameterSet,))
        if self.technology is not None and 'technology' not in already_processed:
            already_processed.add('technology')
            showIndent(outfile, level)
            outfile.write('technology="%s",\n' % (self.technology,))
        if self.forceField is not None and 'forceField' not in already_processed:
            already_processed.add('forceField')
            showIndent(outfile, level)
            outfile.write('forceField="%s",\n' % (self.forceField,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.mmEnergies is not None:
            showIndent(outfile, level)
            outfile.write('mmEnergies=model_.scfElecEnerType(\n')
            self.mmEnergies.exportLiteral(outfile, level, name_='mmEnergies')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.scfWaveFunction is not None:
            showIndent(outfile, level)
            outfile.write('scfWaveFunction=model_.scfWaveFuncType(\n')
            self.scfWaveFunction.exportLiteral(outfile, level, name_='scfWaveFunction')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.scfVibrationalAnalysis is not None:
            showIndent(outfile, level)
            outfile.write('scfVibrationalAnalysis=model_.scfVibAnalType(\n')
            self.scfVibrationalAnalysis.exportLiteral(outfile, level, name_='scfVibrationalAnalysis')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.scfElectronicSpectra is not None:
            showIndent(outfile, level)
            outfile.write('scfElectronicSpectra=model_.scfElecSpecType(\n')
            self.scfElectronicSpectra.exportLiteral(outfile, level, name_='scfElectronicSpectra')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('parameterSet', node)
        if value is not None and 'parameterSet' not in already_processed:
            already_processed.add('parameterSet')
            self.parameterSet = value
        value = find_attr_value_('technology', node)
        if value is not None and 'technology' not in already_processed:
            already_processed.add('technology')
            self.technology = value
        value = find_attr_value_('forceField', node)
        if value is not None and 'forceField' not in already_processed:
            already_processed.add('forceField')
            self.forceField = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mmEnergies':
            obj_ = scfElecEnerType.factory()
            obj_.build(child_)
            self.mmEnergies = obj_
            obj_.original_tagname_ = 'mmEnergies'
        elif nodeName_ == 'scfWaveFunction':
            obj_ = scfWaveFuncType.factory()
            obj_.build(child_)
            self.scfWaveFunction = obj_
            obj_.original_tagname_ = 'scfWaveFunction'
        elif nodeName_ == 'scfVibrationalAnalysis':
            obj_ = scfVibAnalType.factory()
            obj_.build(child_)
            self.scfVibrationalAnalysis = obj_
            obj_.original_tagname_ = 'scfVibrationalAnalysis'
        elif nodeName_ == 'scfElectronicSpectra':
            obj_ = scfElecSpecType.factory()
            obj_.build(child_)
            self.scfElectronicSpectra = obj_
            obj_.original_tagname_ = 'scfElectronicSpectra'
# end class mmCalcType


class scfCalcType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, cs_dftFunctional=None, cs_basisSet=None, cs_correlationFunctional=None, cs_exchangeFunctional=None, cs_technology=None, cs_spinType=None, cs_method=None, scfEnergies=None, scfWaveFunction=None, scfVibrationalAnalysis=None, scfElectronicSpectra=None):
        self.original_tagname_ = None
        self.cs_dftFunctional = _cast(None, cs_dftFunctional)
        self.cs_basisSet = _cast(None, cs_basisSet)
        self.cs_correlationFunctional = _cast(None, cs_correlationFunctional)
        self.cs_exchangeFunctional = _cast(None, cs_exchangeFunctional)
        self.cs_technology = _cast(None, cs_technology)
        self.cs_spinType = _cast(None, cs_spinType)
        self.cs_method = _cast(None, cs_method)
        self.scfEnergies = scfEnergies
        self.scfWaveFunction = scfWaveFunction
        self.scfVibrationalAnalysis = scfVibrationalAnalysis
        self.scfElectronicSpectra = scfElectronicSpectra
    def factory(*args_, **kwargs_):
        if scfCalcType.subclass:
            return scfCalcType.subclass(*args_, **kwargs_)
        else:
            return scfCalcType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_scfEnergies(self): return self.scfEnergies
    def set_scfEnergies(self, scfEnergies): self.scfEnergies = scfEnergies
    def get_scfWaveFunction(self): return self.scfWaveFunction
    def set_scfWaveFunction(self, scfWaveFunction): self.scfWaveFunction = scfWaveFunction
    def get_scfVibrationalAnalysis(self): return self.scfVibrationalAnalysis
    def set_scfVibrationalAnalysis(self, scfVibrationalAnalysis): self.scfVibrationalAnalysis = scfVibrationalAnalysis
    def get_scfElectronicSpectra(self): return self.scfElectronicSpectra
    def set_scfElectronicSpectra(self, scfElectronicSpectra): self.scfElectronicSpectra = scfElectronicSpectra
    def get_cs_dftFunctional(self): return self.cs_dftFunctional
    def set_cs_dftFunctional(self, cs_dftFunctional): self.cs_dftFunctional = cs_dftFunctional
    def get_cs_basisSet(self): return self.cs_basisSet
    def set_cs_basisSet(self, cs_basisSet): self.cs_basisSet = cs_basisSet
    def get_cs_correlationFunctional(self): return self.cs_correlationFunctional
    def set_cs_correlationFunctional(self, cs_correlationFunctional): self.cs_correlationFunctional = cs_correlationFunctional
    def get_cs_exchangeFunctional(self): return self.cs_exchangeFunctional
    def set_cs_exchangeFunctional(self, cs_exchangeFunctional): self.cs_exchangeFunctional = cs_exchangeFunctional
    def get_cs_technology(self): return self.cs_technology
    def set_cs_technology(self, cs_technology): self.cs_technology = cs_technology
    def get_cs_spinType(self): return self.cs_spinType
    def set_cs_spinType(self, cs_spinType): self.cs_spinType = cs_spinType
    def get_cs_method(self): return self.cs_method
    def set_cs_method(self, cs_method): self.cs_method = cs_method
    def hasContent_(self):
        if (
            self.scfEnergies is not None or
            self.scfWaveFunction is not None or
            self.scfVibrationalAnalysis is not None or
            self.scfElectronicSpectra is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='scfCalcType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='scfCalcType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='scfCalcType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='scfCalcType'):
        if self.cs_dftFunctional is not None and 'cs_dftFunctional' not in already_processed:
            already_processed.add('cs_dftFunctional')
            outfile.write(' cs:dftFunctional=%s' % (self.gds_format_string(quote_attrib(self.cs_dftFunctional).encode(ExternalEncoding), input_name='cs:dftFunctional'), ))
        if self.cs_basisSet is not None and 'cs_basisSet' not in already_processed:
            already_processed.add('cs_basisSet')
            outfile.write(' cs:basisSet=%s' % (self.gds_format_string(quote_attrib(self.cs_basisSet).encode(ExternalEncoding), input_name='cs:basisSet'), ))
        if self.cs_correlationFunctional is not None and 'cs_correlationFunctional' not in already_processed:
            already_processed.add('cs_correlationFunctional')
            outfile.write(' cs:correlationFunctional=%s' % (self.gds_format_string(quote_attrib(self.cs_correlationFunctional).encode(ExternalEncoding), input_name='cs:correlationFunctional'), ))
        if self.cs_exchangeFunctional is not None and 'cs_exchangeFunctional' not in already_processed:
            already_processed.add('cs_exchangeFunctional')
            outfile.write(' cs:exchangeFunctional=%s' % (self.gds_format_string(quote_attrib(self.cs_exchangeFunctional).encode(ExternalEncoding), input_name='cs:exchangeFunctional'), ))
        if self.cs_technology is not None and 'cs_technology' not in already_processed:
            already_processed.add('cs_technology')
            outfile.write(' cs:technology=%s' % (self.gds_format_string(quote_attrib(self.cs_technology).encode(ExternalEncoding), input_name='cs:technology'), ))
        if self.cs_spinType is not None and 'cs_spinType' not in already_processed:
            already_processed.add('cs_spinType')
            outfile.write(' cs:spinType=%s' % (self.gds_format_string(quote_attrib(self.cs_spinType).encode(ExternalEncoding), input_name='cs:spinType'), ))
        if self.cs_method is not None and 'cs_method' not in already_processed:
            already_processed.add('cs_method')
            outfile.write(' cs:method=%s' % (self.gds_format_string(quote_attrib(self.cs_method).encode(ExternalEncoding), input_name='cs:method'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='scfCalcType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.scfEnergies is not None:
            self.scfEnergies.export(outfile, level, namespace_, name_='scfEnergies', pretty_print=pretty_print)
        if self.scfWaveFunction is not None:
            self.scfWaveFunction.export(outfile, level, namespace_, name_='scfWaveFunction', pretty_print=pretty_print)
        if self.scfVibrationalAnalysis is not None:
            self.scfVibrationalAnalysis.export(outfile, level, namespace_, name_='scfVibrationalAnalysis', pretty_print=pretty_print)
        if self.scfElectronicSpectra is not None:
            self.scfElectronicSpectra.export(outfile, level, namespace_, name_='scfElectronicSpectra', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='scfCalcType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.cs_dftFunctional is not None and 'cs_dftFunctional' not in already_processed:
            already_processed.add('cs_dftFunctional')
            showIndent(outfile, level)
            outfile.write('cs_dftFunctional="%s",\n' % (self.cs_dftFunctional,))
        if self.cs_basisSet is not None and 'cs_basisSet' not in already_processed:
            already_processed.add('cs_basisSet')
            showIndent(outfile, level)
            outfile.write('cs_basisSet="%s",\n' % (self.cs_basisSet,))
        if self.cs_correlationFunctional is not None and 'cs_correlationFunctional' not in already_processed:
            already_processed.add('cs_correlationFunctional')
            showIndent(outfile, level)
            outfile.write('cs_correlationFunctional="%s",\n' % (self.cs_correlationFunctional,))
        if self.cs_exchangeFunctional is not None and 'cs_exchangeFunctional' not in already_processed:
            already_processed.add('cs_exchangeFunctional')
            showIndent(outfile, level)
            outfile.write('cs_exchangeFunctional="%s",\n' % (self.cs_exchangeFunctional,))
        if self.cs_technology is not None and 'cs_technology' not in already_processed:
            already_processed.add('cs_technology')
            showIndent(outfile, level)
            outfile.write('cs_technology="%s",\n' % (self.cs_technology,))
        if self.cs_spinType is not None and 'cs_spinType' not in already_processed:
            already_processed.add('cs_spinType')
            showIndent(outfile, level)
            outfile.write('cs_spinType="%s",\n' % (self.cs_spinType,))
        if self.cs_method is not None and 'cs_method' not in already_processed:
            already_processed.add('cs_method')
            showIndent(outfile, level)
            outfile.write('cs_method="%s",\n' % (self.cs_method,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.scfEnergies is not None:
            showIndent(outfile, level)
            outfile.write('scfEnergies=model_.scfElecEnerType(\n')
            self.scfEnergies.exportLiteral(outfile, level, name_='scfEnergies')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.scfWaveFunction is not None:
            showIndent(outfile, level)
            outfile.write('scfWaveFunction=model_.scfWaveFuncType(\n')
            self.scfWaveFunction.exportLiteral(outfile, level, name_='scfWaveFunction')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.scfVibrationalAnalysis is not None:
            showIndent(outfile, level)
            outfile.write('scfVibrationalAnalysis=model_.scfVibAnalType(\n')
            self.scfVibrationalAnalysis.exportLiteral(outfile, level, name_='scfVibrationalAnalysis')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.scfElectronicSpectra is not None:
            showIndent(outfile, level)
            outfile.write('scfElectronicSpectra=model_.scfElecSpecType(\n')
            self.scfElectronicSpectra.exportLiteral(outfile, level, name_='scfElectronicSpectra')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cs:dftFunctional', node)
        if value is not None and 'cs:dftFunctional' not in already_processed:
            already_processed.add('cs:dftFunctional')
            self.cs_dftFunctional = value
        value = find_attr_value_('cs:basisSet', node)
        if value is not None and 'cs:basisSet' not in already_processed:
            already_processed.add('cs:basisSet')
            self.cs_basisSet = value
        value = find_attr_value_('cs:correlationFunctional', node)
        if value is not None and 'cs:correlationFunctional' not in already_processed:
            already_processed.add('cs:correlationFunctional')
            self.cs_correlationFunctional = value
        value = find_attr_value_('cs:exchangeFunctional', node)
        if value is not None and 'cs:exchangeFunctional' not in already_processed:
            already_processed.add('cs:exchangeFunctional')
            self.cs_exchangeFunctional = value
        value = find_attr_value_('cs:technology', node)
        if value is not None and 'cs:technology' not in already_processed:
            already_processed.add('cs:technology')
            self.cs_technology = value
        value = find_attr_value_('cs:spinType', node)
        if value is not None and 'cs:spinType' not in already_processed:
            already_processed.add('cs:spinType')
            self.cs_spinType = value
        value = find_attr_value_('cs:method', node)
        if value is not None and 'cs:method' not in already_processed:
            already_processed.add('cs:method')
            self.cs_method = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'scfEnergies':
            obj_ = scfElecEnerType.factory()
            obj_.build(child_)
            self.scfEnergies = obj_
            obj_.original_tagname_ = 'scfEnergies'
        elif nodeName_ == 'scfWaveFunction':
            obj_ = scfWaveFuncType.factory()
            obj_.build(child_)
            self.scfWaveFunction = obj_
            obj_.original_tagname_ = 'scfWaveFunction'
        elif nodeName_ == 'scfVibrationalAnalysis':
            obj_ = scfVibAnalType.factory()
            obj_.build(child_)
            self.scfVibrationalAnalysis = obj_
            obj_.original_tagname_ = 'scfVibrationalAnalysis'
        elif nodeName_ == 'scfElectronicSpectra':
            obj_ = scfElecSpecType.factory()
            obj_.build(child_)
            self.scfElectronicSpectra = obj_
            obj_.original_tagname_ = 'scfElectronicSpectra'
# end class scfCalcType


class scfElecEnerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, cs_units=None, scfElectronicEnergy=None, nuclearRepulsionEnergy=None, totalPotentialEnergy=None, rmsGradient=None, bindingEnergy=None, heatOfFormation=None):
        self.original_tagname_ = None
        self.cs_units = _cast(None, cs_units)
        self.scfElectronicEnergy = scfElectronicEnergy
        self.nuclearRepulsionEnergy = nuclearRepulsionEnergy
        self.totalPotentialEnergy = totalPotentialEnergy
        self.rmsGradient = rmsGradient
        self.bindingEnergy = bindingEnergy
        self.heatOfFormation = heatOfFormation
    def factory(*args_, **kwargs_):
        if scfElecEnerType.subclass:
            return scfElecEnerType.subclass(*args_, **kwargs_)
        else:
            return scfElecEnerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_scfElectronicEnergy(self): return self.scfElectronicEnergy
    def set_scfElectronicEnergy(self, scfElectronicEnergy): self.scfElectronicEnergy = scfElectronicEnergy
    def get_nuclearRepulsionEnergy(self): return self.nuclearRepulsionEnergy
    def set_nuclearRepulsionEnergy(self, nuclearRepulsionEnergy): self.nuclearRepulsionEnergy = nuclearRepulsionEnergy
    def get_totalPotentialEnergy(self): return self.totalPotentialEnergy
    def set_totalPotentialEnergy(self, totalPotentialEnergy): self.totalPotentialEnergy = totalPotentialEnergy
    def get_rmsGradient(self): return self.rmsGradient
    def set_rmsGradient(self, rmsGradient): self.rmsGradient = rmsGradient
    def get_bindingEnergy(self): return self.bindingEnergy
    def set_bindingEnergy(self, bindingEnergy): self.bindingEnergy = bindingEnergy
    def get_heatOfFormation(self): return self.heatOfFormation
    def set_heatOfFormation(self, heatOfFormation): self.heatOfFormation = heatOfFormation
    def get_cs_units(self): return self.cs_units
    def set_cs_units(self, cs_units): self.cs_units = cs_units
    def hasContent_(self):
        if (
            self.scfElectronicEnergy is not None or
            self.nuclearRepulsionEnergy is not None or
            self.totalPotentialEnergy is not None or
            self.rmsGradient is not None or
            self.bindingEnergy is not None or
            self.heatOfFormation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='scfElecEnerType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='scfElecEnerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='scfElecEnerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='scfElecEnerType'):
        if self.cs_units is not None and 'cs_units' not in already_processed:
            already_processed.add('cs_units')
            outfile.write(' cs:units=%s' % (self.gds_format_string(quote_attrib(self.cs_units).encode(ExternalEncoding), input_name='cs:units'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='scfElecEnerType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.scfElectronicEnergy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sscfElectronicEnergy>%s</%sscfElectronicEnergy>%s' % (namespace_, self.gds_format_double(self.scfElectronicEnergy, input_name='scfElectronicEnergy'), namespace_, eol_))
        if self.nuclearRepulsionEnergy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snuclearRepulsionEnergy>%s</%snuclearRepulsionEnergy>%s' % (namespace_, self.gds_format_double(self.nuclearRepulsionEnergy, input_name='nuclearRepulsionEnergy'), namespace_, eol_))
        if self.totalPotentialEnergy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalPotentialEnergy>%s</%stotalPotentialEnergy>%s' % (namespace_, self.gds_format_double(self.totalPotentialEnergy, input_name='totalPotentialEnergy'), namespace_, eol_))
        if self.rmsGradient is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srmsGradient>%s</%srmsGradient>%s' % (namespace_, self.gds_format_double(self.rmsGradient, input_name='rmsGradient'), namespace_, eol_))
        if self.bindingEnergy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbindingEnergy>%s</%sbindingEnergy>%s' % (namespace_, self.gds_format_double(self.bindingEnergy, input_name='bindingEnergy'), namespace_, eol_))
        if self.heatOfFormation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sheatOfFormation>%s</%sheatOfFormation>%s' % (namespace_, self.gds_format_double(self.heatOfFormation, input_name='heatOfFormation'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='scfElecEnerType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.cs_units is not None and 'cs_units' not in already_processed:
            already_processed.add('cs_units')
            showIndent(outfile, level)
            outfile.write('cs_units="%s",\n' % (self.cs_units,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.scfElectronicEnergy is not None:
            showIndent(outfile, level)
            outfile.write('scfElectronicEnergy=%e,\n' % self.scfElectronicEnergy)
        if self.nuclearRepulsionEnergy is not None:
            showIndent(outfile, level)
            outfile.write('nuclearRepulsionEnergy=%e,\n' % self.nuclearRepulsionEnergy)
        if self.totalPotentialEnergy is not None:
            showIndent(outfile, level)
            outfile.write('totalPotentialEnergy=%e,\n' % self.totalPotentialEnergy)
        if self.rmsGradient is not None:
            showIndent(outfile, level)
            outfile.write('rmsGradient=%e,\n' % self.rmsGradient)
        if self.bindingEnergy is not None:
            showIndent(outfile, level)
            outfile.write('bindingEnergy=%e,\n' % self.bindingEnergy)
        if self.heatOfFormation is not None:
            showIndent(outfile, level)
            outfile.write('heatOfFormation=%e,\n' % self.heatOfFormation)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cs:units', node)
        if value is not None and 'cs:units' not in already_processed:
            already_processed.add('cs:units')
            self.cs_units = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'scfElectronicEnergy':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'scfElectronicEnergy')
            self.scfElectronicEnergy = fval_
        elif nodeName_ == 'nuclearRepulsionEnergy':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'nuclearRepulsionEnergy')
            self.nuclearRepulsionEnergy = fval_
        elif nodeName_ == 'totalPotentialEnergy':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'totalPotentialEnergy')
            self.totalPotentialEnergy = fval_
        elif nodeName_ == 'rmsGradient':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'rmsGradient')
            self.rmsGradient = fval_
        elif nodeName_ == 'bindingEnergy':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'bindingEnergy')
            self.bindingEnergy = fval_
        elif nodeName_ == 'heatOfFormation':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'heatOfFormation')
            self.heatOfFormation = fval_
# end class scfElecEnerType


class scfWaveFuncType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, orbitalCount=None, orbitalEnergies=None, alphaOrbitalEnergies=None, betaOrbitalEnergies=None, orbitalOccupancies=None, alphaOrbitalOccupancies=None, betaOrbitalOccupancies=None, orbitals=None, alphaOrbitals=None, betaOrbitals=None):
        self.original_tagname_ = None
        self.orbitalCount = _cast(int, orbitalCount)
        self.orbitalEnergies = orbitalEnergies
        self.alphaOrbitalEnergies = alphaOrbitalEnergies
        self.betaOrbitalEnergies = betaOrbitalEnergies
        self.orbitalOccupancies = orbitalOccupancies
        self.alphaOrbitalOccupancies = alphaOrbitalOccupancies
        self.betaOrbitalOccupancies = betaOrbitalOccupancies
        self.orbitals = orbitals
        self.alphaOrbitals = alphaOrbitals
        self.betaOrbitals = betaOrbitals
    def factory(*args_, **kwargs_):
        if scfWaveFuncType.subclass:
            return scfWaveFuncType.subclass(*args_, **kwargs_)
        else:
            return scfWaveFuncType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_orbitalEnergies(self): return self.orbitalEnergies
    def set_orbitalEnergies(self, orbitalEnergies): self.orbitalEnergies = orbitalEnergies
    def get_alphaOrbitalEnergies(self): return self.alphaOrbitalEnergies
    def set_alphaOrbitalEnergies(self, alphaOrbitalEnergies): self.alphaOrbitalEnergies = alphaOrbitalEnergies
    def get_betaOrbitalEnergies(self): return self.betaOrbitalEnergies
    def set_betaOrbitalEnergies(self, betaOrbitalEnergies): self.betaOrbitalEnergies = betaOrbitalEnergies
    def get_orbitalOccupancies(self): return self.orbitalOccupancies
    def set_orbitalOccupancies(self, orbitalOccupancies): self.orbitalOccupancies = orbitalOccupancies
    def get_alphaOrbitalOccupancies(self): return self.alphaOrbitalOccupancies
    def set_alphaOrbitalOccupancies(self, alphaOrbitalOccupancies): self.alphaOrbitalOccupancies = alphaOrbitalOccupancies
    def get_betaOrbitalOccupancies(self): return self.betaOrbitalOccupancies
    def set_betaOrbitalOccupancies(self, betaOrbitalOccupancies): self.betaOrbitalOccupancies = betaOrbitalOccupancies
    def get_orbitals(self): return self.orbitals
    def set_orbitals(self, orbitals): self.orbitals = orbitals
    def get_alphaOrbitals(self): return self.alphaOrbitals
    def set_alphaOrbitals(self, alphaOrbitals): self.alphaOrbitals = alphaOrbitals
    def get_betaOrbitals(self): return self.betaOrbitals
    def set_betaOrbitals(self, betaOrbitals): self.betaOrbitals = betaOrbitals
    def get_orbitalCount(self): return self.orbitalCount
    def set_orbitalCount(self, orbitalCount): self.orbitalCount = orbitalCount
    def hasContent_(self):
        if (
            self.orbitalEnergies is not None or
            self.alphaOrbitalEnergies is not None or
            self.betaOrbitalEnergies is not None or
            self.orbitalOccupancies is not None or
            self.alphaOrbitalOccupancies is not None or
            self.betaOrbitalOccupancies is not None or
            self.orbitals is not None or
            self.alphaOrbitals is not None or
            self.betaOrbitals is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='scfWaveFuncType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='scfWaveFuncType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='scfWaveFuncType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='scfWaveFuncType'):
        if self.orbitalCount is not None and 'orbitalCount' not in already_processed:
            already_processed.add('orbitalCount')
            outfile.write(' cs:orbitalCount="%s"' % self.gds_format_integer(self.orbitalCount, input_name='orbitalCount'))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='scfWaveFuncType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orbitalEnergies is not None:
            self.orbitalEnergies.export(outfile, level, namespace_, name_='orbitalEnergies', pretty_print=pretty_print)
        if self.alphaOrbitalEnergies is not None:
            self.alphaOrbitalEnergies.export(outfile, level, namespace_, name_='alphaOrbitalEnergies', pretty_print=pretty_print)
        if self.betaOrbitalEnergies is not None:
            self.betaOrbitalEnergies.export(outfile, level, namespace_, name_='betaOrbitalEnergies', pretty_print=pretty_print)
        if self.orbitalOccupancies is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorbitalOccupancies>%s</%sorbitalOccupancies>%s' % (namespace_, self.gds_format_string(quote_xml(self.orbitalOccupancies).encode(ExternalEncoding), input_name='orbitalOccupancies'), namespace_, eol_))
        if self.alphaOrbitalOccupancies is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%salphaOrbitalOccupancies>%s</%salphaOrbitalOccupancies>%s' % (namespace_, self.gds_format_string(quote_xml(self.alphaOrbitalOccupancies).encode(ExternalEncoding), input_name='alphaOrbitalOccupancies'), namespace_, eol_))
        if self.betaOrbitalOccupancies is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbetaOrbitalOccupancies>%s</%sbetaOrbitalOccupancies>%s' % (namespace_, self.gds_format_string(quote_xml(self.betaOrbitalOccupancies).encode(ExternalEncoding), input_name='betaOrbitalOccupancies'), namespace_, eol_))
        if self.orbitals is not None:
            self.orbitals.export(outfile, level, namespace_, name_='orbitals', pretty_print=pretty_print)
        if self.alphaOrbitals is not None:
            self.alphaOrbitals.export(outfile, level, namespace_, name_='alphaOrbitals', pretty_print=pretty_print)
        if self.betaOrbitals is not None:
            self.betaOrbitals.export(outfile, level, namespace_, name_='betaOrbitals', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='scfWaveFuncType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.orbitalCount is not None and 'orbitalCount' not in already_processed:
            already_processed.add('orbitalCount')
            showIndent(outfile, level)
            outfile.write('orbitalCount=%d,\n' % (self.orbitalCount,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.orbitalEnergies is not None:
            showIndent(outfile, level)
            outfile.write('orbitalEnergies=model_.orbEnerType(\n')
            self.orbitalEnergies.exportLiteral(outfile, level, name_='orbitalEnergies')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.alphaOrbitalEnergies is not None:
            showIndent(outfile, level)
            outfile.write('alphaOrbitalEnergies=model_.orbEnerType(\n')
            self.alphaOrbitalEnergies.exportLiteral(outfile, level, name_='alphaOrbitalEnergies')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.betaOrbitalEnergies is not None:
            showIndent(outfile, level)
            outfile.write('betaOrbitalEnergies=model_.orbEnerType(\n')
            self.betaOrbitalEnergies.exportLiteral(outfile, level, name_='betaOrbitalEnergies')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.orbitalOccupancies is not None:
            showIndent(outfile, level)
            outfile.write('orbitalOccupancies=%s,\n' % quote_python(self.orbitalOccupancies).encode(ExternalEncoding))
        if self.alphaOrbitalOccupancies is not None:
            showIndent(outfile, level)
            outfile.write('alphaOrbitalOccupancies=%s,\n' % quote_python(self.alphaOrbitalOccupancies).encode(ExternalEncoding))
        if self.betaOrbitalOccupancies is not None:
            showIndent(outfile, level)
            outfile.write('betaOrbitalOccupancies=%s,\n' % quote_python(self.betaOrbitalOccupancies).encode(ExternalEncoding))
        if self.orbitals is not None:
            showIndent(outfile, level)
            outfile.write('orbitals=model_.orbitalsType(\n')
            self.orbitals.exportLiteral(outfile, level, name_='orbitals')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.alphaOrbitals is not None:
            showIndent(outfile, level)
            outfile.write('alphaOrbitals=model_.orbitalsType(\n')
            self.alphaOrbitals.exportLiteral(outfile, level, name_='alphaOrbitals')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.betaOrbitals is not None:
            showIndent(outfile, level)
            outfile.write('betaOrbitals=model_.orbitalsType(\n')
            self.betaOrbitals.exportLiteral(outfile, level, name_='betaOrbitals')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('orbitalCount', node)
        if value is not None and 'orbitalCount' not in already_processed:
            already_processed.add('orbitalCount')
            try:
                self.orbitalCount = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.orbitalCount <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orbitalEnergies':
            obj_ = orbEnerType.factory()
            obj_.build(child_)
            self.orbitalEnergies = obj_
            obj_.original_tagname_ = 'orbitalEnergies'
        elif nodeName_ == 'alphaOrbitalEnergies':
            obj_ = orbEnerType.factory()
            obj_.build(child_)
            self.alphaOrbitalEnergies = obj_
            obj_.original_tagname_ = 'alphaOrbitalEnergies'
        elif nodeName_ == 'betaOrbitalEnergies':
            obj_ = orbEnerType.factory()
            obj_.build(child_)
            self.betaOrbitalEnergies = obj_
            obj_.original_tagname_ = 'betaOrbitalEnergies'
        elif nodeName_ == 'orbitalOccupancies':
            orbitalOccupancies_ = child_.text
            orbitalOccupancies_ = self.gds_validate_string(orbitalOccupancies_, node, 'orbitalOccupancies')
            self.orbitalOccupancies = orbitalOccupancies_
        elif nodeName_ == 'alphaOrbitalOccupancies':
            alphaOrbitalOccupancies_ = child_.text
            alphaOrbitalOccupancies_ = self.gds_validate_string(alphaOrbitalOccupancies_, node, 'alphaOrbitalOccupancies')
            self.alphaOrbitalOccupancies = alphaOrbitalOccupancies_
        elif nodeName_ == 'betaOrbitalOccupancies':
            betaOrbitalOccupancies_ = child_.text
            betaOrbitalOccupancies_ = self.gds_validate_string(betaOrbitalOccupancies_, node, 'betaOrbitalOccupancies')
            self.betaOrbitalOccupancies = betaOrbitalOccupancies_
        elif nodeName_ == 'orbitals':
            obj_ = orbitalsType.factory()
            obj_.build(child_)
            self.orbitals = obj_
            obj_.original_tagname_ = 'orbitals'
        elif nodeName_ == 'alphaOrbitals':
            obj_ = orbitalsType.factory()
            obj_.build(child_)
            self.alphaOrbitals = obj_
            obj_.original_tagname_ = 'alphaOrbitals'
        elif nodeName_ == 'betaOrbitals':
            obj_ = orbitalsType.factory()
            obj_.build(child_)
            self.betaOrbitals = obj_
            obj_.original_tagname_ = 'betaOrbitals'
# end class scfWaveFuncType


class orbEnerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, cs_units=None, valueOf_=None):
        self.original_tagname_ = None
        self.cs_units = _cast(None, cs_units)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if orbEnerType.subclass:
            return orbEnerType.subclass(*args_, **kwargs_)
        else:
            return orbEnerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cs_units(self): return self.cs_units
    def set_cs_units(self, cs_units): self.cs_units = cs_units
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='orbEnerType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='orbEnerType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='orbEnerType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='orbEnerType'):
        if self.cs_units is not None and 'cs_units' not in already_processed:
            already_processed.add('cs_units')
            outfile.write(' cs:units=%s' % (self.gds_format_string(quote_attrib(self.cs_units).encode(ExternalEncoding), input_name='cs:units'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='orbEnerType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='orbEnerType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.cs_units is not None and 'cs_units' not in already_processed:
            already_processed.add('cs_units')
            showIndent(outfile, level)
            outfile.write('cs_units="%s",\n' % (self.cs_units,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cs:units', node)
        if value is not None and 'cs:units' not in already_processed:
            already_processed.add('cs:units')
            self.cs_units = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class orbEnerType


class orbitalsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, orbital=None):
        self.original_tagname_ = None
        if orbital is None:
            self.orbital = []
        else:
            self.orbital = orbital
    def factory(*args_, **kwargs_):
        if orbitalsType.subclass:
            return orbitalsType.subclass(*args_, **kwargs_)
        else:
            return orbitalsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_orbital(self): return self.orbital
    def set_orbital(self, orbital): self.orbital = orbital
    def add_orbital(self, value): self.orbital.append(value)
    def insert_orbital_at(self, index, value): self.orbital.insert(index, value)
    def replace_orbital_at(self, index, value): self.orbital[index] = value
    def hasContent_(self):
        if (
            self.orbital
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='orbitalsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='orbitalsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='orbitalsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='orbitalsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='orbitalsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for orbital_ in self.orbital:
            orbital_.export(outfile, level, namespace_, name_='orbital', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='orbitalsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('orbital=[\n')
        level += 1
        for orbital_ in self.orbital:
            showIndent(outfile, level)
            outfile.write('model_.orbitalType(\n')
            orbital_.exportLiteral(outfile, level, name_='orbitalType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orbital':
            obj_ = orbitalType.factory()
            obj_.build(child_)
            self.orbital.append(obj_)
            obj_.original_tagname_ = 'orbital'
# end class orbitalsType


class orbitalType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if orbitalType.subclass:
            return orbitalType.subclass(*args_, **kwargs_)
        else:
            return orbitalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='orbitalType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='orbitalType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='orbitalType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='orbitalType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='orbitalType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='orbitalType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class orbitalType


class scfVibAnalType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, cs_units=None, vibrationCount=None, vibrationalFrequencies=None, irIntensities=None, normalModes=None):
        self.original_tagname_ = None
        self.cs_units = _cast(None, cs_units)
        self.vibrationCount = _cast(int, vibrationCount)
        self.vibrationalFrequencies = vibrationalFrequencies
        self.irIntensities = irIntensities
        self.normalModes = normalModes
    def factory(*args_, **kwargs_):
        if scfVibAnalType.subclass:
            return scfVibAnalType.subclass(*args_, **kwargs_)
        else:
            return scfVibAnalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vibrationalFrequencies(self): return self.vibrationalFrequencies
    def set_vibrationalFrequencies(self, vibrationalFrequencies): self.vibrationalFrequencies = vibrationalFrequencies
    def get_irIntensities(self): return self.irIntensities
    def set_irIntensities(self, irIntensities): self.irIntensities = irIntensities
    def get_normalModes(self): return self.normalModes
    def set_normalModes(self, normalModes): self.normalModes = normalModes
    def get_cs_units(self): return self.cs_units
    def set_cs_units(self, cs_units): self.cs_units = cs_units
    def get_vibrationCount(self): return self.vibrationCount
    def set_vibrationCount(self, vibrationCount): self.vibrationCount = vibrationCount
    def hasContent_(self):
        if (
            self.vibrationalFrequencies is not None or
            self.irIntensities is not None or
            self.normalModes is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='scfVibAnalType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='scfVibAnalType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='scfVibAnalType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='scfVibAnalType'):
        if self.cs_units is not None and 'cs_units' not in already_processed:
            already_processed.add('cs_units')
            outfile.write(' cs:units=%s' % (self.gds_format_string(quote_attrib(self.cs_units).encode(ExternalEncoding), input_name='cs:units'), ))
        if self.vibrationCount is not None and 'vibrationCount' not in already_processed:
            already_processed.add('vibrationCount')
            outfile.write(' cs:vibrationCount="%s"' % self.gds_format_integer(self.vibrationCount, input_name='vibrationCount'))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='scfVibAnalType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vibrationalFrequencies is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svibrationalFrequencies>%s</%svibrationalFrequencies>%s' % (namespace_, self.gds_format_string(quote_xml(self.vibrationalFrequencies).encode(ExternalEncoding), input_name='vibrationalFrequencies'), namespace_, eol_))
        if self.irIntensities is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sirIntensities>%s</%sirIntensities>%s' % (namespace_, self.gds_format_string(quote_xml(self.irIntensities).encode(ExternalEncoding), input_name='irIntensities'), namespace_, eol_))
        if self.normalModes is not None:
            self.normalModes.export(outfile, level, namespace_, name_='normalModes', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='scfVibAnalType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.cs_units is not None and 'cs_units' not in already_processed:
            already_processed.add('cs_units')
            showIndent(outfile, level)
            outfile.write('cs_units="%s",\n' % (self.cs_units,))
        if self.vibrationCount is not None and 'vibrationCount' not in already_processed:
            already_processed.add('vibrationCount')
            showIndent(outfile, level)
            outfile.write('vibrationCount=%d,\n' % (self.vibrationCount,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.vibrationalFrequencies is not None:
            showIndent(outfile, level)
            outfile.write('vibrationalFrequencies=%s,\n' % quote_python(self.vibrationalFrequencies).encode(ExternalEncoding))
        if self.irIntensities is not None:
            showIndent(outfile, level)
            outfile.write('irIntensities=%s,\n' % quote_python(self.irIntensities).encode(ExternalEncoding))
        if self.normalModes is not None:
            showIndent(outfile, level)
            outfile.write('normalModes=model_.normalModesType(\n')
            self.normalModes.exportLiteral(outfile, level, name_='normalModes')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cs:units', node)
        if value is not None and 'cs:units' not in already_processed:
            already_processed.add('cs:units')
            self.cs_units = value
        value = find_attr_value_('vibrationCount', node)
        if value is not None and 'vibrationCount' not in already_processed:
            already_processed.add('vibrationCount')
            try:
                self.vibrationCount = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.vibrationCount <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vibrationalFrequencies':
            vibrationalFrequencies_ = child_.text
            vibrationalFrequencies_ = self.gds_validate_string(vibrationalFrequencies_, node, 'vibrationalFrequencies')
            self.vibrationalFrequencies = vibrationalFrequencies_
        elif nodeName_ == 'irIntensities':
            irIntensities_ = child_.text
            irIntensities_ = self.gds_validate_string(irIntensities_, node, 'irIntensities')
            self.irIntensities = irIntensities_
        elif nodeName_ == 'normalModes':
            obj_ = normalModesType.factory()
            obj_.build(child_)
            self.normalModes = obj_
            obj_.original_tagname_ = 'normalModes'
# end class scfVibAnalType


class normalModesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, normalMode=None):
        self.original_tagname_ = None
        if normalMode is None:
            self.normalMode = []
        else:
            self.normalMode = normalMode
    def factory(*args_, **kwargs_):
        if normalModesType.subclass:
            return normalModesType.subclass(*args_, **kwargs_)
        else:
            return normalModesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_normalMode(self): return self.normalMode
    def set_normalMode(self, normalMode): self.normalMode = normalMode
    def add_normalMode(self, value): self.normalMode.append(value)
    def insert_normalMode_at(self, index, value): self.normalMode.insert(index, value)
    def replace_normalMode_at(self, index, value): self.normalMode[index] = value
    def hasContent_(self):
        if (
            self.normalMode
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='normalModesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='normalModesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='normalModesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='normalModesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='normalModesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for normalMode_ in self.normalMode:
            normalMode_.export(outfile, level, namespace_, name_='normalMode', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='normalModesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('normalMode=[\n')
        level += 1
        for normalMode_ in self.normalMode:
            showIndent(outfile, level)
            outfile.write('model_.normalModeType(\n')
            normalMode_.exportLiteral(outfile, level, name_='normalModeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'normalMode':
            obj_ = normalModeType.factory()
            obj_.build(child_)
            self.normalMode.append(obj_)
            obj_.original_tagname_ = 'normalMode'
# end class normalModesType


class normalModeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if normalModeType.subclass:
            return normalModeType.subclass(*args_, **kwargs_)
        else:
            return normalModeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='normalModeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='normalModeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='normalModeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='normalModeType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='normalModeType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='normalModeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class normalModeType


class scfElecSpecType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ciOccupiedOrbitalsIncluded=None, transitionCount=None, ciUnoccupiedOrbitalsIncluded=None, excitedStateMethod=None, cs_units=None, electronicTransitions=None, oscillatorStrength=None):
        self.original_tagname_ = None
        self.ciOccupiedOrbitalsIncluded = _cast(int, ciOccupiedOrbitalsIncluded)
        self.transitionCount = _cast(int, transitionCount)
        self.ciUnoccupiedOrbitalsIncluded = _cast(int, ciUnoccupiedOrbitalsIncluded)
        self.excitedStateMethod = _cast(None, excitedStateMethod)
        self.cs_units = _cast(None, cs_units)
        self.electronicTransitions = electronicTransitions
        self.oscillatorStrength = oscillatorStrength
    def factory(*args_, **kwargs_):
        if scfElecSpecType.subclass:
            return scfElecSpecType.subclass(*args_, **kwargs_)
        else:
            return scfElecSpecType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_electronicTransitions(self): return self.electronicTransitions
    def set_electronicTransitions(self, electronicTransitions): self.electronicTransitions = electronicTransitions
    def get_oscillatorStrength(self): return self.oscillatorStrength
    def set_oscillatorStrength(self, oscillatorStrength): self.oscillatorStrength = oscillatorStrength
    def get_ciOccupiedOrbitalsIncluded(self): return self.ciOccupiedOrbitalsIncluded
    def set_ciOccupiedOrbitalsIncluded(self, ciOccupiedOrbitalsIncluded): self.ciOccupiedOrbitalsIncluded = ciOccupiedOrbitalsIncluded
    def get_transitionCount(self): return self.transitionCount
    def set_transitionCount(self, transitionCount): self.transitionCount = transitionCount
    def get_ciUnoccupiedOrbitalsIncluded(self): return self.ciUnoccupiedOrbitalsIncluded
    def set_ciUnoccupiedOrbitalsIncluded(self, ciUnoccupiedOrbitalsIncluded): self.ciUnoccupiedOrbitalsIncluded = ciUnoccupiedOrbitalsIncluded
    def get_excitedStateMethod(self): return self.excitedStateMethod
    def set_excitedStateMethod(self, excitedStateMethod): self.excitedStateMethod = excitedStateMethod
    def get_cs_units(self): return self.cs_units
    def set_cs_units(self, cs_units): self.cs_units = cs_units
    def hasContent_(self):
        if (
            self.electronicTransitions is not None or
            self.oscillatorStrength is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='scfElecSpecType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='scfElecSpecType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='scfElecSpecType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='scfElecSpecType'):
        if self.ciOccupiedOrbitalsIncluded is not None and 'ciOccupiedOrbitalsIncluded' not in already_processed:
            already_processed.add('ciOccupiedOrbitalsIncluded')
            outfile.write(' ciOccupiedOrbitalsIncluded="%s"' % self.gds_format_integer(self.ciOccupiedOrbitalsIncluded, input_name='ciOccupiedOrbitalsIncluded'))
        if self.transitionCount is not None and 'transitionCount' not in already_processed:
            already_processed.add('transitionCount')
            outfile.write(' transitionCount="%s"' % self.gds_format_integer(self.transitionCount, input_name='transitionCount'))
        if self.ciUnoccupiedOrbitalsIncluded is not None and 'ciUnoccupiedOrbitalsIncluded' not in already_processed:
            already_processed.add('ciUnoccupiedOrbitalsIncluded')
            outfile.write(' ciUnoccupiedOrbitalsIncluded="%s"' % self.gds_format_integer(self.ciUnoccupiedOrbitalsIncluded, input_name='ciUnoccupiedOrbitalsIncluded'))
        if self.excitedStateMethod is not None and 'excitedStateMethod' not in already_processed:
            already_processed.add('excitedStateMethod')
            outfile.write(' excitedStateMethod=%s' % (self.gds_format_string(quote_attrib(self.excitedStateMethod).encode(ExternalEncoding), input_name='excitedStateMethod'), ))
        if self.cs_units is not None and 'cs_units' not in already_processed:
            already_processed.add('cs_units')
            outfile.write(' cs:units=%s' % (self.gds_format_string(quote_attrib(self.cs_units).encode(ExternalEncoding), input_name='cs:units'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='scfElecSpecType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.electronicTransitions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%selectronicTransitions>%s</%selectronicTransitions>%s' % (namespace_, self.gds_format_string(quote_xml(self.electronicTransitions).encode(ExternalEncoding), input_name='electronicTransitions'), namespace_, eol_))
        if self.oscillatorStrength is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soscillatorStrength>%s</%soscillatorStrength>%s' % (namespace_, self.gds_format_string(quote_xml(self.oscillatorStrength).encode(ExternalEncoding), input_name='oscillatorStrength'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='scfElecSpecType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ciOccupiedOrbitalsIncluded is not None and 'ciOccupiedOrbitalsIncluded' not in already_processed:
            already_processed.add('ciOccupiedOrbitalsIncluded')
            showIndent(outfile, level)
            outfile.write('ciOccupiedOrbitalsIncluded=%d,\n' % (self.ciOccupiedOrbitalsIncluded,))
        if self.transitionCount is not None and 'transitionCount' not in already_processed:
            already_processed.add('transitionCount')
            showIndent(outfile, level)
            outfile.write('transitionCount=%d,\n' % (self.transitionCount,))
        if self.ciUnoccupiedOrbitalsIncluded is not None and 'ciUnoccupiedOrbitalsIncluded' not in already_processed:
            already_processed.add('ciUnoccupiedOrbitalsIncluded')
            showIndent(outfile, level)
            outfile.write('ciUnoccupiedOrbitalsIncluded=%d,\n' % (self.ciUnoccupiedOrbitalsIncluded,))
        if self.excitedStateMethod is not None and 'excitedStateMethod' not in already_processed:
            already_processed.add('excitedStateMethod')
            showIndent(outfile, level)
            outfile.write('excitedStateMethod="%s",\n' % (self.excitedStateMethod,))
        if self.cs_units is not None and 'cs_units' not in already_processed:
            already_processed.add('cs_units')
            showIndent(outfile, level)
            outfile.write('cs_units="%s",\n' % (self.cs_units,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.electronicTransitions is not None:
            showIndent(outfile, level)
            outfile.write('electronicTransitions=%s,\n' % quote_python(self.electronicTransitions).encode(ExternalEncoding))
        if self.oscillatorStrength is not None:
            showIndent(outfile, level)
            outfile.write('oscillatorStrength=%s,\n' % quote_python(self.oscillatorStrength).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ciOccupiedOrbitalsIncluded', node)
        if value is not None and 'ciOccupiedOrbitalsIncluded' not in already_processed:
            already_processed.add('ciOccupiedOrbitalsIncluded')
            try:
                self.ciOccupiedOrbitalsIncluded = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ciOccupiedOrbitalsIncluded <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('transitionCount', node)
        if value is not None and 'transitionCount' not in already_processed:
            already_processed.add('transitionCount')
            try:
                self.transitionCount = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.transitionCount <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('ciUnoccupiedOrbitalsIncluded', node)
        if value is not None and 'ciUnoccupiedOrbitalsIncluded' not in already_processed:
            already_processed.add('ciUnoccupiedOrbitalsIncluded')
            try:
                self.ciUnoccupiedOrbitalsIncluded = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ciUnoccupiedOrbitalsIncluded <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('excitedStateMethod', node)
        if value is not None and 'excitedStateMethod' not in already_processed:
            already_processed.add('excitedStateMethod')
            self.excitedStateMethod = value
        value = find_attr_value_('cs:units', node)
        if value is not None and 'cs:units' not in already_processed:
            already_processed.add('cs:units')
            self.cs_units = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'electronicTransitions':
            electronicTransitions_ = child_.text
            electronicTransitions_ = self.gds_validate_string(electronicTransitions_, node, 'electronicTransitions')
            self.electronicTransitions = electronicTransitions_
        elif nodeName_ == 'oscillatorStrength':
            oscillatorStrength_ = child_.text
            oscillatorStrength_ = self.gds_validate_string(oscillatorStrength_, node, 'oscillatorStrength')
            self.oscillatorStrength = oscillatorStrength_
# end class scfElecSpecType


class molDynamType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mdTimeStep=None, mdTemperatureUnits=None, mdRunTime=None, mdTimeUnits=None, mdTemperature=None, mdStep=None):
        self.original_tagname_ = None
        self.mdTimeStep = _cast(float, mdTimeStep)
        self.mdTemperatureUnits = _cast(None, mdTemperatureUnits)
        self.mdRunTime = _cast(float, mdRunTime)
        self.mdTimeUnits = _cast(None, mdTimeUnits)
        self.mdTemperature = _cast(float, mdTemperature)
        if mdStep is None:
            self.mdStep = []
        else:
            self.mdStep = mdStep
    def factory(*args_, **kwargs_):
        if molDynamType.subclass:
            return molDynamType.subclass(*args_, **kwargs_)
        else:
            return molDynamType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mdStep(self): return self.mdStep
    def set_mdStep(self, mdStep): self.mdStep = mdStep
    def add_mdStep(self, value): self.mdStep.append(value)
    def insert_mdStep_at(self, index, value): self.mdStep.insert(index, value)
    def replace_mdStep_at(self, index, value): self.mdStep[index] = value
    def get_mdTimeStep(self): return self.mdTimeStep
    def set_mdTimeStep(self, mdTimeStep): self.mdTimeStep = mdTimeStep
    def get_mdTemperatureUnits(self): return self.mdTemperatureUnits
    def set_mdTemperatureUnits(self, mdTemperatureUnits): self.mdTemperatureUnits = mdTemperatureUnits
    def get_mdRunTime(self): return self.mdRunTime
    def set_mdRunTime(self, mdRunTime): self.mdRunTime = mdRunTime
    def get_mdTimeUnits(self): return self.mdTimeUnits
    def set_mdTimeUnits(self, mdTimeUnits): self.mdTimeUnits = mdTimeUnits
    def get_mdTemperature(self): return self.mdTemperature
    def set_mdTemperature(self, mdTemperature): self.mdTemperature = mdTemperature
    def hasContent_(self):
        if (
            self.mdStep
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='molDynamType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='molDynamType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='molDynamType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='molDynamType'):
        if self.mdTimeStep is not None and 'mdTimeStep' not in already_processed:
            already_processed.add('mdTimeStep')
            outfile.write(' mdTimeStep="%s"' % self.gds_format_float(self.mdTimeStep, input_name='mdTimeStep'))
        if self.mdTemperatureUnits is not None and 'mdTemperatureUnits' not in already_processed:
            already_processed.add('mdTemperatureUnits')
            outfile.write(' mdTemperatureUnits=%s' % (self.gds_format_string(quote_attrib(self.mdTemperatureUnits).encode(ExternalEncoding), input_name='mdTemperatureUnits'), ))
        if self.mdRunTime is not None and 'mdRunTime' not in already_processed:
            already_processed.add('mdRunTime')
            outfile.write(' mdRunTime="%s"' % self.gds_format_float(self.mdRunTime, input_name='mdRunTime'))
        if self.mdTimeUnits is not None and 'mdTimeUnits' not in already_processed:
            already_processed.add('mdTimeUnits')
            outfile.write(' mdTimeUnits=%s' % (self.gds_format_string(quote_attrib(self.mdTimeUnits).encode(ExternalEncoding), input_name='mdTimeUnits'), ))
        if self.mdTemperature is not None and 'mdTemperature' not in already_processed:
            already_processed.add('mdTemperature')
            outfile.write(' mdTemperature="%s"' % self.gds_format_float(self.mdTemperature, input_name='mdTemperature'))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='molDynamType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for mdStep_ in self.mdStep:
            mdStep_.export(outfile, level, namespace_, name_='mdStep', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='molDynamType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.mdTimeStep is not None and 'mdTimeStep' not in already_processed:
            already_processed.add('mdTimeStep')
            showIndent(outfile, level)
            outfile.write('mdTimeStep=%f,\n' % (self.mdTimeStep,))
        if self.mdTemperatureUnits is not None and 'mdTemperatureUnits' not in already_processed:
            already_processed.add('mdTemperatureUnits')
            showIndent(outfile, level)
            outfile.write('mdTemperatureUnits="%s",\n' % (self.mdTemperatureUnits,))
        if self.mdRunTime is not None and 'mdRunTime' not in already_processed:
            already_processed.add('mdRunTime')
            showIndent(outfile, level)
            outfile.write('mdRunTime=%f,\n' % (self.mdRunTime,))
        if self.mdTimeUnits is not None and 'mdTimeUnits' not in already_processed:
            already_processed.add('mdTimeUnits')
            showIndent(outfile, level)
            outfile.write('mdTimeUnits="%s",\n' % (self.mdTimeUnits,))
        if self.mdTemperature is not None and 'mdTemperature' not in already_processed:
            already_processed.add('mdTemperature')
            showIndent(outfile, level)
            outfile.write('mdTemperature=%f,\n' % (self.mdTemperature,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('mdStep=[\n')
        level += 1
        for mdStep_ in self.mdStep:
            showIndent(outfile, level)
            outfile.write('model_.mdStepType(\n')
            mdStep_.exportLiteral(outfile, level, name_='mdStepType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mdTimeStep', node)
        if value is not None and 'mdTimeStep' not in already_processed:
            already_processed.add('mdTimeStep')
            try:
                self.mdTimeStep = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (mdTimeStep): %s' % exp)
        value = find_attr_value_('mdTemperatureUnits', node)
        if value is not None and 'mdTemperatureUnits' not in already_processed:
            already_processed.add('mdTemperatureUnits')
            self.mdTemperatureUnits = value
        value = find_attr_value_('mdRunTime', node)
        if value is not None and 'mdRunTime' not in already_processed:
            already_processed.add('mdRunTime')
            try:
                self.mdRunTime = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (mdRunTime): %s' % exp)
        value = find_attr_value_('mdTimeUnits', node)
        if value is not None and 'mdTimeUnits' not in already_processed:
            already_processed.add('mdTimeUnits')
            self.mdTimeUnits = value
        value = find_attr_value_('mdTemperature', node)
        if value is not None and 'mdTemperature' not in already_processed:
            already_processed.add('mdTemperature')
            try:
                self.mdTemperature = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (mdTemperature): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mdStep':
            obj_ = mdStepType.factory()
            obj_.build(child_)
            self.mdStep.append(obj_)
            obj_.original_tagname_ = 'mdStep'
# end class molDynamType


class mdStepType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, step=None, mdPhaseCoord=None):
        self.original_tagname_ = None
        self.step = _cast(int, step)
        if mdPhaseCoord is None:
            self.mdPhaseCoord = []
        else:
            self.mdPhaseCoord = mdPhaseCoord
    def factory(*args_, **kwargs_):
        if mdStepType.subclass:
            return mdStepType.subclass(*args_, **kwargs_)
        else:
            return mdStepType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mdPhaseCoord(self): return self.mdPhaseCoord
    def set_mdPhaseCoord(self, mdPhaseCoord): self.mdPhaseCoord = mdPhaseCoord
    def add_mdPhaseCoord(self, value): self.mdPhaseCoord.append(value)
    def insert_mdPhaseCoord_at(self, index, value): self.mdPhaseCoord.insert(index, value)
    def replace_mdPhaseCoord_at(self, index, value): self.mdPhaseCoord[index] = value
    def get_step(self): return self.step
    def set_step(self, step): self.step = step
    def hasContent_(self):
        if (
            self.mdPhaseCoord
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='mdStepType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mdStepType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='mdStepType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='mdStepType'):
        if self.step is not None and 'step' not in already_processed:
            already_processed.add('step')
            outfile.write(' step="%s"' % self.gds_format_integer(self.step, input_name='step'))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='mdStepType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for mdPhaseCoord_ in self.mdPhaseCoord:
            mdPhaseCoord_.export(outfile, level, namespace_, name_='mdPhaseCoord', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='mdStepType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.step is not None and 'step' not in already_processed:
            already_processed.add('step')
            showIndent(outfile, level)
            outfile.write('step=%d,\n' % (self.step,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('mdPhaseCoord=[\n')
        level += 1
        for mdPhaseCoord_ in self.mdPhaseCoord:
            showIndent(outfile, level)
            outfile.write('model_.phasCoordType(\n')
            mdPhaseCoord_.exportLiteral(outfile, level, name_='phasCoordType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('step', node)
        if value is not None and 'step' not in already_processed:
            already_processed.add('step')
            try:
                self.step = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mdPhaseCoord':
            obj_ = phasCoordType.factory()
            obj_.build(child_)
            self.mdPhaseCoord.append(obj_)
            obj_.original_tagname_ = 'mdPhaseCoord'
# end class mdStepType


class phasCoordType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, num=None, valueOf_=None):
        self.original_tagname_ = None
        self.num = _cast(None, num)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if phasCoordType.subclass:
            return phasCoordType.subclass(*args_, **kwargs_)
        else:
            return phasCoordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_num(self): return self.num
    def set_num(self, num): self.num = num
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='phasCoordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='phasCoordType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='phasCoordType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='phasCoordType'):
        if self.num is not None and 'num' not in already_processed:
            already_processed.add('num')
            outfile.write(' num=%s' % (self.gds_format_string(quote_attrib(self.num).encode(ExternalEncoding), input_name='num'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='phasCoordType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='phasCoordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.num is not None and 'num' not in already_processed:
            already_processed.add('num')
            showIndent(outfile, level)
            outfile.write('num="%s",\n' % (self.num,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('num', node)
        if value is not None and 'num' not in already_processed:
            already_processed.add('num')
            self.num = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class phasCoordType


class rateConsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, kineticReactionType=None, kineticArrheniusPreFactor=None, kineticArrheniusActivationEnergy=None, kineticModifiedArrheniusTemperaturePower=None):
        self.original_tagname_ = None
        self.kineticReactionType = _cast(None, kineticReactionType)
        self.kineticArrheniusPreFactor = kineticArrheniusPreFactor
        self.kineticArrheniusActivationEnergy = kineticArrheniusActivationEnergy
        self.kineticModifiedArrheniusTemperaturePower = kineticModifiedArrheniusTemperaturePower
    def factory(*args_, **kwargs_):
        if rateConsType.subclass:
            return rateConsType.subclass(*args_, **kwargs_)
        else:
            return rateConsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_kineticArrheniusPreFactor(self): return self.kineticArrheniusPreFactor
    def set_kineticArrheniusPreFactor(self, kineticArrheniusPreFactor): self.kineticArrheniusPreFactor = kineticArrheniusPreFactor
    def get_kineticArrheniusActivationEnergy(self): return self.kineticArrheniusActivationEnergy
    def set_kineticArrheniusActivationEnergy(self, kineticArrheniusActivationEnergy): self.kineticArrheniusActivationEnergy = kineticArrheniusActivationEnergy
    def get_kineticModifiedArrheniusTemperaturePower(self): return self.kineticModifiedArrheniusTemperaturePower
    def set_kineticModifiedArrheniusTemperaturePower(self, kineticModifiedArrheniusTemperaturePower): self.kineticModifiedArrheniusTemperaturePower = kineticModifiedArrheniusTemperaturePower
    def get_kineticReactionType(self): return self.kineticReactionType
    def set_kineticReactionType(self, kineticReactionType): self.kineticReactionType = kineticReactionType
    def hasContent_(self):
        if (
            self.kineticArrheniusPreFactor is not None or
            self.kineticArrheniusActivationEnergy is not None or
            self.kineticModifiedArrheniusTemperaturePower is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='rateConsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='rateConsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='rateConsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='rateConsType'):
        if self.kineticReactionType is not None and 'kineticReactionType' not in already_processed:
            already_processed.add('kineticReactionType')
            outfile.write(' kineticReactionType=%s' % (self.gds_format_string(quote_attrib(self.kineticReactionType).encode(ExternalEncoding), input_name='kineticReactionType'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='rateConsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.kineticArrheniusPreFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skineticArrheniusPreFactor>%s</%skineticArrheniusPreFactor>%s' % (namespace_, self.gds_format_double(self.kineticArrheniusPreFactor, input_name='kineticArrheniusPreFactor'), namespace_, eol_))
        if self.kineticArrheniusActivationEnergy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skineticArrheniusActivationEnergy>%s</%skineticArrheniusActivationEnergy>%s' % (namespace_, self.gds_format_float(self.kineticArrheniusActivationEnergy, input_name='kineticArrheniusActivationEnergy'), namespace_, eol_))
        if self.kineticModifiedArrheniusTemperaturePower is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skineticModifiedArrheniusTemperaturePower>%s</%skineticModifiedArrheniusTemperaturePower>%s' % (namespace_, self.gds_format_float(self.kineticModifiedArrheniusTemperaturePower, input_name='kineticModifiedArrheniusTemperaturePower'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='rateConsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.kineticReactionType is not None and 'kineticReactionType' not in already_processed:
            already_processed.add('kineticReactionType')
            showIndent(outfile, level)
            outfile.write('kineticReactionType="%s",\n' % (self.kineticReactionType,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.kineticArrheniusPreFactor is not None:
            showIndent(outfile, level)
            outfile.write('kineticArrheniusPreFactor=%e,\n' % self.kineticArrheniusPreFactor)
        if self.kineticArrheniusActivationEnergy is not None:
            showIndent(outfile, level)
            outfile.write('kineticArrheniusActivationEnergy=%f,\n' % self.kineticArrheniusActivationEnergy)
        if self.kineticModifiedArrheniusTemperaturePower is not None:
            showIndent(outfile, level)
            outfile.write('kineticModifiedArrheniusTemperaturePower=%f,\n' % self.kineticModifiedArrheniusTemperaturePower)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('kineticReactionType', node)
        if value is not None and 'kineticReactionType' not in already_processed:
            already_processed.add('kineticReactionType')
            self.kineticReactionType = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'kineticArrheniusPreFactor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'kineticArrheniusPreFactor')
            self.kineticArrheniusPreFactor = fval_
        elif nodeName_ == 'kineticArrheniusActivationEnergy':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'kineticArrheniusActivationEnergy')
            self.kineticArrheniusActivationEnergy = fval_
        elif nodeName_ == 'kineticModifiedArrheniusTemperaturePower':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'kineticModifiedArrheniusTemperaturePower')
            self.kineticModifiedArrheniusTemperaturePower = fval_
# end class rateConsType


class eqmConsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, molesProduct2=None, molesProduct1=None, molesReactant2=None, molesReactant1=None, molesProduct=None, equilibriumReactionType=None, molesReactant=None, equilibriumPreexponentialFactor=None, equilibriumFreeEnergy=None, equilibriumTemperaturePower=None):
        self.original_tagname_ = None
        self.molesProduct2 = _cast(int, molesProduct2)
        self.molesProduct1 = _cast(int, molesProduct1)
        self.molesReactant2 = _cast(int, molesReactant2)
        self.molesReactant1 = _cast(int, molesReactant1)
        self.molesProduct = _cast(int, molesProduct)
        self.equilibriumReactionType = _cast(None, equilibriumReactionType)
        self.molesReactant = _cast(int, molesReactant)
        self.equilibriumPreexponentialFactor = equilibriumPreexponentialFactor
        self.equilibriumFreeEnergy = equilibriumFreeEnergy
        self.equilibriumTemperaturePower = equilibriumTemperaturePower
    def factory(*args_, **kwargs_):
        if eqmConsType.subclass:
            return eqmConsType.subclass(*args_, **kwargs_)
        else:
            return eqmConsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_equilibriumPreexponentialFactor(self): return self.equilibriumPreexponentialFactor
    def set_equilibriumPreexponentialFactor(self, equilibriumPreexponentialFactor): self.equilibriumPreexponentialFactor = equilibriumPreexponentialFactor
    def get_equilibriumFreeEnergy(self): return self.equilibriumFreeEnergy
    def set_equilibriumFreeEnergy(self, equilibriumFreeEnergy): self.equilibriumFreeEnergy = equilibriumFreeEnergy
    def get_equilibriumTemperaturePower(self): return self.equilibriumTemperaturePower
    def set_equilibriumTemperaturePower(self, equilibriumTemperaturePower): self.equilibriumTemperaturePower = equilibriumTemperaturePower
    def get_molesProduct2(self): return self.molesProduct2
    def set_molesProduct2(self, molesProduct2): self.molesProduct2 = molesProduct2
    def get_molesProduct1(self): return self.molesProduct1
    def set_molesProduct1(self, molesProduct1): self.molesProduct1 = molesProduct1
    def get_molesReactant2(self): return self.molesReactant2
    def set_molesReactant2(self, molesReactant2): self.molesReactant2 = molesReactant2
    def get_molesReactant1(self): return self.molesReactant1
    def set_molesReactant1(self, molesReactant1): self.molesReactant1 = molesReactant1
    def get_molesProduct(self): return self.molesProduct
    def set_molesProduct(self, molesProduct): self.molesProduct = molesProduct
    def get_equilibriumReactionType(self): return self.equilibriumReactionType
    def set_equilibriumReactionType(self, equilibriumReactionType): self.equilibriumReactionType = equilibriumReactionType
    def get_molesReactant(self): return self.molesReactant
    def set_molesReactant(self, molesReactant): self.molesReactant = molesReactant
    def hasContent_(self):
        if (
            self.equilibriumPreexponentialFactor is not None or
            self.equilibriumFreeEnergy is not None or
            self.equilibriumTemperaturePower is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='eqmConsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='eqmConsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='eqmConsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='eqmConsType'):
        if self.molesProduct2 is not None and 'molesProduct2' not in already_processed:
            already_processed.add('molesProduct2')
            outfile.write(' molesProduct2="%s"' % self.gds_format_integer(self.molesProduct2, input_name='molesProduct2'))
        if self.molesProduct1 is not None and 'molesProduct1' not in already_processed:
            already_processed.add('molesProduct1')
            outfile.write(' molesProduct1="%s"' % self.gds_format_integer(self.molesProduct1, input_name='molesProduct1'))
        if self.molesReactant2 is not None and 'molesReactant2' not in already_processed:
            already_processed.add('molesReactant2')
            outfile.write(' molesReactant2="%s"' % self.gds_format_integer(self.molesReactant2, input_name='molesReactant2'))
        if self.molesReactant1 is not None and 'molesReactant1' not in already_processed:
            already_processed.add('molesReactant1')
            outfile.write(' molesReactant1="%s"' % self.gds_format_integer(self.molesReactant1, input_name='molesReactant1'))
        if self.molesProduct is not None and 'molesProduct' not in already_processed:
            already_processed.add('molesProduct')
            outfile.write(' molesProduct="%s"' % self.gds_format_integer(self.molesProduct, input_name='molesProduct'))
        if self.equilibriumReactionType is not None and 'equilibriumReactionType' not in already_processed:
            already_processed.add('equilibriumReactionType')
            outfile.write(' equilibriumReactionType=%s' % (self.gds_format_string(quote_attrib(self.equilibriumReactionType).encode(ExternalEncoding), input_name='equilibriumReactionType'), ))
        if self.molesReactant is not None and 'molesReactant' not in already_processed:
            already_processed.add('molesReactant')
            outfile.write(' molesReactant="%s"' % self.gds_format_integer(self.molesReactant, input_name='molesReactant'))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='eqmConsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.equilibriumPreexponentialFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sequilibriumPreexponentialFactor>%s</%sequilibriumPreexponentialFactor>%s' % (namespace_, self.gds_format_float(self.equilibriumPreexponentialFactor, input_name='equilibriumPreexponentialFactor'), namespace_, eol_))
        if self.equilibriumFreeEnergy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sequilibriumFreeEnergy>%s</%sequilibriumFreeEnergy>%s' % (namespace_, self.gds_format_float(self.equilibriumFreeEnergy, input_name='equilibriumFreeEnergy'), namespace_, eol_))
        if self.equilibriumTemperaturePower is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sequilibriumTemperaturePower>%s</%sequilibriumTemperaturePower>%s' % (namespace_, self.gds_format_float(self.equilibriumTemperaturePower, input_name='equilibriumTemperaturePower'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='eqmConsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.molesProduct2 is not None and 'molesProduct2' not in already_processed:
            already_processed.add('molesProduct2')
            showIndent(outfile, level)
            outfile.write('molesProduct2=%d,\n' % (self.molesProduct2,))
        if self.molesProduct1 is not None and 'molesProduct1' not in already_processed:
            already_processed.add('molesProduct1')
            showIndent(outfile, level)
            outfile.write('molesProduct1=%d,\n' % (self.molesProduct1,))
        if self.molesReactant2 is not None and 'molesReactant2' not in already_processed:
            already_processed.add('molesReactant2')
            showIndent(outfile, level)
            outfile.write('molesReactant2=%d,\n' % (self.molesReactant2,))
        if self.molesReactant1 is not None and 'molesReactant1' not in already_processed:
            already_processed.add('molesReactant1')
            showIndent(outfile, level)
            outfile.write('molesReactant1=%d,\n' % (self.molesReactant1,))
        if self.molesProduct is not None and 'molesProduct' not in already_processed:
            already_processed.add('molesProduct')
            showIndent(outfile, level)
            outfile.write('molesProduct=%d,\n' % (self.molesProduct,))
        if self.equilibriumReactionType is not None and 'equilibriumReactionType' not in already_processed:
            already_processed.add('equilibriumReactionType')
            showIndent(outfile, level)
            outfile.write('equilibriumReactionType="%s",\n' % (self.equilibriumReactionType,))
        if self.molesReactant is not None and 'molesReactant' not in already_processed:
            already_processed.add('molesReactant')
            showIndent(outfile, level)
            outfile.write('molesReactant=%d,\n' % (self.molesReactant,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.equilibriumPreexponentialFactor is not None:
            showIndent(outfile, level)
            outfile.write('equilibriumPreexponentialFactor=%f,\n' % self.equilibriumPreexponentialFactor)
        if self.equilibriumFreeEnergy is not None:
            showIndent(outfile, level)
            outfile.write('equilibriumFreeEnergy=%f,\n' % self.equilibriumFreeEnergy)
        if self.equilibriumTemperaturePower is not None:
            showIndent(outfile, level)
            outfile.write('equilibriumTemperaturePower=%f,\n' % self.equilibriumTemperaturePower)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('molesProduct2', node)
        if value is not None and 'molesProduct2' not in already_processed:
            already_processed.add('molesProduct2')
            try:
                self.molesProduct2 = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.molesProduct2 <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('molesProduct1', node)
        if value is not None and 'molesProduct1' not in already_processed:
            already_processed.add('molesProduct1')
            try:
                self.molesProduct1 = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.molesProduct1 <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('molesReactant2', node)
        if value is not None and 'molesReactant2' not in already_processed:
            already_processed.add('molesReactant2')
            try:
                self.molesReactant2 = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.molesReactant2 <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('molesReactant1', node)
        if value is not None and 'molesReactant1' not in already_processed:
            already_processed.add('molesReactant1')
            try:
                self.molesReactant1 = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.molesReactant1 <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('molesProduct', node)
        if value is not None and 'molesProduct' not in already_processed:
            already_processed.add('molesProduct')
            try:
                self.molesProduct = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.molesProduct <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('equilibriumReactionType', node)
        if value is not None and 'equilibriumReactionType' not in already_processed:
            already_processed.add('equilibriumReactionType')
            self.equilibriumReactionType = value
        value = find_attr_value_('molesReactant', node)
        if value is not None and 'molesReactant' not in already_processed:
            already_processed.add('molesReactant')
            try:
                self.molesReactant = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.molesReactant <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'equilibriumPreexponentialFactor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'equilibriumPreexponentialFactor')
            self.equilibriumPreexponentialFactor = fval_
        elif nodeName_ == 'equilibriumFreeEnergy':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'equilibriumFreeEnergy')
            self.equilibriumFreeEnergy = fval_
        elif nodeName_ == 'equilibriumTemperaturePower':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'equilibriumTemperaturePower')
            self.equilibriumTemperaturePower = fval_
# end class eqmConsType


class title(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if title.subclass:
            return title.subclass(*args_, **kwargs_)
        else:
            return title(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='title', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='title')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='title', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='title'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='title', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='title'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class title


class creator(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if creator.subclass:
            return creator.subclass(*args_, **kwargs_)
        else:
            return creator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='creator', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='creator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='creator', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='creator'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='creator', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='creator'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class creator


class subject(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if subject.subclass:
            return subject.subclass(*args_, **kwargs_)
        else:
            return subject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='subject', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='subject')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='subject', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='subject'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='subject', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='subject'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class subject


class description(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if description.subclass:
            return description.subclass(*args_, **kwargs_)
        else:
            return description(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='description', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='description')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='description', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='description'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='description', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='description'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class description


class publisher(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if publisher.subclass:
            return publisher.subclass(*args_, **kwargs_)
        else:
            return publisher(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='publisher', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='publisher')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='publisher', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='publisher'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='publisher', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='publisher'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class publisher


class contributor(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if contributor.subclass:
            return contributor.subclass(*args_, **kwargs_)
        else:
            return contributor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='contributor', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='contributor')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='contributor', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='contributor'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='contributor', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='contributor'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class contributor


class date(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if date.subclass:
            return date.subclass(*args_, **kwargs_)
        else:
            return date(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='date', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='date')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='date', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='date'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='date', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='date'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class date


class type_(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if type_.subclass:
            return type_.subclass(*args_, **kwargs_)
        else:
            return type_(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='type'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='type', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class type_


class format(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if format.subclass:
            return format.subclass(*args_, **kwargs_)
        else:
            return format(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='format', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='format')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='format', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='format'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='format', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='format'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class format


class identifier(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if identifier.subclass:
            return identifier.subclass(*args_, **kwargs_)
        else:
            return identifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='identifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='identifier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='identifier', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='identifier'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='identifier', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='identifier'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class identifier


class source(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if source.subclass:
            return source.subclass(*args_, **kwargs_)
        else:
            return source(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='source', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='source')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='source', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='source'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='source', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='source'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class source


class language(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if language.subclass:
            return language.subclass(*args_, **kwargs_)
        else:
            return language(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='language', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='language')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='language', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='language'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='language', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='language'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class language


class relation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if relation.subclass:
            return relation.subclass(*args_, **kwargs_)
        else:
            return relation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='relation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='relation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='relation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='relation'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='relation', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='relation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class relation


class coverage(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if coverage.subclass:
            return coverage.subclass(*args_, **kwargs_)
        else:
            return coverage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='coverage', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='coverage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='coverage', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='coverage'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='coverage', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='coverage'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class coverage


class rights(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if rights.subclass:
            return rights.subclass(*args_, **kwargs_)
        else:
            return rights(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='rights', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='rights')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='rights', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='rights'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='rights', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='rights'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class rights


class alternative(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if alternative.subclass:
            return alternative.subclass(*args_, **kwargs_)
        else:
            return alternative(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='alternative', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='alternative')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='alternative', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='alternative'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='alternative', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='alternative'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class alternative


class tableOfContents(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if tableOfContents.subclass:
            return tableOfContents.subclass(*args_, **kwargs_)
        else:
            return tableOfContents(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='tableOfContents', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tableOfContents')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='tableOfContents', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='tableOfContents'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='tableOfContents', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='tableOfContents'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tableOfContents


class abstract(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if abstract.subclass:
            return abstract.subclass(*args_, **kwargs_)
        else:
            return abstract(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='abstract', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='abstract')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='abstract', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='abstract'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='abstract', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='abstract'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class abstract


class created(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if created.subclass:
            return created.subclass(*args_, **kwargs_)
        else:
            return created(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='created', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='created')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='created', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='created'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='created', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='created'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class created


class valid(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if valid.subclass:
            return valid.subclass(*args_, **kwargs_)
        else:
            return valid(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='valid', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='valid')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='valid', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='valid'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='valid', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='valid'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class valid


class available(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if available.subclass:
            return available.subclass(*args_, **kwargs_)
        else:
            return available(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='available', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='available')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='available', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='available'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='available', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='available'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class available


class issued(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if issued.subclass:
            return issued.subclass(*args_, **kwargs_)
        else:
            return issued(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='issued', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='issued')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='issued', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='issued'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='issued', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='issued'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class issued


class modified(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if modified.subclass:
            return modified.subclass(*args_, **kwargs_)
        else:
            return modified(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='modified', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='modified')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='modified', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='modified'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='modified', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='modified'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class modified


class dateAccepted(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if dateAccepted.subclass:
            return dateAccepted.subclass(*args_, **kwargs_)
        else:
            return dateAccepted(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='dateAccepted', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dateAccepted')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='dateAccepted', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='dateAccepted'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='dateAccepted', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='dateAccepted'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dateAccepted


class dateCopyrighted(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if dateCopyrighted.subclass:
            return dateCopyrighted.subclass(*args_, **kwargs_)
        else:
            return dateCopyrighted(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='dateCopyrighted', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dateCopyrighted')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='dateCopyrighted', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='dateCopyrighted'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='dateCopyrighted', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='dateCopyrighted'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dateCopyrighted


class dateSubmitted(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if dateSubmitted.subclass:
            return dateSubmitted.subclass(*args_, **kwargs_)
        else:
            return dateSubmitted(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='dateSubmitted', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dateSubmitted')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='dateSubmitted', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='dateSubmitted'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='dateSubmitted', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='dateSubmitted'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dateSubmitted


class extent(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if extent.subclass:
            return extent.subclass(*args_, **kwargs_)
        else:
            return extent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='extent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='extent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='extent', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='extent'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='extent', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='extent'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class extent


class medium(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if medium.subclass:
            return medium.subclass(*args_, **kwargs_)
        else:
            return medium(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='medium', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='medium')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='medium', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='medium'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='medium', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='medium'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class medium


class isVersionOf(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if isVersionOf.subclass:
            return isVersionOf.subclass(*args_, **kwargs_)
        else:
            return isVersionOf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='isVersionOf', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='isVersionOf')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='isVersionOf', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='isVersionOf'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='isVersionOf', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='isVersionOf'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class isVersionOf


class hasVersion(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if hasVersion.subclass:
            return hasVersion.subclass(*args_, **kwargs_)
        else:
            return hasVersion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='hasVersion', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='hasVersion')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='hasVersion', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='hasVersion'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='hasVersion', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='hasVersion'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class hasVersion


class isReplacedBy(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if isReplacedBy.subclass:
            return isReplacedBy.subclass(*args_, **kwargs_)
        else:
            return isReplacedBy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='isReplacedBy', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='isReplacedBy')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='isReplacedBy', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='isReplacedBy'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='isReplacedBy', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='isReplacedBy'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class isReplacedBy


class replaces(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if replaces.subclass:
            return replaces.subclass(*args_, **kwargs_)
        else:
            return replaces(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='replaces', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='replaces')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='replaces', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='replaces'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='replaces', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='replaces'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class replaces


class isRequiredBy(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if isRequiredBy.subclass:
            return isRequiredBy.subclass(*args_, **kwargs_)
        else:
            return isRequiredBy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='isRequiredBy', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='isRequiredBy')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='isRequiredBy', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='isRequiredBy'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='isRequiredBy', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='isRequiredBy'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class isRequiredBy


class requires(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if requires.subclass:
            return requires.subclass(*args_, **kwargs_)
        else:
            return requires(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='requires', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='requires')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='requires', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='requires'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='requires', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='requires'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class requires


class isPartOf(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if isPartOf.subclass:
            return isPartOf.subclass(*args_, **kwargs_)
        else:
            return isPartOf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='isPartOf', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='isPartOf')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='isPartOf', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='isPartOf'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='isPartOf', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='isPartOf'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class isPartOf


class hasPart(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if hasPart.subclass:
            return hasPart.subclass(*args_, **kwargs_)
        else:
            return hasPart(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='hasPart', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='hasPart')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='hasPart', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='hasPart'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='hasPart', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='hasPart'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class hasPart


class isReferencedBy(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if isReferencedBy.subclass:
            return isReferencedBy.subclass(*args_, **kwargs_)
        else:
            return isReferencedBy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='isReferencedBy', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='isReferencedBy')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='isReferencedBy', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='isReferencedBy'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='isReferencedBy', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='isReferencedBy'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class isReferencedBy


class references(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if references.subclass:
            return references.subclass(*args_, **kwargs_)
        else:
            return references(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='references', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='references')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='references', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='references'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='references', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='references'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class references


class isFormatOf(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if isFormatOf.subclass:
            return isFormatOf.subclass(*args_, **kwargs_)
        else:
            return isFormatOf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='isFormatOf', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='isFormatOf')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='isFormatOf', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='isFormatOf'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='isFormatOf', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='isFormatOf'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class isFormatOf


class hasFormat(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if hasFormat.subclass:
            return hasFormat.subclass(*args_, **kwargs_)
        else:
            return hasFormat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='hasFormat', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='hasFormat')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='hasFormat', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='hasFormat'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='hasFormat', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='hasFormat'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class hasFormat


class conformsTo(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if conformsTo.subclass:
            return conformsTo.subclass(*args_, **kwargs_)
        else:
            return conformsTo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='conformsTo', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='conformsTo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='conformsTo', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='conformsTo'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='conformsTo', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='conformsTo'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class conformsTo


class spatial(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if spatial.subclass:
            return spatial.subclass(*args_, **kwargs_)
        else:
            return spatial(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='spatial', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='spatial')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='spatial', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='spatial'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='spatial', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='spatial'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class spatial


class temporal(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if temporal.subclass:
            return temporal.subclass(*args_, **kwargs_)
        else:
            return temporal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='temporal', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='temporal')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='temporal', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='temporal'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='temporal', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='temporal'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class temporal


class audience(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if audience.subclass:
            return audience.subclass(*args_, **kwargs_)
        else:
            return audience(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='audience', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='audience')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='audience', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='audience'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='audience', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='audience'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class audience


class accrualMethod(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if accrualMethod.subclass:
            return accrualMethod.subclass(*args_, **kwargs_)
        else:
            return accrualMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='accrualMethod', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accrualMethod')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='accrualMethod', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='accrualMethod'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='accrualMethod', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='accrualMethod'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class accrualMethod


class accrualPeriodicity(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if accrualPeriodicity.subclass:
            return accrualPeriodicity.subclass(*args_, **kwargs_)
        else:
            return accrualPeriodicity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='accrualPeriodicity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accrualPeriodicity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='accrualPeriodicity', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='accrualPeriodicity'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='accrualPeriodicity', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='accrualPeriodicity'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class accrualPeriodicity


class accrualPolicy(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if accrualPolicy.subclass:
            return accrualPolicy.subclass(*args_, **kwargs_)
        else:
            return accrualPolicy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='accrualPolicy', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accrualPolicy')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='accrualPolicy', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='accrualPolicy'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='accrualPolicy', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='accrualPolicy'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class accrualPolicy


class instructionalMethod(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if instructionalMethod.subclass:
            return instructionalMethod.subclass(*args_, **kwargs_)
        else:
            return instructionalMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='instructionalMethod', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='instructionalMethod')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='instructionalMethod', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='instructionalMethod'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='instructionalMethod', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='instructionalMethod'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class instructionalMethod


class provenance(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if provenance.subclass:
            return provenance.subclass(*args_, **kwargs_)
        else:
            return provenance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='provenance', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='provenance')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='provenance', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='provenance'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='provenance', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='provenance'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class provenance


class rightsHolder(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if rightsHolder.subclass:
            return rightsHolder.subclass(*args_, **kwargs_)
        else:
            return rightsHolder(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='rightsHolder', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='rightsHolder')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='rightsHolder', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='rightsHolder'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='rightsHolder', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='rightsHolder'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class rightsHolder


class mediator(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if mediator.subclass:
            return mediator.subclass(*args_, **kwargs_)
        else:
            return mediator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='mediator', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mediator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='mediator', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='mediator'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='mediator', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='mediator'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class mediator


class educationLevel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if educationLevel.subclass:
            return educationLevel.subclass(*args_, **kwargs_)
        else:
            return educationLevel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='educationLevel', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='educationLevel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='educationLevel', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='educationLevel'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='educationLevel', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='educationLevel'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class educationLevel


class accessRights(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if accessRights.subclass:
            return accessRights.subclass(*args_, **kwargs_)
        else:
            return accessRights(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='accessRights', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accessRights')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='accessRights', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='accessRights'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='accessRights', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='accessRights'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class accessRights


class license(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if license.subclass:
            return license.subclass(*args_, **kwargs_)
        else:
            return license(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='license', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='license')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='license', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='license'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='license', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='license'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class license


class bibliographicCitation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if bibliographicCitation.subclass:
            return bibliographicCitation.subclass(*args_, **kwargs_)
        else:
            return bibliographicCitation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='bibliographicCitation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='bibliographicCitation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='bibliographicCitation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='bibliographicCitation'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='bibliographicCitation', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='bibliographicCitation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class bibliographicCitation


class elementOrRefinementContainer(GeneratedsSuper):
    """This is included as a convenience for schema authors who need to
    define a root or container element for all of the DC elements
    and element refinements."""
    subclass = None
    superclass = None
    def __init__(self, any=None):
        self.original_tagname_ = None
        if any is None:
            self.any = []
        else:
            self.any = any
    def factory(*args_, **kwargs_):
        if elementOrRefinementContainer.subclass:
            return elementOrRefinementContainer.subclass(*args_, **kwargs_)
        else:
            return elementOrRefinementContainer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_any(self): return self.any
    def set_any(self, any): self.any = any
    def add_any(self, value): self.any.append(value)
    def insert_any_at(self, index, value): self.any.insert(index, value)
    def replace_any_at(self, index, value): self.any[index] = value
    def hasContent_(self):
        if (
            self.any
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='elementOrRefinementContainer', namespacedef_='xmlns:cs="http://chemicalsemantics.com/dictionary/chemicalsemantics/" xmlns:dc="http://purl.org/dc/elements/1.1/" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='elementOrRefinementContainer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='elementOrRefinementContainer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='elementOrRefinementContainer'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='elementOrRefinementContainer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for any_ in self.any:
            any_.export(outfile, level, namespace_, name_='any', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='elementOrRefinementContainer'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('any=[\n')
        level += 1
        for any_ in self.any:
            showIndent(outfile, level)
            outfile.write('model_.any(\n')
            any_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'any':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <any> element')
            self.any.append(obj_)
            obj_.original_tagname_ = 'any'
        elif nodeName_ == 'audience':
            obj_ = audience.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'audience'
        elif nodeName_ == 'accrualMethod':
            obj_ = accrualMethod.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'accrualMethod'
        elif nodeName_ == 'accrualPeriodicity':
            obj_ = accrualPeriodicity.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'accrualPeriodicity'
        elif nodeName_ == 'accrualPolicy':
            obj_ = accrualPolicy.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'accrualPolicy'
        elif nodeName_ == 'instructionalMethod':
            obj_ = instructionalMethod.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'instructionalMethod'
        elif nodeName_ == 'provenance':
            obj_ = provenance.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'provenance'
        elif nodeName_ == 'rightsHolder':
            obj_ = rightsHolder.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'rightsHolder'
        elif nodeName_ == 'title':
            obj_ = title.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'creator':
            obj_ = creator.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'creator'
        elif nodeName_ == 'subject':
            obj_ = subject.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'publisher':
            obj_ = publisher.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'publisher'
        elif nodeName_ == 'contributor':
            obj_ = contributor.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'contributor'
        elif nodeName_ == 'date':
            obj_ = date.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'date'
        elif nodeName_ == 'type':
            obj_ = type_.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'format':
            obj_ = format.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'format'
        elif nodeName_ == 'identifier':
            obj_ = identifier.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'source':
            obj_ = source.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'source'
        elif nodeName_ == 'language':
            obj_ = language.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'language'
        elif nodeName_ == 'relation':
            obj_ = relation.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'relation'
        elif nodeName_ == 'coverage':
            obj_ = coverage.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'coverage'
        elif nodeName_ == 'rights':
            obj_ = rights.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'rights'
        elif nodeName_ == 'mediator':
            obj_ = mediator.factory()
            obj_.build(child_)
            self.audience.append(obj_)
            obj_.original_tagname_ = 'mediator'
        elif nodeName_ == 'educationLevel':
            obj_ = educationLevel.factory()
            obj_.build(child_)
            self.audience.append(obj_)
            obj_.original_tagname_ = 'educationLevel'
        elif nodeName_ == 'title':
            obj_ = title.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'alternative':
            obj_ = alternative.factory()
            obj_.build(child_)
            self.title.append(obj_)
            obj_.original_tagname_ = 'alternative'
        elif nodeName_ == 'creator':
            obj_ = creator.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'creator'
        elif nodeName_ == 'subject':
            obj_ = subject.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'tableOfContents':
            obj_ = tableOfContents.factory()
            obj_.build(child_)
            self.description.append(obj_)
            obj_.original_tagname_ = 'tableOfContents'
        elif nodeName_ == 'abstract':
            obj_ = abstract.factory()
            obj_.build(child_)
            self.description.append(obj_)
            obj_.original_tagname_ = 'abstract'
        elif nodeName_ == 'publisher':
            obj_ = publisher.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'publisher'
        elif nodeName_ == 'contributor':
            obj_ = contributor.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'contributor'
        elif nodeName_ == 'date':
            obj_ = date.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'date'
        elif nodeName_ == 'created':
            obj_ = created.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'created'
        elif nodeName_ == 'valid':
            obj_ = valid.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'valid'
        elif nodeName_ == 'available':
            obj_ = available.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'available'
        elif nodeName_ == 'issued':
            obj_ = issued.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'issued'
        elif nodeName_ == 'modified':
            obj_ = modified.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'modified'
        elif nodeName_ == 'dateAccepted':
            obj_ = dateAccepted.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'dateAccepted'
        elif nodeName_ == 'dateCopyrighted':
            obj_ = dateCopyrighted.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'dateCopyrighted'
        elif nodeName_ == 'dateSubmitted':
            obj_ = dateSubmitted.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'dateSubmitted'
        elif nodeName_ == 'type':
            obj_ = type_.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'format':
            obj_ = format.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'format'
        elif nodeName_ == 'extent':
            obj_ = extent.factory()
            obj_.build(child_)
            self.format.append(obj_)
            obj_.original_tagname_ = 'extent'
        elif nodeName_ == 'medium':
            obj_ = medium.factory()
            obj_.build(child_)
            self.format.append(obj_)
            obj_.original_tagname_ = 'medium'
        elif nodeName_ == 'identifier':
            obj_ = identifier.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'bibliographicCitation':
            obj_ = bibliographicCitation.factory()
            obj_.build(child_)
            self.identifier.append(obj_)
            obj_.original_tagname_ = 'bibliographicCitation'
        elif nodeName_ == 'source':
            obj_ = source.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'source'
        elif nodeName_ == 'language':
            obj_ = language.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'language'
        elif nodeName_ == 'relation':
            obj_ = relation.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'relation'
        elif nodeName_ == 'isVersionOf':
            obj_ = isVersionOf.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'isVersionOf'
        elif nodeName_ == 'hasVersion':
            obj_ = hasVersion.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'hasVersion'
        elif nodeName_ == 'isReplacedBy':
            obj_ = isReplacedBy.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'isReplacedBy'
        elif nodeName_ == 'replaces':
            obj_ = replaces.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'replaces'
        elif nodeName_ == 'isRequiredBy':
            obj_ = isRequiredBy.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'isRequiredBy'
        elif nodeName_ == 'requires':
            obj_ = requires.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'requires'
        elif nodeName_ == 'isPartOf':
            obj_ = isPartOf.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'isPartOf'
        elif nodeName_ == 'hasPart':
            obj_ = hasPart.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'hasPart'
        elif nodeName_ == 'isReferencedBy':
            obj_ = isReferencedBy.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'isReferencedBy'
        elif nodeName_ == 'references':
            obj_ = references.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'references'
        elif nodeName_ == 'isFormatOf':
            obj_ = isFormatOf.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'isFormatOf'
        elif nodeName_ == 'hasFormat':
            obj_ = hasFormat.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'hasFormat'
        elif nodeName_ == 'conformsTo':
            obj_ = conformsTo.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'conformsTo'
        elif nodeName_ == 'coverage':
            obj_ = coverage.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'coverage'
        elif nodeName_ == 'spatial':
            obj_ = spatial.factory()
            obj_.build(child_)
            self.coverage.append(obj_)
            obj_.original_tagname_ = 'spatial'
        elif nodeName_ == 'temporal':
            obj_ = temporal.factory()
            obj_.build(child_)
            self.coverage.append(obj_)
            obj_.original_tagname_ = 'temporal'
        elif nodeName_ == 'rights':
            obj_ = rights.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'rights'
        elif nodeName_ == 'accessRights':
            obj_ = accessRights.factory()
            obj_.build(child_)
            self.rights.append(obj_)
            obj_.original_tagname_ = 'accessRights'
        elif nodeName_ == 'license':
            obj_ = license.factory()
            obj_.build(child_)
            self.rights.append(obj_)
            obj_.original_tagname_ = 'license'
# end class elementOrRefinementContainer


class SimpleLiteral(GeneratedsSuper):
    """This is the default type for all of the DC elements. It permits text
    content only with optional xml:lang attribute. Text is allowed
    because mixed="true", but sub-elements are disallowed because
    minOccurs="0" and maxOccurs="0" are on the xs:any tag. This
    complexType allows for restriction or extension permitting child
    elements."""
    subclass = None
    superclass = None
    def __init__(self, lang=None, anytypeobjs_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.lang = _cast(None, lang)
        self.anytypeobjs_ = anytypeobjs_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if SimpleLiteral.subclass:
            return SimpleLiteral.subclass(*args_, **kwargs_)
        else:
            return SimpleLiteral(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='SimpleLiteral', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SimpleLiteral')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='SimpleLiteral', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='SimpleLiteral'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='cs:', name_='SimpleLiteral', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SimpleLiteral'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'SimpleLiteral')
        if obj_ is not None:
            self.set_anytypeobjs_(obj_)
# end class SimpleLiteral


class elementContainer(GeneratedsSuper):
    """This complexType is included as a convenience for schema authors who
    need to define a root or container element for all of the DC
    elements."""
    subclass = None
    superclass = None
    def __init__(self, any=None):
        self.original_tagname_ = None
        if any is None:
            self.any = []
        else:
            self.any = any
    def factory(*args_, **kwargs_):
        if elementContainer.subclass:
            return elementContainer.subclass(*args_, **kwargs_)
        else:
            return elementContainer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_any(self): return self.any
    def set_any(self, any): self.any = any
    def add_any(self, value): self.any.append(value)
    def insert_any_at(self, index, value): self.any.insert(index, value)
    def replace_any_at(self, index, value): self.any[index] = value
    def hasContent_(self):
        if (
            self.any
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='elementContainer', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='elementContainer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='elementContainer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='elementContainer'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='elementContainer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for any_ in self.any:
            any_.export(outfile, level, namespace_, name_='any', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='elementContainer'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('any=[\n')
        level += 1
        for any_ in self.any:
            showIndent(outfile, level)
            outfile.write('model_.any(\n')
            any_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'any':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <any> element')
            self.any.append(obj_)
            obj_.original_tagname_ = 'any'
        elif nodeName_ == 'audience':
            obj_ = audience.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'audience'
        elif nodeName_ == 'accrualMethod':
            obj_ = accrualMethod.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'accrualMethod'
        elif nodeName_ == 'accrualPeriodicity':
            obj_ = accrualPeriodicity.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'accrualPeriodicity'
        elif nodeName_ == 'accrualPolicy':
            obj_ = accrualPolicy.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'accrualPolicy'
        elif nodeName_ == 'instructionalMethod':
            obj_ = instructionalMethod.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'instructionalMethod'
        elif nodeName_ == 'provenance':
            obj_ = provenance.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'provenance'
        elif nodeName_ == 'rightsHolder':
            obj_ = rightsHolder.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'rightsHolder'
        elif nodeName_ == 'title':
            obj_ = title.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'creator':
            obj_ = creator.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'creator'
        elif nodeName_ == 'subject':
            obj_ = subject.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'publisher':
            obj_ = publisher.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'publisher'
        elif nodeName_ == 'contributor':
            obj_ = contributor.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'contributor'
        elif nodeName_ == 'date':
            obj_ = date.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'date'
        elif nodeName_ == 'type':
            obj_ = type_.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'format':
            obj_ = format.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'format'
        elif nodeName_ == 'identifier':
            obj_ = identifier.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'source':
            obj_ = source.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'source'
        elif nodeName_ == 'language':
            obj_ = language.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'language'
        elif nodeName_ == 'relation':
            obj_ = relation.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'relation'
        elif nodeName_ == 'coverage':
            obj_ = coverage.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'coverage'
        elif nodeName_ == 'rights':
            obj_ = rights.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'rights'
        elif nodeName_ == 'mediator':
            obj_ = mediator.factory()
            obj_.build(child_)
            self.audience.append(obj_)
            obj_.original_tagname_ = 'mediator'
        elif nodeName_ == 'educationLevel':
            obj_ = educationLevel.factory()
            obj_.build(child_)
            self.audience.append(obj_)
            obj_.original_tagname_ = 'educationLevel'
        elif nodeName_ == 'title':
            obj_ = title.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'alternative':
            obj_ = alternative.factory()
            obj_.build(child_)
            self.title.append(obj_)
            obj_.original_tagname_ = 'alternative'
        elif nodeName_ == 'creator':
            obj_ = creator.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'creator'
        elif nodeName_ == 'subject':
            obj_ = subject.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'tableOfContents':
            obj_ = tableOfContents.factory()
            obj_.build(child_)
            self.description.append(obj_)
            obj_.original_tagname_ = 'tableOfContents'
        elif nodeName_ == 'abstract':
            obj_ = abstract.factory()
            obj_.build(child_)
            self.description.append(obj_)
            obj_.original_tagname_ = 'abstract'
        elif nodeName_ == 'publisher':
            obj_ = publisher.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'publisher'
        elif nodeName_ == 'contributor':
            obj_ = contributor.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'contributor'
        elif nodeName_ == 'date':
            obj_ = date.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'date'
        elif nodeName_ == 'created':
            obj_ = created.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'created'
        elif nodeName_ == 'valid':
            obj_ = valid.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'valid'
        elif nodeName_ == 'available':
            obj_ = available.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'available'
        elif nodeName_ == 'issued':
            obj_ = issued.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'issued'
        elif nodeName_ == 'modified':
            obj_ = modified.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'modified'
        elif nodeName_ == 'dateAccepted':
            obj_ = dateAccepted.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'dateAccepted'
        elif nodeName_ == 'dateCopyrighted':
            obj_ = dateCopyrighted.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'dateCopyrighted'
        elif nodeName_ == 'dateSubmitted':
            obj_ = dateSubmitted.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'dateSubmitted'
        elif nodeName_ == 'type':
            obj_ = type_.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'format':
            obj_ = format.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'format'
        elif nodeName_ == 'extent':
            obj_ = extent.factory()
            obj_.build(child_)
            self.format.append(obj_)
            obj_.original_tagname_ = 'extent'
        elif nodeName_ == 'medium':
            obj_ = medium.factory()
            obj_.build(child_)
            self.format.append(obj_)
            obj_.original_tagname_ = 'medium'
        elif nodeName_ == 'identifier':
            obj_ = identifier.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'bibliographicCitation':
            obj_ = bibliographicCitation.factory()
            obj_.build(child_)
            self.identifier.append(obj_)
            obj_.original_tagname_ = 'bibliographicCitation'
        elif nodeName_ == 'source':
            obj_ = source.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'source'
        elif nodeName_ == 'language':
            obj_ = language.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'language'
        elif nodeName_ == 'relation':
            obj_ = relation.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'relation'
        elif nodeName_ == 'isVersionOf':
            obj_ = isVersionOf.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'isVersionOf'
        elif nodeName_ == 'hasVersion':
            obj_ = hasVersion.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'hasVersion'
        elif nodeName_ == 'isReplacedBy':
            obj_ = isReplacedBy.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'isReplacedBy'
        elif nodeName_ == 'replaces':
            obj_ = replaces.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'replaces'
        elif nodeName_ == 'isRequiredBy':
            obj_ = isRequiredBy.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'isRequiredBy'
        elif nodeName_ == 'requires':
            obj_ = requires.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'requires'
        elif nodeName_ == 'isPartOf':
            obj_ = isPartOf.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'isPartOf'
        elif nodeName_ == 'hasPart':
            obj_ = hasPart.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'hasPart'
        elif nodeName_ == 'isReferencedBy':
            obj_ = isReferencedBy.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'isReferencedBy'
        elif nodeName_ == 'references':
            obj_ = references.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'references'
        elif nodeName_ == 'isFormatOf':
            obj_ = isFormatOf.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'isFormatOf'
        elif nodeName_ == 'hasFormat':
            obj_ = hasFormat.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'hasFormat'
        elif nodeName_ == 'conformsTo':
            obj_ = conformsTo.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'conformsTo'
        elif nodeName_ == 'coverage':
            obj_ = coverage.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'coverage'
        elif nodeName_ == 'spatial':
            obj_ = spatial.factory()
            obj_.build(child_)
            self.coverage.append(obj_)
            obj_.original_tagname_ = 'spatial'
        elif nodeName_ == 'temporal':
            obj_ = temporal.factory()
            obj_.build(child_)
            self.coverage.append(obj_)
            obj_.original_tagname_ = 'temporal'
        elif nodeName_ == 'rights':
            obj_ = rights.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'rights'
        elif nodeName_ == 'accessRights':
            obj_ = accessRights.factory()
            obj_.build(child_)
            self.rights.append(obj_)
            obj_.original_tagname_ = 'accessRights'
        elif nodeName_ == 'license':
            obj_ = license.factory()
            obj_.build(child_)
            self.rights.append(obj_)
            obj_.original_tagname_ = 'license'
# end class elementContainer


class TGN(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(TGN, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if TGN.subclass:
            return TGN.subclass(*args_, **kwargs_)
        else:
            return TGN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(TGN, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='TGN', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TGN')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='TGN', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='TGN'):
        super(TGN, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TGN')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='TGN', fromsubclass_=False, pretty_print=True):
        super(TGN, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TGN'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(TGN, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TGN, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(TGN, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TGN


class Box(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(Box, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Box.subclass:
            return Box.subclass(*args_, **kwargs_)
        else:
            return Box(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(Box, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='Box', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Box')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='Box', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='Box'):
        super(Box, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Box')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='Box', fromsubclass_=False, pretty_print=True):
        super(Box, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Box'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(Box, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Box, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(Box, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Box


class ISO3166(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(ISO3166, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ISO3166.subclass:
            return ISO3166.subclass(*args_, **kwargs_)
        else:
            return ISO3166(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(ISO3166, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='ISO3166', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ISO3166')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='ISO3166', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='ISO3166'):
        super(ISO3166, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ISO3166')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='ISO3166', fromsubclass_=False, pretty_print=True):
        super(ISO3166, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ISO3166'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(ISO3166, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ISO3166, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(ISO3166, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ISO3166


class Point(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(Point, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Point.subclass:
            return Point.subclass(*args_, **kwargs_)
        else:
            return Point(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(Point, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='Point', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Point')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='Point', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='Point'):
        super(Point, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Point')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='Point', fromsubclass_=False, pretty_print=True):
        super(Point, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Point'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(Point, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Point, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(Point, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Point


class RFC4646(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(RFC4646, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if RFC4646.subclass:
            return RFC4646.subclass(*args_, **kwargs_)
        else:
            return RFC4646(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(RFC4646, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='RFC4646', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RFC4646')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='RFC4646', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='RFC4646'):
        super(RFC4646, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RFC4646')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='RFC4646', fromsubclass_=False, pretty_print=True):
        super(RFC4646, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RFC4646'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(RFC4646, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RFC4646, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(RFC4646, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RFC4646


class RFC3066(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(RFC3066, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if RFC3066.subclass:
            return RFC3066.subclass(*args_, **kwargs_)
        else:
            return RFC3066(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(RFC3066, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='RFC3066', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RFC3066')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='RFC3066', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='RFC3066'):
        super(RFC3066, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RFC3066')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='RFC3066', fromsubclass_=False, pretty_print=True):
        super(RFC3066, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RFC3066'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(RFC3066, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RFC3066, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(RFC3066, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RFC3066


class RFC1766(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(RFC1766, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if RFC1766.subclass:
            return RFC1766.subclass(*args_, **kwargs_)
        else:
            return RFC1766(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(RFC1766, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='RFC1766', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RFC1766')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='RFC1766', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='RFC1766'):
        super(RFC1766, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RFC1766')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='RFC1766', fromsubclass_=False, pretty_print=True):
        super(RFC1766, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RFC1766'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(RFC1766, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RFC1766, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(RFC1766, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RFC1766


class ISO639_3(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(ISO639_3, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ISO639_3.subclass:
            return ISO639_3.subclass(*args_, **kwargs_)
        else:
            return ISO639_3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(ISO639_3, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='ISO639-3', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ISO639-3')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='ISO639-3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='ISO639-3'):
        super(ISO639_3, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ISO639-3')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='ISO639-3', fromsubclass_=False, pretty_print=True):
        super(ISO639_3, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ISO639-3'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(ISO639_3, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ISO639_3, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(ISO639_3, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ISO639_3


class ISO639_2(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(ISO639_2, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ISO639_2.subclass:
            return ISO639_2.subclass(*args_, **kwargs_)
        else:
            return ISO639_2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(ISO639_2, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='ISO639-2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ISO639-2')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='ISO639-2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='ISO639-2'):
        super(ISO639_2, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ISO639-2')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='ISO639-2', fromsubclass_=False, pretty_print=True):
        super(ISO639_2, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ISO639-2'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(ISO639_2, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ISO639_2, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(ISO639_2, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ISO639_2


class URI(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(URI, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if URI.subclass:
            return URI.subclass(*args_, **kwargs_)
        else:
            return URI(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(URI, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='URI', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='URI')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='URI', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='URI'):
        super(URI, self).exportAttributes(outfile, level, already_processed, namespace_, name_='URI')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='URI', fromsubclass_=False, pretty_print=True):
        super(URI, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='URI'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(URI, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(URI, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(URI, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class URI


class IMT(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(IMT, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if IMT.subclass:
            return IMT.subclass(*args_, **kwargs_)
        else:
            return IMT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(IMT, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='IMT', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IMT')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='IMT', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='IMT'):
        super(IMT, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IMT')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='IMT', fromsubclass_=False, pretty_print=True):
        super(IMT, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='IMT'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(IMT, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IMT, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(IMT, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IMT


class DCMIType(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(DCMIType, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DCMIType.subclass:
            return DCMIType.subclass(*args_, **kwargs_)
        else:
            return DCMIType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(DCMIType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='DCMIType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DCMIType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='DCMIType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='DCMIType'):
        super(DCMIType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DCMIType')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='DCMIType', fromsubclass_=False, pretty_print=True):
        super(DCMIType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DCMIType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(DCMIType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DCMIType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(DCMIType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DCMIType


class W3CDTF(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(W3CDTF, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if W3CDTF.subclass:
            return W3CDTF.subclass(*args_, **kwargs_)
        else:
            return W3CDTF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(W3CDTF, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='W3CDTF', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='W3CDTF')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='W3CDTF', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='W3CDTF'):
        super(W3CDTF, self).exportAttributes(outfile, level, already_processed, namespace_, name_='W3CDTF')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='W3CDTF', fromsubclass_=False, pretty_print=True):
        super(W3CDTF, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='W3CDTF'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(W3CDTF, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(W3CDTF, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(W3CDTF, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class W3CDTF


class Period(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(Period, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Period.subclass:
            return Period.subclass(*args_, **kwargs_)
        else:
            return Period(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(Period, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='Period', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Period')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='Period', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='Period'):
        super(Period, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Period')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='Period', fromsubclass_=False, pretty_print=True):
        super(Period, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Period'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(Period, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Period, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(Period, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Period


class UDC(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(UDC, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if UDC.subclass:
            return UDC.subclass(*args_, **kwargs_)
        else:
            return UDC(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(UDC, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='UDC', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UDC')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='UDC', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='UDC'):
        super(UDC, self).exportAttributes(outfile, level, already_processed, namespace_, name_='UDC')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='UDC', fromsubclass_=False, pretty_print=True):
        super(UDC, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='UDC'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(UDC, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(UDC, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(UDC, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class UDC


class LCC(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(LCC, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if LCC.subclass:
            return LCC.subclass(*args_, **kwargs_)
        else:
            return LCC(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(LCC, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='LCC', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LCC')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='LCC', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='LCC'):
        super(LCC, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LCC')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='LCC', fromsubclass_=False, pretty_print=True):
        super(LCC, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LCC'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(LCC, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LCC, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(LCC, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LCC


class DDC(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(DDC, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DDC.subclass:
            return DDC.subclass(*args_, **kwargs_)
        else:
            return DDC(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(DDC, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='DDC', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DDC')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='DDC', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='DDC'):
        super(DDC, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DDC')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='DDC', fromsubclass_=False, pretty_print=True):
        super(DDC, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DDC'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(DDC, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DDC, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(DDC, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DDC


class MESH(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(MESH, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if MESH.subclass:
            return MESH.subclass(*args_, **kwargs_)
        else:
            return MESH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(MESH, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='MESH', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MESH')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='MESH', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='MESH'):
        super(MESH, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MESH')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='MESH', fromsubclass_=False, pretty_print=True):
        super(MESH, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MESH'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(MESH, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MESH, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(MESH, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MESH


class LCSH(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(LCSH, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if LCSH.subclass:
            return LCSH.subclass(*args_, **kwargs_)
        else:
            return LCSH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(LCSH, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='LCSH', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LCSH')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='LCSH', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='LCSH'):
        super(LCSH, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LCSH')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='LCSH', fromsubclass_=False, pretty_print=True):
        super(LCSH, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LCSH'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(LCSH, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LCSH, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(LCSH, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LCSH


GDSClassesMapping = {
    'scfWaveFunction': scfWaveFuncType,
    'submittingAuthor': authorType,
    'normalModes': normalModesType,
    'betaOrbitals': orbitalsType,
    'scfMolecularDynamics': molDynamType,
    'mmMolecularDynamics': molDynamType,
    'scfElectronicSpectra': scfElecSpecType,
    'scfCalculation': scfCalcType,
    'residue': residueType,
    'molecularCalculations': mcType,
    'orbitalEnergies': orbEnerType,
    'normalMode': normalModeType,
    'correspondingAuthor': authorType,
    'alphaOrbitals': orbitalsType,
    'chemicalSemantics': csType,
    'mmEnergies': scfElecEnerType,
    'orbital': orbitalType,
    'alphaOrbitalEnergies': orbEnerType,
    'any': SimpleLiteral,
    'molecule': moleculeType,
    'mmCalculation': mmCalcType,
    'orbitals': orbitalsType,
    'equilibriumConstants': eqmConsType,
    'atom': atomType,
    'coordination': coordinationType,
    'scfVibrationalAnalysis': scfVibAnalType,
    'betaOrbitalEnergies': orbEnerType,
    'scfEnergies': scfElecEnerType,
    'molecularPublication': mpType,
    'molecularSystem': msType,
    'mdPhaseCoord': phasCoordType,
    'mdStep': mdStepType,
    'kineticRateConstants': rateConsType,
    'bond': bondType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'csType'
        rootClass = csType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:cs=http://www.chemicalsemantics.com/cs',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'csType'
        rootClass = csType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'csType'
        rootClass = csType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:cs=http://www.chemicalsemantics.com/cs')
    return rootObj


def parseLiteral(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'csType'
        rootClass = csType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from csx_api import *\n\n')
        sys.stdout.write('import csx_api as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "Box",
    "DCMIType",
    "DDC",
    "IMT",
    "ISO3166",
    "ISO639_2",
    "ISO639_3",
    "LCC",
    "LCSH",
    "MESH",
    "Period",
    "Point",
    "RFC1766",
    "RFC3066",
    "RFC4646",
    "SimpleLiteral",
    "TGN",
    "UDC",
    "URI",
    "W3CDTF",
    "abstract",
    "accessRights",
    "accrualMethod",
    "accrualPeriodicity",
    "accrualPolicy",
    "alternative",
    "atomType",
    "audience",
    "authorType",
    "available",
    "bibliographicCitation",
    "bondType",
    "conformsTo",
    "contributor",
    "coordinationType",
    "coverage",
    "created",
    "creator",
    "csType",
    "date",
    "dateAccepted",
    "dateCopyrighted",
    "dateSubmitted",
    "description",
    "educationLevel",
    "elementContainer",
    "elementOrRefinementContainer",
    "eqmConsType",
    "extent",
    "format",
    "hasFormat",
    "hasPart",
    "hasVersion",
    "identifier",
    "instructionalMethod",
    "isFormatOf",
    "isPartOf",
    "isReferencedBy",
    "isReplacedBy",
    "isRequiredBy",
    "isVersionOf",
    "issued",
    "language",
    "license",
    "mcType",
    "mdStepType",
    "mediator",
    "medium",
    "mmCalcType",
    "modified",
    "molDynamType",
    "moleculeType",
    "mpType",
    "msType",
    "name",
    "normalModeType",
    "normalModesType",
    "orbEnerType",
    "orbitalType",
    "orbitalsType",
    "organization",
    "phasCoordType",
    "provenance",
    "publisher",
    "rateConsType",
    "references",
    "relation",
    "replaces",
    "requires",
    "residueType",
    "rights",
    "rightsHolder",
    "scfCalcType",
    "scfElecEnerType",
    "scfElecSpecType",
    "scfVibAnalType",
    "scfWaveFuncType",
    "source",
    "spatial",
    "subject",
    "tableOfContents",
    "temporal",
    "title",
    "type_",
    "valid"
]
