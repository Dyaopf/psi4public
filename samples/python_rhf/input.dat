from math import *

print '\n'
banner("PSI4 Python RHF")
print '\n'

# Molecular Geometry
molecule mol {
O 0.0 0.0 0.0
H 0.0 0.0 1.0
H 0.0 1.0 0.0
symmetry c1
}

banner("Molecular Geometry",2)
print '\n'

mol.update_geometry()
mol.print_out()
Enuc = mol.nuclear_repulsion_energy()
print 'Nuclear Repulsion Energy %14.10f [H]\n\n' % (Enuc) 

# Basis set Info
globals {
basis sto-3g 
scf_type direct
}

banner("Integrals",2)
print '\n'
# Mints helper object
mints = PsiMod.MintsHelper()

# One-electron integrals
S = mints.ao_overlap()
T = mints.ao_kinetic()
V = mints.ao_potential()

S.print_out()
T.print_out()
V.print_out()

# Two-electron integrals
I = mints.ao_eri()
I.print_out()

banner('Pre-Iterations',2)   
print '\n'
print '\n'

nso = S.cols(0)
natom = mol.natom()
Z = 0
for k in range(0, natom):
    Z = Z + mol.Z(k)
Z = Z - mol.molecular_charge()
ndocc = Z / 2 # This had better work

print 'Natom = %d\n' %(natom)
print 'Nso   = %d\n' %(nso)
print 'Ndocc = %d\n' %(ndocc)

# Form X (S^-1/2)
W = PsiMod.Vector(4*nso);
s = PsiMod.Vector(nso);

# Eigendecomposition
info = PsiMod.DSYEV(0, 'V','U', nso, S, nso, s, W, 4*nso)

# Scale by square roots
for k in range(0,nso):
    s.set(0,k,1.0 / sqrt(s.get(0,k)))
L = PsiMod.Matrix(nso,nso)
for k in range(0,nso):
    for l in range(0,nso):
        L.set(0, k, l, S.get(0,k,l) * s.get(0,k))

# Multiply back out to get X
X = PsiMod.Matrix(nso,nso)
X.set_name('X: Change of basis matrix')
PsiMod.DGEMM(0,'T','N',nso,nso,nso,1.0,L,nso,S,nso,0.0,X,nso)
X.print_out()

# Form H
H = PsiMod.Matrix(nso,nso)
H.set_name("One-Electron Hamiltonian")
for k in range(0,nso):
    for l in range(0,nso):
        H.set(0,k,l,T.get(0,k,l) + V.get(0,k,l))
H.print_out()

eig = PsiMod.Vector(nso)
G = PsiMod.Matrix(nso,nso)
G.set_name("G Matrix")
F = PsiMod.Matrix(nso,nso)
F.set_name("Fock Matrix")
C = PsiMod.Matrix(nso,nso)
C.set_name("C Matrix")
D = PsiMod.Matrix(nso,nso)
D.set_name("D Matrix")

max_iterations = 100;
deltaE_conv = 1.0E-11
E = 0.0
Eold = 0.0;
deltaE = 0.0;

banner("Iterations", 2)
print '\n'

# Begin Iterations (The zeroth one is the guess) 
print '\n          %9s %20s %20s\n' %('Iteration', 'Energy', 'Delta Energy')
print '\n----------------------------------------------------------------\n'
for iteration in range(0, max_iterations):

    # Sum the Fock Matrix (AO basis)
    for k in range(0,nso):
        for l in range(0,nso):
            F.set(0,k,l,H.get(0,k,l) + G.get(0,k,l))
    
    # Some temporary matrices
    Temp = PsiMod.Matrix(nso,nso)
    Fp = PsiMod.Matrix(nso,nso)
 
    # Transform the Fock Matrix to (orthogonal basis)
    PsiMod.DGEMM(0,'T','N',nso,nso,nso,1.0,X,nso,F,nso,0.0,Temp,nso)
    PsiMod.DGEMM(0,'N','N',nso,nso,nso,1.0,Temp,nso,X,nso,0.0,Fp,nso)
    
    # Eigendecompose the Fock Matrix (orthogonal basis)
    info = PsiMod.DSYEV(0, 'V','U', nso, Fp, nso, eig, W, 4*nso)
    
    # Form the canonical C matrix (AO basis)
    PsiMod.DGEMM(0,'N','T',nso,nso,nso,1.0,X,nso,Fp,nso,0.0,C,nso)

    #C.print_out()

    # Form the canonical D matrix (AO basis)
    PsiMod.DGEMM(0,'N','T',nso,nso,ndocc,1.0,C,nso,C,nso,0.0,D,nso)

    #D.print_out()
    
    # Compute E
    E = Enuc;
    for k in range(0,nso):
        for l in range(0,nso):
            E = E + D.get(0,k,l) * (H.get(0,k,l) + F.get(0,k,l))
    deltaE = E - Eold
    Eold = E 

    print '@RHF Iteration %4d %20.14f %20.14f\n' %(iteration, E, deltaE)

    if (abs(deltaE) < deltaE_conv and iteration > 0):
        break

    # Compute G (in a ridiculously slow way)
    for m in range(0,nso):
        for n in range(0,nso):
            g = 0.0
            for l in range(0,nso):
                for s in range(0,nso):
                    g = g + 2.0 * D.get(0,l,s) * I.get(0, m*nso + n, l*nso + s)
                    g = g - 1.0 * D.get(0,l,s) * I.get(0, m*nso + l, n*nso + s)
            G.set(0,m,n, g)

# Final Output and properties
print '----------------------------------------------------------------\n'
print '\nRHF Final Energy %24.16f [H]\n\n' %(E)

print 'Occupied Orbital Energies:\n'
for k in range(0,ndocc):
    print '  %12.6f\n' % (eig.get(0,k))

print '\nUnoccupied Orbital Energies:\n'
for k in range(ndocc,nso):
    print '  %12.6f\n' % (eig.get(0,k))

print '\n'
C.print_out()
D.print_out()
F.print_out()
G.print_out()

energy('rhf')
