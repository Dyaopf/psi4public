\hypertarget{classJKBuilder_1_1PsiShared}{
\section{PsiShared Class Reference}
\label{classJKBuilder_1_1PsiShared}\index{JKBuilder::PsiShared@{JKBuilder::PsiShared}}
}


{\ttfamily \#include $<$PsiShared.h$>$}Inheritance diagram for PsiShared::\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3cm]{classJKBuilder_1_1PsiShared}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classJKBuilder_1_1PsiShared_aa5f73a8109ec88464262262164feda1e}{BuildJK} (const double $\ast$DensityMatrix, \hyperlink{namespaceJKBuilder_aef21bc37b7cf7bc5ebb5a48628db8d0f}{SharedSymJKMatrix} \&J\_\-Matrix, \hyperlink{namespaceJKBuilder_aef21bc37b7cf7bc5ebb5a48628db8d0f}{SharedSymJKMatrix} \&K\_\-Matrix)
\begin{DoxyCompactList}\small\item\em The function actually in charge of building the J and K matrices. \item\end{DoxyCompactList}\item 
\hyperlink{classJKBuilder_1_1PsiShared_a6500ac4c346e1a9c8c27f8b9f02bb29b}{PsiShared} (\hyperlink{classJKBuilder_1_1AOBasisSet}{AOBasisSet} $\ast$\hyperlink{classJKBuilder_1_1PsiShared_a33250ff04c740919f41b0ffb6c78ada5}{basis}, \hyperlink{classJKBuilder_1_1Integrals}{Integrals} $\ast$\hyperlink{classJKBuilder_1_1PsiShared_abff505bf91f526e978bc6abbf3e0cfc5}{DaInts})
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
std::vector$<$ \hyperlink{namespaceJKBuilder_a490b0a0cd0b0f8f0e280e29b03eb51a3}{Shared2Matrix} $>$ \hyperlink{classJKBuilder_1_1SharedFactory_afabc3015deddc9247c1c2822431a724f}{J}
\begin{DoxyCompactList}\small\item\em The J \hyperlink{classJKBuilder_1_1matrix}{matrix}. \item\end{DoxyCompactList}\item 
std::vector$<$ \hyperlink{namespaceJKBuilder_a490b0a0cd0b0f8f0e280e29b03eb51a3}{Shared2Matrix} $>$ \hyperlink{classJKBuilder_1_1SharedFactory_a59469c5d5576ee51c033626879e699b1}{K}
\begin{DoxyCompactList}\small\item\em The K \hyperlink{classJKBuilder_1_1matrix}{matrix}. \item\end{DoxyCompactList}\item 
std::vector$<$ \hyperlink{namespaceJKBuilder_a490b0a0cd0b0f8f0e280e29b03eb51a3}{Shared2Matrix} $>$ \hyperlink{classJKBuilder_1_1SharedFactory_af21e4022fc5e357635e5b22bb359fcba}{rho}
\begin{DoxyCompactList}\small\item\em The density. \item\end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classJKBuilder_1_1PsiShared_a911b43dc1d1da86bfdbd45e86f4be122}{IsSignificant} (const int i, const int j)
\begin{DoxyCompactList}\small\item\em Replicates Psi's Significance criteria for determining if shell pair i,j should be considered. \item\end{DoxyCompactList}\item 
bool \hyperlink{classJKBuilder_1_1PsiShared_a0ec04bf57470f228eeb9e8f608014edf}{IsSignificant} (const int i, const int j, const int k, const int l)
\begin{DoxyCompactList}\small\item\em The four-\/index version. \item\end{DoxyCompactList}\item 
double \hyperlink{classJKBuilder_1_1PsiShared_af71d3f76014ba72b33336cef6ad2e397}{CalcPrefactor} (const int p, const int q, const int r, const int s)
\begin{DoxyCompactList}\small\item\em Given a shell quartet: pqrs calculates the appropriate weighting factor. \item\end{DoxyCompactList}\item 
void \hyperlink{classJKBuilder_1_1PsiShared_a4b5b1a33d6eb89835454c8b852a1e63b}{FillJK} (std::vector$<$ double $\ast$ $>$ \&JKs, \hyperlink{namespaceJKBuilder_aa50d645c83645be7de5fa94937abf1f3}{SharedBasis} \hyperlink{classJKBuilder_1_1PsiShared_a33250ff04c740919f41b0ffb6c78ada5}{basis}, double $\ast$dp, int $\ast$PQRS, int $\ast$pqrs, const double $\ast$\hyperlink{classJKBuilder_1_1Integrals}{Integrals})
\begin{DoxyCompactList}\small\item\em Given a block of the four electron integrals fills the values into J and K. \item\end{DoxyCompactList}\item 
void \hyperlink{classJKBuilder_1_1PsiShared_ac2d3bee6c0f963913d26d6cc3f7e2403}{FillJK2} (\hyperlink{namespaceJKBuilder_aa50d645c83645be7de5fa94937abf1f3}{SharedBasis} \hyperlink{classJKBuilder_1_1PsiShared_a33250ff04c740919f41b0ffb6c78ada5}{basis}, int P, int Q, double $\ast$JorK, vector$<$ double $\ast$ $>$ JandKs, int index, bool IsSymmetric)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{namespaceJKBuilder_a5f21cc1a0cc795f1cb9aceca0400dcd0}{SharedInts} \hyperlink{classJKBuilder_1_1PsiShared_abff505bf91f526e978bc6abbf3e0cfc5}{DaInts}
\item 
\hyperlink{namespaceJKBuilder_aa50d645c83645be7de5fa94937abf1f3}{SharedBasis} \hyperlink{classJKBuilder_1_1PsiShared_a33250ff04c740919f41b0ffb6c78ada5}{basis}
\end{DoxyCompactItemize}


\subsection{Constructor \& Destructor Documentation}
\hypertarget{classJKBuilder_1_1PsiShared_a6500ac4c346e1a9c8c27f8b9f02bb29b}{
\index{JKBuilder::PsiShared@{JKBuilder::PsiShared}!PsiShared@{PsiShared}}
\index{PsiShared@{PsiShared}!JKBuilder::PsiShared@{JKBuilder::PsiShared}}
\subsubsection[{PsiShared}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PsiShared} ({\bf AOBasisSet} $\ast$ {\em basis}, \/  {\bf Integrals} $\ast$ {\em DaInts})}}
\label{classJKBuilder_1_1PsiShared_a6500ac4c346e1a9c8c27f8b9f02bb29b}


\subsection{Member Function Documentation}
\hypertarget{classJKBuilder_1_1PsiShared_a911b43dc1d1da86bfdbd45e86f4be122}{
\index{JKBuilder::PsiShared@{JKBuilder::PsiShared}!IsSignificant@{IsSignificant}}
\index{IsSignificant@{IsSignificant}!JKBuilder::PsiShared@{JKBuilder::PsiShared}}
\subsubsection[{IsSignificant}]{\setlength{\rightskip}{0pt plus 5cm}bool IsSignificant (const int {\em i}, \/  const int {\em j})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classJKBuilder_1_1PsiShared_a911b43dc1d1da86bfdbd45e86f4be122}


Replicates Psi's Significance criteria for determining if shell pair i,j should be considered. Right now this function does nothing because Psi's significance criteria is based on the magnitude of elements of the 4 index electrons, which I don't have a way at yet... \hypertarget{classJKBuilder_1_1PsiShared_a0ec04bf57470f228eeb9e8f608014edf}{
\index{JKBuilder::PsiShared@{JKBuilder::PsiShared}!IsSignificant@{IsSignificant}}
\index{IsSignificant@{IsSignificant}!JKBuilder::PsiShared@{JKBuilder::PsiShared}}
\subsubsection[{IsSignificant}]{\setlength{\rightskip}{0pt plus 5cm}bool IsSignificant (const int {\em i}, \/  const int {\em j}, \/  const int {\em k}, \/  const int {\em l})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classJKBuilder_1_1PsiShared_a0ec04bf57470f228eeb9e8f608014edf}


The four-\/index version. \hypertarget{classJKBuilder_1_1PsiShared_af71d3f76014ba72b33336cef6ad2e397}{
\index{JKBuilder::PsiShared@{JKBuilder::PsiShared}!CalcPrefactor@{CalcPrefactor}}
\index{CalcPrefactor@{CalcPrefactor}!JKBuilder::PsiShared@{JKBuilder::PsiShared}}
\subsubsection[{CalcPrefactor}]{\setlength{\rightskip}{0pt plus 5cm}double CalcPrefactor (const int {\em p}, \/  const int {\em q}, \/  const int {\em r}, \/  const int {\em s})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classJKBuilder_1_1PsiShared_af71d3f76014ba72b33336cef6ad2e397}


Given a shell quartet: pqrs calculates the appropriate weighting factor. To understand the origin of this prefactor see the comments regarding FillJK. \hypertarget{classJKBuilder_1_1PsiShared_a4b5b1a33d6eb89835454c8b852a1e63b}{
\index{JKBuilder::PsiShared@{JKBuilder::PsiShared}!FillJK@{FillJK}}
\index{FillJK@{FillJK}!JKBuilder::PsiShared@{JKBuilder::PsiShared}}
\subsubsection[{FillJK}]{\setlength{\rightskip}{0pt plus 5cm}void FillJK (std::vector$<$ double $\ast$ $>$ \& {\em JKs}, \/  {\bf SharedBasis} {\em basis}, \/  double $\ast$ {\em dp}, \/  int $\ast$ {\em PQRS}, \/  int $\ast$ {\em pqrs}, \/  const double $\ast$ {\em Integrals})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classJKBuilder_1_1PsiShared_a4b5b1a33d6eb89835454c8b852a1e63b}


Given a block of the four electron integrals fills the values into J and K. Assume we have a block of the four electron integrals that corresponds to shells p,q,r, and s on atoms P,Q,R, and S respectively. Letting i,j,k,l be basis functions belonging to shells p,q,r, and s respectively, it is this functions job to fill in J and K respectively.

Elements of J and K are defined in terms of the density \hyperlink{classJKBuilder_1_1matrix}{matrix}, D, and the four electron integrals as: \begin{eqnarray*} J_{ij}=\sum_{kl}D_{kl}(ij|kl)\\ K_{ij}=\sum_{kl}D_{kl}(ik|jl)\\ K_{ik}=\sum_{jl}D_{jl}(ij|kl), \end{eqnarray*} where in the last line we swapped dummy indices for the exchange \hyperlink{classJKBuilder_1_1matrix}{matrix}, so that it is in terms of the same four electron integral element.

Assume that p!=q!=r!=s for the time being, then note that the summation over kl runs over all pairs including lk; however, the iterator will not give us this element because (ij$|$kl)=(ij$|$lk) and we agreed to only iterate over unique elements. This means we have to add both of these at the same time:

\begin{eqnarray*} J_{ij}=\sum_{kl}\left(D_{kl}+D_{lk}\right)(ij|kl)\\ J_{kl}=\sum_{kl}\left(D_{ij}+D_{ji}\right)(ij|kl), \end{eqnarray*}

where the last line accounts for the fact that we agreed not to iterate over (kl$|$ij), which consequently means we are also not iterating over (kl$|$ji), because they all have the same value. Noting the symmetry of the four electron integral, we are also not iterating over (ji$|$kl), (ji$|$lk), (lk$|$ij), and (lk$|$ji), which correspond to elements J\_\-\{ji\} and J\_\-\{lk\} of the Coulomb \hyperlink{classJKBuilder_1_1matrix}{matrix}. Note that : \begin{eqnarray*} J_{ij}=\sum_{kl}\left(D_{kl}+D_{lk}\right)(ij|kl)\\ J_{ji}=\sum_{kl}\left(D_{kl}+D_{lk}\right)(ij|kl)\\ \therefore J_{ij}=J_{ji}\forall\ \{i,j,D\}, \end{eqnarray*} furthermore this is true whether or not D is symmetric (i.e. D\_\-\{kl\}=D\_\-\{lk\}), which means we never have to worry about the last four elements of this list.

What about the exchange \hyperlink{classJKBuilder_1_1matrix}{matrix}? Our discussion of the J \hyperlink{classJKBuilder_1_1matrix}{matrix} shows that for each element (ij$|$kl), we are essentially considering eight elements: (ij$|$kl), (ij$|$lk), (kl$|$ij), (kl$|$ji), (ji$|$kl), (ji$|$lk), (lk$|$ij), and (lk$|$ji). Based on the equation for the exchange \hyperlink{classJKBuilder_1_1matrix}{matrix} given above, this means we need to update elements $K_{ik}$,$K_{il}$,$K_{ki}$, $K_{kj}$, $K_{jk}$, $K_{li}$, and $K_{lj}$ respectively. Unlike the J \hyperlink{classJKBuilder_1_1matrix}{matrix}: \begin{eqnarray*} K_{ik}=\sum_{jl}D_{jl}(ij|kl)\\ K_{ki}=\sum_{lj}D_{lj}(ji|lk)\\ K_{ik}=K_{ki} \iff\ D_{jl}=D_{lj}, \end{eqnarray*} i.e. if D is symmetric, we only need to consider four elements ($K_{ik}$,$K_{il}$,$K_{jk}$ and $K_{jl}$) if it is not we have to consider all 8, bummer....

Now consider what happens if r==s, in that case our assumption that because (ij$|$kl)=(ij$|$lk) we are not going to consider the element (ij$|$lk) are false (because we iterate each index over the entire range). And if we use the same code, we will double count this integral. Of course an analogous situation exists for p==q and when both are true we actually quadruple count. Less obvious is that when p==r and q==s, also leads to a double counting (not quadruple) scenario; this case stems from assuming we are only going to consider (ij$|$kl) and not (kl$|$ij). Note that p==r or q==s alone corresponds to considering (ij$|$kl) and (kj$|$il) \mbox{[}or (il$|$kj) for the q==s case\mbox{]}, which need to be considered, i.e. there is no general symmetry relation between them. It follows that for the case when p==q==r==s we octuple count the quantity. This is what the prefactor function above accounts for.

It seems to me that these \char`\"{}fringe\char`\"{} cases are actually quite common... TODO: Check if we get a much faster code by omitting these \char`\"{}fringe\char`\"{} cases from the summations. \hypertarget{classJKBuilder_1_1PsiShared_ac2d3bee6c0f963913d26d6cc3f7e2403}{
\index{JKBuilder::PsiShared@{JKBuilder::PsiShared}!FillJK2@{FillJK2}}
\index{FillJK2@{FillJK2}!JKBuilder::PsiShared@{JKBuilder::PsiShared}}
\subsubsection[{FillJK2}]{\setlength{\rightskip}{0pt plus 5cm}void FillJK2 ({\bf SharedBasis} {\em basis}, \/  int {\em P}, \/  int {\em Q}, \/  double $\ast$ {\em JorK}, \/  vector$<$ double $\ast$ $>$ {\em JandKs}, \/  int {\em index}, \/  bool {\em IsSymmetric})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classJKBuilder_1_1PsiShared_ac2d3bee6c0f963913d26d6cc3f7e2403}
\hypertarget{classJKBuilder_1_1PsiShared_aa5f73a8109ec88464262262164feda1e}{
\index{JKBuilder::PsiShared@{JKBuilder::PsiShared}!BuildJK@{BuildJK}}
\index{BuildJK@{BuildJK}!JKBuilder::PsiShared@{JKBuilder::PsiShared}}
\subsubsection[{BuildJK}]{\setlength{\rightskip}{0pt plus 5cm}void BuildJK (const double $\ast$ {\em DensityMatrix}, \/  {\bf SharedSymJKMatrix} \& {\em J\_\-Matrix}, \/  {\bf SharedSymJKMatrix} \& {\em K\_\-Matrix})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classJKBuilder_1_1PsiShared_aa5f73a8109ec88464262262164feda1e}


The function actually in charge of building the J and K matrices. This function first updates the density \hyperlink{classJKBuilder_1_1matrix}{matrix} to be the one given to it. Next, it computes J and K and returns them as \hyperlink{classJKBuilder_1_1matrix}{matrix} objects.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em DensityMatrix}]The density \hyperlink{classJKBuilder_1_1matrix}{matrix} \item[\mbox{$\rightarrow$} {\em J}]The Coulomb \hyperlink{classJKBuilder_1_1matrix}{matrix} corresponding to DensityMatrix \item[\mbox{$\rightarrow$} {\em K}]The Exchange \hyperlink{classJKBuilder_1_1matrix}{matrix} corresponding to DensityMatrix \end{DoxyParams}


Implements \hyperlink{classJKBuilder_1_1JKFactory_ae253b309dafe3ce003fdabfd315318b8}{JKFactory}.

\subsection{Member Data Documentation}
\hypertarget{classJKBuilder_1_1PsiShared_abff505bf91f526e978bc6abbf3e0cfc5}{
\index{JKBuilder::PsiShared@{JKBuilder::PsiShared}!DaInts@{DaInts}}
\index{DaInts@{DaInts}!JKBuilder::PsiShared@{JKBuilder::PsiShared}}
\subsubsection[{DaInts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf SharedInts} {\bf DaInts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classJKBuilder_1_1PsiShared_abff505bf91f526e978bc6abbf3e0cfc5}
\hypertarget{classJKBuilder_1_1PsiShared_a33250ff04c740919f41b0ffb6c78ada5}{
\index{JKBuilder::PsiShared@{JKBuilder::PsiShared}!basis@{basis}}
\index{basis@{basis}!JKBuilder::PsiShared@{JKBuilder::PsiShared}}
\subsubsection[{basis}]{\setlength{\rightskip}{0pt plus 5cm}{\bf SharedBasis} {\bf basis}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classJKBuilder_1_1PsiShared_a33250ff04c740919f41b0ffb6c78ada5}
\hypertarget{classJKBuilder_1_1SharedFactory_afabc3015deddc9247c1c2822431a724f}{
\index{JKBuilder::PsiShared@{JKBuilder::PsiShared}!J@{J}}
\index{J@{J}!JKBuilder::PsiShared@{JKBuilder::PsiShared}}
\subsubsection[{J}]{\setlength{\rightskip}{0pt plus 5cm}std::vector$<${\bf Shared2Matrix}$>$ {\bf J}\hspace{0.3cm}{\ttfamily  \mbox{[}protected, inherited\mbox{]}}}}
\label{classJKBuilder_1_1SharedFactory_afabc3015deddc9247c1c2822431a724f}


The J \hyperlink{classJKBuilder_1_1matrix}{matrix}. \hypertarget{classJKBuilder_1_1SharedFactory_a59469c5d5576ee51c033626879e699b1}{
\index{JKBuilder::PsiShared@{JKBuilder::PsiShared}!K@{K}}
\index{K@{K}!JKBuilder::PsiShared@{JKBuilder::PsiShared}}
\subsubsection[{K}]{\setlength{\rightskip}{0pt plus 5cm}std::vector$<${\bf Shared2Matrix}$>$ {\bf K}\hspace{0.3cm}{\ttfamily  \mbox{[}protected, inherited\mbox{]}}}}
\label{classJKBuilder_1_1SharedFactory_a59469c5d5576ee51c033626879e699b1}


The K \hyperlink{classJKBuilder_1_1matrix}{matrix}. \hypertarget{classJKBuilder_1_1SharedFactory_af21e4022fc5e357635e5b22bb359fcba}{
\index{JKBuilder::PsiShared@{JKBuilder::PsiShared}!rho@{rho}}
\index{rho@{rho}!JKBuilder::PsiShared@{JKBuilder::PsiShared}}
\subsubsection[{rho}]{\setlength{\rightskip}{0pt plus 5cm}std::vector$<${\bf Shared2Matrix}$>$ {\bf rho}\hspace{0.3cm}{\ttfamily  \mbox{[}protected, inherited\mbox{]}}}}
\label{classJKBuilder_1_1SharedFactory_af21e4022fc5e357635e5b22bb359fcba}


The density. 

The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
src/\hyperlink{PsiShared_8h}{PsiShared.h}\item 
src/\hyperlink{PsiShared_8cpp}{PsiShared.cpp}\end{DoxyCompactItemize}
