% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{Psithon Documentation}
\date{February 25, 2012}
\release{4.01}
\author{Psi4 Project}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}
\includegraphics[width=1.000\linewidth]{PSI4_3.png}



To allow arbitrarily complex computations to be performed, PSI4 is built
upon the Python interpreter, with modifications termed Psithon. Chapter 3
of the User's Manual describes the non-standard Python associated with
clean molecule, basis, and option specification in the PSI4 input file.
This documentation addresses the pure Python side- what functions allow
the efficient compiled code to be run, what functions post-process and
interact with that output, and how the ordinary (or ambitious) user can
extent PSI4's functionality.

\begin{notice}{warning}{Warning:}
Python naming practices of file\_that\_includes\_function.function\_name()
are followed below. In psi4 input files, it is only necessary to call the
function name alone. That is, use \code{energy('scf')}, not \code{driver.energy('scf')}.
\end{notice}

\begin{notice}{note}{Note:}
The options documented below are placed as arguments in the command that
calls the Python function, not in the \code{set globals} block or with any
other \code{set} command.
\end{notice}

\begin{notice}{note}{Note:}
Psithon keyword names and values are insensitive to case. The few
exceptions are documented for the \code{database()} function, where case
structure must match the database file.
\end{notice}

\begin{notice}{note}{Note:}
Boolean arguments can be specified by \code{yes}, \code{on}, \code{true}, or \code{1}
for affirmative and \code{no}, \code{off}, \code{false}, or \code{0} for negative,
all insensitive to case.
\end{notice}


\chapter{Energy}
\label{index:energy}\label{index:general}\index{energy() (in module driver)}

\begin{fulllineitems}
\phantomsection\label{index:driver.energy}\pysiglinewithargsret{\code{driver.}\bfcode{energy}}{\emph{name}, \emph{**kwargs}}{}
Function to compute the single-point electronic energy.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
(\emph{float}) Total electronic energy in Hartrees. SAPT returns interaction energy.

\item[{Psi variables}] \leavevmode
\end{description}\end{quote}
\index{environment variable!CURRENTENERGY}\index{environment variable!CURRENTREFERENCEENERGY}\index{environment variable!CURRENTCORRELATIONENERGY}

\begin{fulllineitems}
\phantomsection\label{index:envvar-CURRENTENERGY}\pysigline{\bfcode{CURRENT~ENERGY}}\phantomsection\label{index:envvar-CURRENTREFERENCEENERGY}\pysigline{\bfcode{CURRENT~REFERENCE~ENERGY}}\phantomsection\label{index:envvar-CURRENTCORRELATIONENERGY}\pysigline{\bfcode{CURRENT~CORRELATION~ENERGY}}
\end{fulllineitems}


\begin{longtable}{|l|l|}
\hline
\textbf{
name
} & \textbf{
calls method
}\\\hline
\endfirsthead

\multicolumn{2}{c}%
{{\bfseries \tablename\ \thetable{} -- continued from previous page}} \\
\hline
\textbf{
name
} & \textbf{
calls method
}\\\hline
\endhead

\hline \multicolumn{2}{|r|}{{Continued on next page}} \\ \hline
\endfoot

\hline
\endlastfoot


scf
 & 
Hartree--Fock (HF) or density functional theory (DFT)
\\\hline

mp2
 & 
2nd-order Moller-Plesset perturbation theory (MP2)
\\\hline

df-mp2
 & 
MP2 with density fitting
\\\hline

dcft
 & 
density cumulant functional theory
\\\hline

mcscf
 & 
multiconfigurational self consistent field (SCF)
\\\hline

dfcc
 & 
coupled cluster with density fitting
\\\hline

mp2c
 & 
coupled MP2 (MP2C)
\\\hline

mp2-drpa
 & 
random phase approximation?
\\\hline

sapt0
 & 
0th-order symmetry adapted perturbation theory (SAPT)
\\\hline

sapt2
 & 
2nd-order SAPT, traditional definition
\\\hline

sapt2+
 & 
SAPT including all 2nd-order terms
\\\hline

sapt2+(3)
 & 
SAPT including perturbative triples
\\\hline

sapt2+3
 & \\\hline

sapt0-ct
 & 
0th-order SAPT plus charge transfer (CT) calculation
\\\hline

sapt2-ct
 & 
SAPT2 plus CT
\\\hline

sapt2+-ct
 & 
SAPT2+ plus CT
\\\hline

sapt2+(3)-ct
 & 
SAPT2+(3) plus CT
\\\hline

sapt2+3-ct
 & 
SAPT2+3 plus CT
\\\hline

cc2
 & 
approximate coupled cluster singles and doubles (CC2)
\\\hline

ccsd
 & 
coupled cluster singles and doubles (CCSD)
\\\hline

bccd
 & 
Brueckner coupled cluster doubles (BCCD)
\\\hline

cc3
 & 
approximate coupled cluster singles, doubles, and triples (CC3)
\\\hline

ccsd(t)
 & 
CCSD with perturbative triples
\\\hline

bccd(t)
 & 
BCCD with perturbative triples
\\\hline

ccenergy
 & 
\textbf{expert} full control over ccenergy module
\\\hline

mp \emph{n}
 & 
\emph{n} th-order Moller--Plesset perturbation theory
\\\hline

zapt \emph{n}
 & 
\emph{n} th-order z-averaged perturbation theory (ZAPT)
\\\hline

cisd
 & 
configuration interaction (CI) singles and doubles (CISD)
\\\hline

cisdt
 & 
CI singles, doubles, and triples (CISDT)
\\\hline

cisdtq
 & 
CI singles, doubles, triples, and quadruples (CISDTQ)
\\\hline

ci \emph{n}
 & 
\emph{n} th-order CI
\\\hline

fci
 & 
full configuration interaction (FCI)
\\\hline

detci
 & 
\textbf{expert} full control over detci module
\\\hline

cphf
 & 
coupled-perturbed Hartree-Fock?
\\\hline

cpks
 & 
coupled-perturbed Kohn-Sham?
\\\hline

cis
 & 
CI singles (CIS)
\\\hline

tda
 & 
Tamm-Dankoff approximation (TDA)
\\\hline

tdhf
 & 
time-dependent HF (TDHF)
\\\hline

tddft
 & 
time-dependent DFT (TDDFT)
\\\hline

adc
 & 
2nd-order algebraic diagrammatic construction (ADC)
\\\hline

eom-cc2
 & 
EOM-CC2
\\\hline

eom-ccsd
 & 
equation of motion (EOM) CCSD
\\\hline

eom-cc3
 & 
EOM-CC3
\\\hline
\end{longtable}


\begin{longtable}{|l|l|}
\hline
\textbf{
name
} & \textbf{
calls method in Kallay's MRCC program
}\\\hline
\endfirsthead

\multicolumn{2}{c}%
{{\bfseries \tablename\ \thetable{} -- continued from previous page}} \\
\hline
\textbf{
name
} & \textbf{
calls method in Kallay's MRCC program
}\\\hline
\endhead

\hline \multicolumn{2}{|r|}{{Continued on next page}} \\ \hline
\endfoot

\hline
\endlastfoot


mrccsd
 & 
CC through doubles
\\\hline

mrccsdt
 & 
CC through triples
\\\hline

mrccsdtq
 & 
CC through quadruples
\\\hline

mrccsdtqp
 & 
CC through quintuples
\\\hline

mrccsdtqph
 & 
CC through sextuples
\\\hline

mrccsd(t)
 & 
CC through doubles with perturbative triples
\\\hline

mrccsdt(q)
 & 
CC through triples with perturbative quadruples
\\\hline

mrccsdtq(p)
 & 
CC through quadruples with pertubative quintuples
\\\hline

mrccsdtqp(h)
 & 
CC through quintuples with pertubative sextuples
\\\hline

mrccsd(t)\_l
 & \\\hline

mrccsdt(q)\_l
 & \\\hline

mrccsdtq(p)\_l
 & \\\hline

mrccsdtqp(h)\_l
 & \\\hline

mrccsdt-1a
 & \\\hline

mrccsdtq-1a
 & \\\hline

mrccsdtqp-1a
 & \\\hline

mrccsdtqph-1a
 & \\\hline

mrccsdt-1b
 & \\\hline

mrccsdtq-1b
 & \\\hline

mrccsdtqp-1b
 & \\\hline

mrccsdtqph-1b
 & \\\hline

mrcc2
 & \\\hline

mrcc3
 & \\\hline

mrcc4
 & \\\hline

mrcc5
 & \\\hline

mrcc6
 & \\\hline

mrccsdt-3
 & \\\hline

mrccsdtq-3
 & \\\hline

mrccsdtqp-3
 & \\\hline

mrccsdtqph-3
 & \\\hline
\end{longtable}


\textbf{Keywords}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{name} (\emph{string}) -- 
\code{'scf'} \textbar{}\textbar{} \code{'df-mp2'} \textbar{}\textbar{} \code{'ci5'} \textbar{}\textbar{} etc.

First argument, usually unlabeled. Indicates the computational method
to be applied to the system.


\item {} 
\textbf{bypass\_scf} (\emph{bool}) -- 
\code{'on'} \textbar{}\textbar{} $\Rightarrow$ \code{'off'} $\Leftarrow$

Indicates whether, for \emph{name} values built atop of scf calculations,
the scf step is skipped. Suitable when special steps are taken to get
the scf to converge in an explicit preceeding scf step.


\end{itemize}

\end{description}\end{quote}

\textbf{Examples}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [1] Coupled-cluster singles and doubles calculation with psi code}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{energy}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{ccsd}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [2] Charge-transfer SAPT calculation with scf projection from small into requested basis}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{energy}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{sapt0-ct}\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{cast\PYGZus{}up}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [3] Arbitrary-order MPn calculation}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{energy}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp4}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}



\chapter{Optimize}
\label{index:optimize}
\begin{notice}{note}{Note:}
The derivative level type for {\hyperref[index:driver.optimize]{\code{driver.optimize()}}} and {\hyperref[index:driver.frequency]{\code{driver.frequency()}}}
functions can be specified by \code{energy}, \code{none}, or \code{0} for 0th derivative,
\code{gradient}, \code{first}, or \code{1} for 1st derivative, and \code{hessian},
\code{second}, or \code{2} for 2nd derivative.
\end{notice}
\index{optimize() (in module driver)}

\begin{fulllineitems}
\phantomsection\label{index:driver.optimize}\pysiglinewithargsret{\code{driver.}\bfcode{optimize}}{\emph{name}, \emph{**kwargs}}{}
Function to perform a geometry optimization.
\begin{quote}\begin{description}
\item[{Aliases }] \leavevmode
opt()

\item[{Returns}] \leavevmode
(\emph{float}) Total electronic energy of optimized structure in Hartrees.

\item[{Psi variables}] \leavevmode
\end{description}\end{quote}
\index{environment variable!CURRENTENERGY}

\begin{fulllineitems}
\phantomsection\label{index:envvar-CURRENTENERGY}\pysigline{\bfcode{CURRENT~ENERGY}}
\end{fulllineitems}


\begin{notice}{note}{Note:}
Analytic gradients area available for all methods in the table
below. Optimizations with other methods in the energy table proceed
by finite differences.
\end{notice}

\begin{notice}{caution}{Caution:}
Some features are not yet implemented. Buy a developer a coffee.
\begin{itemize}
\item {} 
Need to check that all methods do return electronic energy. I think gradient got changed at one point.

\end{itemize}
\end{notice}

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{
name
} & \textbf{
calls method
}\\\hline

scf
 & 
Hartree--Fock (HF) or density functional theory (DFT)
\\\hline

mp2
 & 
2nd-order Moller-Plesset perturbation theory (MP2)
\\\hline

ccsd
 & 
coupled cluster singles and doubles (CCSD)
\\\hline

ccsd(t)
 & 
CCSD with perturbative triples
\\\hline

eom-ccsd
 & 
equation of motion (EOM) CCSD
\\\hline
\end{tabulary}


\textbf{Keywords}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{name} (\emph{string}) -- 
\code{'scf'} \textbar{}\textbar{} \code{'df-mp2'} \textbar{}\textbar{} \code{'ci5'} \textbar{}\textbar{} etc.

First argument, usually unlabeled. Indicates the computational method
to be applied to the database. May be any valid argument to
{\hyperref[index:driver.energy]{\code{driver.energy()}}}.


\item {} 
\textbf{func} (\emph{function}) -- 
$\Rightarrow$ \code{gradient} $\Leftarrow$ \textbar{}\textbar{} \code{energy} \textbar{}\textbar{} \code{cbs}

Indicates the type of calculation to be performed on the molecule.
The default dertype accesses{}`{}`'gradient'{}`{}` or \code{'energy'}, while
\code{'cbs'} performs a multistage finite difference calculation.
If a nested series of python functions is intended (see {\hyperref[index:function-intercalls]{Function Intercalls}}),
use keyword \code{opt\_func} instead of \code{func}.


\item {} 
\textbf{mode} (\emph{string}) -- 
$\Rightarrow$ \code{'continuous'} $\Leftarrow$ \textbar{}\textbar{} \code{'sow'} \textbar{}\textbar{} \code{'reap'}

Indicates whether the calculation required to complete the
optimization are to be run in one file (\code{'continuous'}) or are to be
farmed out in an embarrassingly parallel fashion
(\code{'sow'}/\code{'reap'}).  For the latter, run an initial job with
\code{'sow'} and follow instructions in its output file.


\item {} 
\textbf{dertype} (\emph{dertype}) -- 
\code{'gradient'} \textbar{}\textbar{} \code{'energy'}

Indicates whether analytic (if available) or finite difference
optimization is to be performed.


\end{itemize}

\end{description}\end{quote}

\textbf{Examples}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [1] Analytic scf optimization}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{optimize}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{scf}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [2] Finite difference mp3 optimization}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{opt}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp3}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [3] Forced finite difference ccsd optimization}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{optimize}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{ccsd}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{dertype}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}



\chapter{Response}
\label{index:response}\index{response() (in module driver)}

\begin{fulllineitems}
\phantomsection\label{index:driver.response}\pysiglinewithargsret{\code{driver.}\bfcode{response}}{\emph{name}, \emph{**kwargs}}{}
Function to compute linear response properties.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
(\emph{float}) Total electronic energy in Hartrees.

\end{description}\end{quote}

\begin{notice}{caution}{Caution:}
Some features are not yet implemented. Buy a developer a coffee.
\begin{itemize}
\item {} 
Check that energy is actually being returned.

\item {} 
Check if ther're some PSI variables that ought to be set.

\end{itemize}
\end{notice}

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{
name
} & \textbf{
calls method
}\\\hline

cc2
 & 
2nd-order approximate CCSD
\\\hline

ccsd
 & 
coupled cluster singles and doubles (CCSD)
\\\hline
\end{tabulary}


\textbf{Keywords}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{name} (\emph{string}) -- 
\code{'ccsd'} \textbar{}\textbar{} etc.

First argument, usually unlabeled. Indicates the computational method
to be applied to the system.


\end{description}\end{quote}

\textbf{Examples}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [1] CCSD-LR properties calculation}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{response}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{ccsd}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}



\chapter{Frequency}
\label{index:frequency}\index{frequency() (in module driver)}

\begin{fulllineitems}
\phantomsection\label{index:driver.frequency}\pysiglinewithargsret{\code{driver.}\bfcode{frequency}}{\emph{name}, \emph{**kwargs}}{}
Function to compute harmonic vibrational frequencies.
\begin{quote}\begin{description}
\item[{Aliases }] \leavevmode
frequencies(), freq()

\item[{Returns}] \leavevmode
(\emph{float}) Total electronic energy in Hartrees.

\end{description}\end{quote}

\begin{notice}{caution}{Caution:}
Some features are not yet implemented. Buy a developer a coffee.
\begin{itemize}
\item {} 
RAK, why are you adding OPTKING options as GLOBALS? And shouldn't they be Py-side not C-side options?

\item {} 
Put in a dictionary, so IRREPS can be called by symmetry element or `all'

\item {} 
Make frequency look analogous to gradient, especially in matching derivative levels. Make dertype actually a dertype type.

\end{itemize}
\end{notice}

\textbf{Keywords}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{name} (\emph{string}) -- 
\code{'scf'} \textbar{}\textbar{} \code{'df-mp2'} \textbar{}\textbar{} \code{'ci5'} \textbar{}\textbar{} etc.

First argument, usually unlabeled. Indicates the computational method
to be applied to the system.


\item {} 
\textbf{dertype} (\emph{dertype}) -- 
$\Rightarrow$ \code{'hessian'} $\Leftarrow$ \textbar{}\textbar{} \code{'gradient'} \textbar{}\textbar{} \code{'energy'}

Indicates whether analytic (if available- they're not), finite
difference of gradients (if available) or finite difference of
energies is to be performed.


\item {} 
\textbf{irrep} (\emph{int}) -- 
$\Rightarrow$ \code{-1} $\Leftarrow$ \textbar{}\textbar{} \code{1} \textbar{}\textbar{} etc.

Indicates which symmetry block of vibrational freqiencies to be
computed. 1 represents $a_1$, requesting only the totally symmetric modes.
\code{-1} indicates a full frequency calculation.


\end{itemize}

\end{description}\end{quote}

\textbf{Examples}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [1] \textless{}example description\textgreater{}}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{o}{\textless{}}\PYG{n}{example} \PYG{n}{python} \PYG{n}{command}\PYG{o}{\textgreater{}}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [2] Frequency calculation for b2 modes through finite difference of gradients}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{frequencies}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{scf}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{dertype}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{irrep}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}



\chapter{Counterpoise Correct}
\label{index:counterpoise-correct}\index{cp() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{index:wrappers.cp}\pysiglinewithargsret{\code{wrappers.}\bfcode{cp}}{\emph{name}\optional{, \emph{func}, \emph{check\_bsse}}}{}
The cp function computes counterpoise-corrected two-body interaction energies
for complexes composed of arbitrary numbers of monomers.
\begin{quote}\begin{description}
\item[{Aliases }] \leavevmode
counterpoise\_correct(), counterpoise\_correction()

\item[{Returns}] \leavevmode
(\emph{float}) Counterpoise-corrected interaction energy in kcal/mol

\item[{Psi variables}] \leavevmode
\end{description}\end{quote}
\index{environment variable!CP-CORRECTED2-BODYINTERACTIONENERGY}\index{environment variable!UNCP-CORRECTED2-BODYINTERACTIONENERGY}

\begin{fulllineitems}
\phantomsection\label{index:envvar-CP-CORRECTED2-BODYINTERACTIONENERGY}\pysigline{\bfcode{CP-CORRECTED~2-BODY~INTERACTION~ENERGY}}\phantomsection\label{index:envvar-UNCP-CORRECTED2-BODYINTERACTIONENERGY}\pysigline{\bfcode{UNCP-CORRECTED~2-BODY~INTERACTION~ENERGY}}
\end{fulllineitems}


\begin{notice}{caution}{Caution:}
Some features are not yet implemented. Buy a developer a coffee.
\begin{itemize}
\item {} 
No values of func besides energy have been tested.

\item {} 
Table print-out needs improving. Add some PSI variables.

\end{itemize}
\end{notice}

\textbf{Keywords}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{name} (\emph{string}) -- 
\code{'scf'} \textbar{}\textbar{} \code{'ccsd(t)'} \textbar{}\textbar{} etc.

First argument, usually unlabeled. Indicates the computational method
to be applied to the molecule. May be any valid argument to
{\hyperref[index:driver.energy]{\code{driver.energy()}}}; however, SAPT is not appropriate.


\item {} 
\textbf{func} (\emph{function}) -- 
$\Rightarrow$ \code{energy} $\Leftarrow$ \textbar{}\textbar{} \code{optimize} \textbar{}\textbar{} \code{cbs}

Indicates the type of calculation to be performed on the molecule
and each of its monomers. The default performs a single-point
\code{energy('name')}, while \code{optimize} perfoms a geometry optimization
on each system, and \code{cbs} performs a compound single-point energy.
If a nested series of python functions is intended
(see {\hyperref[index:function-intercalls]{Function Intercalls}}), use keyword \code{cp\_func} instead of \code{func}.


\item {} 
\textbf{check\_bsse} (\emph{bool}) -- 
\code{'on'} \textbar{}\textbar{} $\Rightarrow$ \code{'off'} $\Leftarrow$

Indicates whether to additionally compute un-counterpoise corrected
monomers and thus obtain an estimate for the basis set superposition error.


\end{itemize}

\end{description}\end{quote}

\textbf{Examples}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [1] counterpoise-corrected mp2 interaction energy}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{cp}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{dfmp2}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}



\chapter{Database}
\label{index:database}\index{database() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{index:wrappers.database}\pysiglinewithargsret{\code{wrappers.}\bfcode{database}}{\emph{name}, \emph{db\_name}\optional{, \emph{func}, \emph{mode}, \emph{cp}, \emph{rlxd}, \emph{symm}, \emph{zpe}, \emph{benchmark}, \emph{tabulate}, \emph{subset}}}{}
Function to access the molecule objects and reference energies of
popular chemical databases.
\begin{quote}\begin{description}
\item[{Aliases }] \leavevmode
db()

\item[{Returns}] \leavevmode
(\emph{float}) Mean absolute deviation of the database in kcal/mol

\item[{Psi variables}] \leavevmode
\end{description}\end{quote}
\index{environment variable!db\_nameDATABASEMEANSIGNEDDEVIATION}\index{environment variable!db\_nameDATABASEMEANABSOLUTEDEVIATION}\index{environment variable!db\_nameDATABASEROOT-MEAN-SQUAREDEVIATION}

\begin{fulllineitems}
\phantomsection\label{index:envvar-db_nameDATABASEMEANSIGNEDDEVIATION}\pysigline{\bfcode{db\_name~DATABASE~MEAN~SIGNED~DEVIATION}}\phantomsection\label{index:envvar-db_nameDATABASEMEANABSOLUTEDEVIATION}\pysigline{\bfcode{db\_name~DATABASE~MEAN~ABSOLUTE~DEVIATION}}\phantomsection\label{index:envvar-db_nameDATABASEROOT-MEAN-SQUAREDEVIATION}\pysigline{\bfcode{db\_name~DATABASE~ROOT-MEAN-SQUARE~DEVIATION}}
\end{fulllineitems}


\begin{notice}{note}{Note:}
It is very easy to make a database from a collection of xyz files
using the script \code{\$PSIDATADIR/databases/ixyz2database.pl}.
See {\hyperref[index:creating-a-new-database]{Creating a New Database}} for details.
\end{notice}

\begin{notice}{caution}{Caution:}
Some features are not yet implemented. Buy a developer some coffee.
\begin{itemize}
\item {} 
In sow/reap mode, use only global options (e.g., the local option set by \code{set scf scf\_type df} will not be respected).

\end{itemize}
\end{notice}

\textbf{Keywords}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{name} (\emph{string}) -- 
\code{'scf'} \textbar{}\textbar{} \code{'sapt0'} \textbar{}\textbar{} \code{'ccsd(t)'} \textbar{}\textbar{} etc.

First argument, usually unlabeled. Indicates the computational method
to be applied to the database. May be any valid argument to
{\hyperref[index:driver.energy]{\code{driver.energy()}}}.


\item {} 
\textbf{db\_name} (\emph{string}) -- 
\code{'BASIC'} \textbar{}\textbar{} \code{'S22'} \textbar{}\textbar{} \code{'HTBH'} \textbar{}\textbar{} etc.

Second argument, usually unlabeled. Indicates the requested database
name, matching the name of a python file in \code{psi4/lib/databases}.
Consult that directory for available databases and literature citations.


\item {} 
\textbf{func} (\emph{function}) -- 
$\Rightarrow$ \code{energy} $\Leftarrow$ \textbar{}\textbar{} \code{optimize} \textbar{}\textbar{} \code{cbs}

Indicates the type of calculation to be performed on each database
member. The default performs a single-point \code{energy('name')}, while
\code{optimize} perfoms a geometry optimization on each reagent, and
\code{cbs} performs a compound single-point energy. If a nested series
of python functions is intended (see {\hyperref[index:function-intercalls]{Function Intercalls}}), use
keyword \code{db\_func} instead of \code{func}.


\item {} 
\textbf{mode} (\emph{string}) -- 
$\Rightarrow$ \code{'continuous'} $\Leftarrow$ \textbar{}\textbar{} \code{'sow'} \textbar{}\textbar{} \code{'reap'}

Indicates whether the calculations required to complete the
database are to be run in one file (\code{'continuous'}) or are to be
farmed out in an embarrassingly parallel fashion
(\code{'sow'}/\code{'reap'}).  For the latter, run an initial job with
\code{'sow'} and follow instructions in its output file.


\item {} 
\textbf{cp} (\emph{bool}) -- 
\code{'on'} \textbar{}\textbar{} $\Rightarrow$ \code{'off'} $\Leftarrow$

Indicates whether counterpoise correction is employed in computing
interaction energies. Use this option and NOT the {\hyperref[index:wrappers.cp]{\code{wrappers.cp()}}}
function for BSSE correction in database().  Option
valid only for databases consisting of bimolecular complexes.


\item {} 
\textbf{rlxd} (\emph{bool}) -- 
\code{'on'} \textbar{}\textbar{} $\Rightarrow$ \code{'off'} $\Leftarrow$

Indicates whether correction for deformation energy is
employed in computing interaction energies.  Option valid only for
databases consisting of bimolecular complexes with non-frozen
monomers, e.g., HBC6.


\item {} 
\textbf{symm} (\emph{bool}) -- 
$\Rightarrow$ \code{'on'} $\Leftarrow$ \textbar{}\textbar{} \code{'off'}

Indicates whether the native symmetry of the database reagents is
employed (\code{'on'}) or whether it is forced to $C_1$ symmetry
(\code{'off'}). Some computational methods (e.g., SAPT) require no
symmetry, and this will be set by database().


\item {} 
\textbf{zpe} (\emph{bool}) -- 
\code{'on'} \textbar{}\textbar{} $\Rightarrow$ \code{'off'} $\Leftarrow$

Indicates whether zero-point-energy corrections are appended to
single-point energy values. Option valid only for certain
thermochemical databases. Disabled until Hessians ready.


\item {} 
\textbf{benchmark} (\emph{string}) -- 
$\Rightarrow$ \code{'default'} $\Leftarrow$ \textbar{}\textbar{} \code{'S22A'} \textbar{}\textbar{} etc.

Indicates whether a non-default set of reference energies, if
available, are employed for the calculation of error statistics.


\item {} 
\textbf{tabulate} (\emph{array of strings}) -- 
$\Rightarrow$ \code{{[}{]}} $\Leftarrow$ \textbar{}\textbar{} \code{{[}'scf total energy', 'natom'{]}} \textbar{}\textbar{} etc.

Indicates whether to form tables of variables other than the
primary requested energy.  Available for any PSI variable.


\item {} 
\textbf{subset} (\emph{string or array of strings}) -- 
Indicates a subset of the full database to run. This is a very
flexible option and can be used in three distinct ways, outlined
below. Note that two take a string and the last takes an array.
\begin{itemize}
\item {} \begin{description}
\item[{\code{'small'} \textbar{}\textbar{} \code{'large'} \textbar{}\textbar{} \code{'equilibrium'}}] \leavevmode
Calls predefined subsets of the requested database, either
\code{'small'}, a few of the smallest database members,
\code{'large'}, the largest of the database members, or
\code{'equilibrium'}, the equilibrium geometries for a database
composed of dissociation curves.

\end{description}

\item {} \begin{description}
\item[{\code{'BzBz\_S'} \textbar{}\textbar{} \code{'FaOOFaON'} \textbar{}\textbar{} \code{'ArNe'} \textbar{}\textbar{} etc.}] \leavevmode
For databases composed of dissociation curves, individual
curves can be called by name. Consult the database python
files for available molecular systems.  The choices for this
keyword are case sensitive and must match the database python file

\end{description}

\item {} \begin{description}
\item[{\code{{[}1,2,5{]}} \textbar{}\textbar{} \code{{[}'1','2','5'{]}} \textbar{}\textbar{} \code{{[}'BzMe-3.5', 'MeMe-5.0'{]}} \textbar{}\textbar{} etc.}] \leavevmode
Specify a list of database members to run. Consult the
database python files for available molecular systems.  The
choices for this keyword are case sensitive and must match the
database python file

\end{description}

\end{itemize}


\end{itemize}

\end{description}\end{quote}

\textbf{Examples}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{db}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{scf}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{RGC10}\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{cast\PYGZus{}up}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{sto-3g}\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{subset}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{HeHe-0.85}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{HeHe-1.0}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{HeHe-1.5}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{,} \PYG{n}{tabulate}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{scf total energy}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{natom}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [2] Counterpoise-corrected interaction energies for three complexes in S22}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{}     Error statistics computed wrt an old benchmark, S22A}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{database}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{dfmp2}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{S22}\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{cp}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{subset}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{l+m+mi}{17}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{,}\PYG{n}{benchmark}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{S22A}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [3] SAPT0 on the neon dimer dissociation curve}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{db}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{sapt0}\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{subset}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{NeNe}\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{cp}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{symm}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{db\PYGZus{}name}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{RGC10}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{db}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp2}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{S22}\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{db\PYGZus{}func}\PYG{o}{=}\PYG{n}{optimize}\PYG{p}{,}\PYG{n}{subset}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{tabulate}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{mp2 total energy}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{current energy}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{database}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{ccsd}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{HTBH}\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{subset}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{small}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{tabulate}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{ccsd total energy}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{mp2 total energy}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}



\section{Output}
\label{index:output}
At the beginning of a database job is printed a listing of the individual system
calculations which will be performed. The output snippet below is from the example job {[}1{]}
above. It shows each reagent required for the subset of database reactions requested.
Note that this is an un-counterpoise-corrected example, and the wrapper is smart enough
to compute only once the monomer whose energy will be subtracted from each of the three dimers.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{RGC1}\PYG{o}{-}\PYG{n}{HeHe}\PYG{o}{-}\PYG{l+m+mf}{0.85}\PYG{o}{-}\PYG{n}{dimer}
\PYG{n}{RGC1}\PYG{o}{-}\PYG{n}{He}\PYG{o}{-}\PYG{n}{mono}\PYG{o}{-}\PYG{n}{unCP}
\PYG{n}{RGC1}\PYG{o}{-}\PYG{n}{HeHe}\PYG{o}{-}\PYG{l+m+mf}{1.0}\PYG{o}{-}\PYG{n}{dimer}
\PYG{n}{RGC1}\PYG{o}{-}\PYG{n}{HeHe}\PYG{o}{-}\PYG{l+m+mf}{1.5}\PYG{o}{-}\PYG{n}{dimer}
\end{Verbatim}

At the end of the job, the Requested Energy table is printed that gives the total
energies for the requested model chemistry for each reagent and each reaction, as
well as the stoichoimetric weights by which the reagent energies are transfromed
into the reaction energy. In this case, the dimer is +1 and the monomer is -2,
indicating the the interaction energy is computed from dimer less first monomer
less second (identical) monomer. Error statistics are computed with respect to the reference
energies stored in the database. One of these, the mean absolute deviation, is
returned by the wrapper as an ordinary Python variable. (For databases
without a stored reference energy, e.g., BASIC, large and meaningless numbers are
printed for error.) The other two tables tabulate the PSI variables requested
through keyword \code{tabulate}, in this case the total SCF energy and the number
of atoms in each reagent.

\begin{Verbatim}[commandchars=\\\{\}]
==\textgreater{} Scf Total Energy \textless{}==

-----------------------------------------------------------------------------------
         Reaction          Reaction Value              Reagent 1       Reagent 2
                                                        Value Wt        Value Wt
-----------------------------------------------------------------------------------
   RGC1-HeHe-0.85              0.00011520         -5.71020576  1  -2.85516048 -2
    RGC1-HeHe-1.0              0.00000153         -5.71031943  1  -2.85516048 -2
    RGC1-HeHe-1.5             -0.00000000         -5.71032096  1  -2.85516048 -2
-----------------------------------------------------------------------------------

==\textgreater{} Natom \textless{}==

-----------------------------------------------------------------------------------
         Reaction          Reaction Value              Reagent 1       Reagent 2
                                                        Value Wt        Value Wt
-----------------------------------------------------------------------------------
   RGC1-HeHe-0.85              0.00000000          2.00000000  1   1.00000000 -2
    RGC1-HeHe-1.0              0.00000000          2.00000000  1   1.00000000 -2
    RGC1-HeHe-1.5              0.00000000          2.00000000  1   1.00000000 -2
-----------------------------------------------------------------------------------

==\textgreater{} Requested Energy \textless{}==

-----------------------------------------------------------------------------------
         Reaction     Reaction Energy      Error       Reagent 1       Reagent 2
                         Ref     Calc [kcal/mol]          [H] Wt          [H] Wt
-----------------------------------------------------------------------------------
   RGC1-HeHe-0.85     0.0376   0.0723     0.0347  -5.71020576  1  -2.85516048 -2
    RGC1-HeHe-1.0    -0.0219   0.0010     0.0228  -5.71031943  1  -2.85516048 -2
    RGC1-HeHe-1.5    -0.0029  -0.0000     0.0029  -5.71032096  1  -2.85516048 -2
-----------------------------------------------------------------------------------
      Minimal Dev                         0.0029
      Maximal Dev                         0.0347
  Mean Signed Dev                         0.0201
Mean Absolute Dev                         0.0201
          RMS Dev                         0.0240
-----------------------------------------------------------------------------------
\end{Verbatim}


\chapter{Complete Basis Set}
\label{index:complete-basis-set}\index{complete\_basis\_set() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{index:wrappers.complete_basis_set}\pysiglinewithargsret{\code{wrappers.}\bfcode{complete\_basis\_set}}{\emph{name}\optional{, \emph{scf\_basis}, \emph{scf\_scheme}, \emph{corl\_wfn}, \emph{corl\_basis}, \emph{corl\_scheme}, \emph{delta\_wfn}, \emph{delta\_wfn\_lesser}, \emph{delta\_basis}, \emph{delta\_scheme}, \emph{delta2\_wfn}, \emph{delta2\_wfn\_lesser}, \emph{delta2\_basis}, \emph{delta2\_scheme}}}{}
Function to define a multistage energy method from combinations of
basis set extrapolations and delta corrections and condense the
components into a minimum number of calculations.
\begin{quote}\begin{description}
\item[{Aliases }] \leavevmode
cbs()

\item[{Returns}] \leavevmode
(\emph{float}) -- Total electronic energy in Hartrees

\item[{Psi variables}] \leavevmode
\end{description}\end{quote}
\index{environment variable!CBSTOTALENERGY}\index{environment variable!CBSREFERENCEENERGY}\index{environment variable!CBSCORRELATIONENERGY}\index{environment variable!CURRENTENERGY}\index{environment variable!CURRENTREFERENCEENERGY}\index{environment variable!CURRENTCORRELATIONENERGY}

\begin{fulllineitems}
\phantomsection\label{index:envvar-CBSTOTALENERGY}\pysigline{\bfcode{CBS~TOTAL~ENERGY}}\phantomsection\label{index:envvar-CBSREFERENCEENERGY}\pysigline{\bfcode{CBS~REFERENCE~ENERGY}}\phantomsection\label{index:envvar-CBSCORRELATIONENERGY}\pysigline{\bfcode{CBS~CORRELATION~ENERGY}}\phantomsection\label{index:envvar-CURRENTENERGY}\pysigline{\bfcode{CURRENT~ENERGY}}\phantomsection\label{index:envvar-CURRENTREFERENCEENERGY}\pysigline{\bfcode{CURRENT~REFERENCE~ENERGY}}\phantomsection\label{index:envvar-CURRENTCORRELATIONENERGY}\pysigline{\bfcode{CURRENT~CORRELATION~ENERGY}}
\end{fulllineitems}


\begin{notice}{caution}{Caution:}
Some features are not yet implemented. Buy a developer a coffee.
\begin{itemize}
\item {} 
Methods beyond basic scf, mp2, ccsd, ccsd(t) not yet hooked in through PSI variables, df-mp2 in particular.

\item {} 
No scheme defaults for given basis zeta number, so scheme must be specified explicitly.

\item {} 
No way to tell function to boost fitting basis size for all calculations.

\item {} 
No way to extrapolate def2 family basis sets

\item {} 
Need to add more extrapolation schemes

\end{itemize}
\end{notice}

As represented in the equation below, a CBS energy method is defined in four
sequential stages (scf, corl, delta, delta2) covering treatment of the
reference total energy, the correlation energy, a delta correction to the
correlation energy, and a second delta correction. Each is activated by its
stage\_wfn keyword and is only allowed if all preceding stages are active.
\begin{gather}
\begin{split}E_{total}^{\text{CBS}} = \mathcal{F}_{\textbf{scf\_scheme}} \left(E_{total,\; \text{SCF}}^{\textbf{scf\_basis}}\right) \; + \mathcal{F}_{\textbf{corl\_scheme}} \left(E_{corl,\; \textbf{corl\_wfn}}^{\textbf{corl\_basis}}\right) \; + \delta_{\textbf{delta\_wfn\_lesser}}^{\textbf{delta\_wfn}} \; + \delta_{\textbf{delta2\_wfn\_lesser}}^{\textbf{delta2\_wfn}}\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
Here, $\mathcal{F}$ is an energy or energy extrapolation scheme, and the following also hold.
\begin{gather}
\begin{split}\delta_{\textbf{delta\_wfn\_lesser}}^{\textbf{delta\_wfn}} \; = \mathcal{F}_{\textbf{delta\_scheme}} \left(E_{corl,\; \textbf{delta\_wfn}}^{\textbf{delta\_basis}}\right) - \mathcal{F}_{\textbf{delta\_scheme}} \left(E_{corl,\; \textbf{delta\_wfn\_lesser}}^{\textbf{delta\_basis}}\right)\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}\begin{gather}
\begin{split}\delta_{\textbf{delta2\_wfn\_lesser}}^{\textbf{delta2\_wfn}} \; = \mathcal{F}_{\textbf{delta2\_scheme}} \left(E_{corl,\; \textbf{delta2\_wfn}}^{\textbf{delta2\_basis}}\right) - \mathcal{F}_{\textbf{delta2\_scheme}} \left(E_{corl,\; \textbf{delta2\_wfn\_lesser}}^{\textbf{delta2\_basis}}\right)\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
A translation of this ungainly equation to example {[}5{]} below is as
follows. In words, this is a double- and triple-zeta 2-point
Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction
appended to a triple- and quadruple-zeta 2-point
Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ
reference energy.
\begin{gather}
\begin{split}E_{total}^{\text{CBS}} = \mathcal{F}_{\text{highest\_1}} \left(E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}}\right) \; + \mathcal{F}_{\text{corl\_xtpl\_helgaker\_2}} \left(E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}}\right) \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}\begin{gather}
\begin{split}\delta_{\text{MP2}}^{\text{CCSD(T)}} \; = \mathcal{F}_{\text{corl\_xtpl\_helgaker\_2}} \left(E_{corl,\; \text{CCSD(T)}}^{\text{aug-cc-pV[DT]Z}}\right) - \mathcal{F}_{\text{corl\_xtpl\_helgaker\_2}} \left(E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[DT]Z}}\right)\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
\textbf{Keywords}
\begin{itemize}
\item {} \begin{description}
\item[{Energy Methods}] \leavevmode
The presence of a stage\_wfn keyword is the indicator to incorporate
(and check for stage\_basis and stage\_scheme keywords) and compute
that stage in defining the CBS energy.

\end{description}

\end{itemize}
\begin{description}
\item[{The cbs() function requires, at a minimum, \code{name='scf'} and \code{scf\_basis}}] \leavevmode
keywords to be specified for reference-step only jobs and \code{name} and
\code{corl\_basis} keywords for correlated jobs.

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{name} (\emph{string}) -- 
\code{'scf'} \textbar{}\textbar{} \code{'ccsd'} \textbar{}\textbar{} etc.

First argument, usually unlabeled. Indicates the computational method
for the correlation energy, unless only reference step to be performed,
in which case should be \code{'scf'}. Overruled if stage\_wfn keywords supplied.


\item {} 
\textbf{corl\_wfn} (\emph{string}) -- 
\code{'mp2'} \textbar{}\textbar{} \code{'ccsd(t)'} \textbar{}\textbar{} etc.

Indicates the energy method for which the correlation energy is to be
obtained. Can also be specified with \code{name} or as the unlabeled
first argument to the function.


\item {} 
\textbf{delta\_wfn} (\emph{string}) -- 
\code{'ccsd'} \textbar{}\textbar{} \code{'ccsd(t)'} \textbar{}\textbar{} etc.

Indicates the (superior) energy method for which a delta correction
to the correlation energy is to be obtained.


\item {} 
\textbf{delta\_wfn\_lesser} (\emph{string}) -- 
$\Rightarrow$ \code{'mp2'} $\Leftarrow$ \textbar{}\textbar{} \code{'ccsd'} \textbar{}\textbar{} etc.

Indicates the inferior energy method for which a delta correction
to the correlation energy is to be obtained.


\item {} 
\textbf{delta2\_wfn} (\emph{string}) -- 
\code{'ccsd'} \textbar{}\textbar{} \code{'ccsd(t)'} \textbar{}\textbar{} etc.

Indicates the (superior) energy method for which a second delta correction
to the correlation energy is to be obtained.


\item {} 
\textbf{delta2\_wfn\_lesser} (\emph{string}) -- 
$\Rightarrow$ \code{'mp2'} $\Leftarrow$ \textbar{}\textbar{} \code{'ccsd(t)'} \textbar{}\textbar{} etc.

Indicates the inferior energy method for which a second delta correction
to the correlation energy is to be obtained.


\end{itemize}

\end{description}\end{quote}
\begin{itemize}
\item {} \begin{description}
\item[{Basis Sets}] \leavevmode
Currently, the basis set set through \code{set} commands have no influence
on a cbs calculation.

\end{description}

\end{itemize}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{scf\_basis} (\emph{string}) -- 
$\Rightarrow$ \code{corl\_basis} $\Leftarrow$ \textbar{}\textbar{} \code{'cc-pV{[}TQ{]}Z'} \textbar{}\textbar{} \code{'jun-cc-pv{[}tq5{]}z'} \textbar{}\textbar{} \code{'6-31G*'} \textbar{}\textbar{} etc.

Indicates the sequence of basis sets employed for the reference energy.
If any correlation method is specified, \code{scf\_basis} can default
to \code{corl\_basis}.


\item {} 
\textbf{corl\_basis} (\emph{string}) -- 
\code{'cc-pV{[}TQ{]}Z'} \textbar{}\textbar{} \code{'jun-cc-pv{[}tq5{]}z'} \textbar{}\textbar{} \code{'6-31G*'} \textbar{}\textbar{} etc.

Indicates the sequence of basis sets employed for the correlation energy.


\item {} 
\textbf{delta\_basis} (\emph{string}) -- 
\code{'cc-pV{[}TQ{]}Z'} \textbar{}\textbar{} \code{'jun-cc-pv{[}tq5{]}z'} \textbar{}\textbar{} \code{'6-31G*'} \textbar{}\textbar{} etc.

Indicates the sequence of basis sets employed for the delta correction
to the correlation energy.


\item {} 
\textbf{delta2\_basis} (\emph{string}) -- 
\code{'cc-pV{[}TQ{]}Z'} \textbar{}\textbar{} \code{'jun-cc-pv{[}tq5{]}z'} \textbar{}\textbar{} \code{'6-31G*'} \textbar{}\textbar{} etc.

Indicates the sequence of basis sets employed for the second delta correction
to the correlation energy.


\end{itemize}

\end{description}\end{quote}
\begin{itemize}
\item {} \begin{description}
\item[{Schemes}] \leavevmode
Transformations of the energy through basis set extrapolation for each
stage of the CBS definition. A complaint is generated if number of basis
sets in stage\_basis does not exactly satisfy requirements of stage\_scheme.
An exception is the default, \code{'highest\_1'}, which uses the best basis
set available. See {\hyperref[index:extrapolation-schemes]{Extrapolation Schemes}} for all available schemes.

\end{description}

\end{itemize}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{scf\_scheme} (\emph{function}) -- 
$\Rightarrow$ \code{highest\_1} $\Leftarrow$ \textbar{}\textbar{} \code{scf\_xtpl\_helgaker\_3} \textbar{}\textbar{} etc.

Indicates the basis set extrapolation scheme to be applied to the reference energy.


\item {} 
\textbf{corl\_scheme} (\emph{function}) -- 
$\Rightarrow$ \code{highest\_1} $\Leftarrow$ \textbar{}\textbar{} \code{corl\_xtpl\_helgaker\_2} \textbar{}\textbar{} etc.

Indicates the basis set extrapolation scheme to be applied to the correlation energy.


\item {} 
\textbf{delta\_scheme} (\emph{function}) -- 
$\Rightarrow$ \code{highest\_1} $\Leftarrow$ \textbar{}\textbar{} \code{corl\_xtpl\_helgaker\_2} \textbar{}\textbar{} etc.

Indicates the basis set extrapolation scheme to be applied to the delta correction
to the correlation energy.


\item {} 
\textbf{delta2\_scheme} (\emph{function}) -- 
$\Rightarrow$ \code{highest\_1} $\Leftarrow$ \textbar{}\textbar{} \code{corl\_xtpl\_helgaker\_2} \textbar{}\textbar{} etc.

Indicates the basis set extrapolation scheme to be applied to the second delta correction
to the correlation energy.


\end{itemize}

\end{description}\end{quote}

\textbf{Examples}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf')}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{cbs}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{scf}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{scf\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{cc-pVDZ}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2')}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{cbs}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp2}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{corl\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{jun-cc-pVDZ}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [3] DTQ-zeta extrapolated scf reference energy}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{cbs}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{scf}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{scf\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{cc-pV[DTQ]Z}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{scf\PYGZus{}scheme}\PYG{o}{=}\PYG{n}{scf\PYGZus{}xtpl\PYGZus{}helgaker\PYGZus{}3}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{cbs}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp2}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{corl\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{cc-pv[dt]z}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{corl\PYGZus{}scheme}\PYG{o}{=}\PYG{n}{corl\PYGZus{}xtpl\PYGZus{}helgaker\PYGZus{}2}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{cbs}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp2}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{corl\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{aug-cc-pv[tq]z}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{corl\PYGZus{}scheme}\PYG{o}{=}\PYG{n}{corl\PYGZus{}xtpl\PYGZus{}helgaker\PYGZus{}2}\PYG{p}{,} \PYG{n}{delta\PYGZus{}wfn}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{ccsd(t)}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{delta\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{aug-cc-pv[dt]z}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{delta\PYGZus{}scheme}\PYG{o}{=}\PYG{n}{corl\PYGZus{}xtpl\PYGZus{}helgaker\PYGZus{}2}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{cbs}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp2}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{corl\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{aug-cc-pv[tq]z}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{corl\PYGZus{}scheme}\PYG{o}{=}\PYG{n}{corl\PYGZus{}xtpl\PYGZus{}helgaker\PYGZus{}2}\PYG{p}{,} \PYG{n}{delta\PYGZus{}wfn}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{ccsd}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{delta\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{aug-cc-pv[dt]z}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{delta\PYGZus{}scheme}\PYG{o}{=}\PYG{n}{corl\PYGZus{}xtpl\PYGZus{}helgaker\PYGZus{}2}\PYG{p}{,} \PYG{n}{delta2\PYGZus{}wfn}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{ccsd(t)}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{delta2\PYGZus{}wfn\PYGZus{}lesser}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{ccsd}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{delta2\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{aug-cc-pvdz}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [7] cbs() coupled with database()}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{database}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp2}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{BASIC}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{subset}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{h2o}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{nh3}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{,} \PYG{n}{symm}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{on}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{func}\PYG{o}{=}\PYG{n}{cbs}\PYG{p}{,} \PYG{n}{corl\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{cc-pV[tq]z}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{corl\PYGZus{}scheme}\PYG{o}{=}\PYG{n}{corl\PYGZus{}xtpl\PYGZus{}helgaker\PYGZus{}2}\PYG{p}{,} \PYG{n}{delta\PYGZus{}wfn}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{ccsd(t)}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{delta\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{sto-3g}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}



\section{Output}
\label{index:id1}
At the beginning of a cbs() job is printed a listing of the individual
energy calculations which will be performed. The output snippet below is
from the example job {[}2{]} above. It shows first each model chemistry needed
to compute the aggregate model chemistry requested through cbs(). Then,
since, for example, an \code{energy('ccsd(t)')} yields CCSD(T), CCSD, MP2,
and SCF energy values, the wrapper condenses this task list into the second
list of minimum number of calculations which will actually be run.

\begin{Verbatim}[commandchars=\\\{\}]
Naive listing of computations required.
        scf / aug-cc-pvqz              for  SCF TOTAL ENERGY
        mp2 / aug-cc-pvtz              for  MP2 CORRELATION ENERGY
        mp2 / aug-cc-pvqz              for  MP2 CORRELATION ENERGY
    ccsd(t) / aug-cc-pvdz              for  CCSD(T) CORRELATION ENERGY
    ccsd(t) / aug-cc-pvtz              for  CCSD(T) CORRELATION ENERGY
        mp2 / aug-cc-pvdz              for  MP2 CORRELATION ENERGY
        mp2 / aug-cc-pvtz              for  MP2 CORRELATION ENERGY

Enlightened listing of computations required.
        mp2 / aug-cc-pvqz              for  MP2 CORRELATION ENERGY
    ccsd(t) / aug-cc-pvdz              for  CCSD(T) CORRELATION ENERGY
    ccsd(t) / aug-cc-pvtz              for  CCSD(T) CORRELATION ENERGY
\end{Verbatim}

At the end of a cbs() job is printed a summary section like the one below. First,
in the components section, are listed the results for each model chemistry available, whether
required for the cbs job (*) or not. Next, in the stages section, are listed the results for
each extrapolation. The energies of this section must be dotted with the weightings in column Wt
to get the total cbs energy. Finally, in the CBS section, are listed the results for each stage
of the cbs procedure. The stage energies of this section sum outright to the total cbs energy.

\begin{Verbatim}[commandchars=\\\{\}]
==\textgreater{} Components \textless{}==

----------------------------------------------------------------------------------
               Method / Basis            Rqd   Energy [H]   Variable
----------------------------------------------------------------------------------
                  scf / aug-cc-pvqz        *  -1.11916375   SCF TOTAL ENERGY
                  mp2 / aug-cc-pvqz        *  -0.03407997   MP2 CORRELATION ENERGY
                  scf / aug-cc-pvdz           -1.11662884   SCF TOTAL ENERGY
                  mp2 / aug-cc-pvdz        *  -0.02881480   MP2 CORRELATION ENERGY
              ccsd(t) / aug-cc-pvdz        *  -0.03893812   CCSD(T) CORRELATION ENERGY
                 ccsd / aug-cc-pvdz           -0.03893812   CCSD CORRELATION ENERGY
                  scf / aug-cc-pvtz           -1.11881134   SCF TOTAL ENERGY
                  mp2 / aug-cc-pvtz        *  -0.03288936   MP2 CORRELATION ENERGY
              ccsd(t) / aug-cc-pvtz        *  -0.04201004   CCSD(T) CORRELATION ENERGY
                 ccsd / aug-cc-pvtz           -0.04201004   CCSD CORRELATION ENERGY
----------------------------------------------------------------------------------

==\textgreater{} Stages \textless{}==

----------------------------------------------------------------------------------
 Stage         Method / Basis             Wt   Energy [H]   Scheme
----------------------------------------------------------------------------------
   scf            scf / aug-cc-pvqz        1  -1.11916375   highest\_1
  corl            mp2 / aug-cc-pv[tq]z     1  -0.03494879   corl\_xtpl\_helgaker\_2
 delta        ccsd(t) / aug-cc-pv[dt]z     1  -0.04330347   corl\_xtpl\_helgaker\_2
 delta            mp2 / aug-cc-pv[dt]z    -1  -0.03460497   corl\_xtpl\_helgaker\_2
----------------------------------------------------------------------------------

==\textgreater{} CBS \textless{}==

----------------------------------------------------------------------------------
 Stage         Method / Basis                  Energy [H]   Scheme
----------------------------------------------------------------------------------
   scf            scf / aug-cc-pvqz           -1.11916375   highest\_1
  corl            mp2 / aug-cc-pv[tq]z        -0.03494879   corl\_xtpl\_helgaker\_2
 delta  ccsd(t) - mp2 / aug-cc-pv[dt]z        -0.00869851   corl\_xtpl\_helgaker\_2
 total            CBS                         -1.16281105
----------------------------------------------------------------------------------
\end{Verbatim}


\section{Extrapolation Schemes}
\label{index:extrapolation-schemes}\index{highest\_1() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{index:wrappers.highest_1}\pysiglinewithargsret{\code{wrappers.}\bfcode{highest\_1}}{\emph{**largs}}{}
Scheme for total or correlation energies with a single basis or the highest
zeta-level among an array of bases. Used by {\hyperref[index:wrappers.complete_basis_set]{\code{wrappers.complete\_basis\_set()}}}.
\begin{gather}
\begin{split}E_{total}^X = E_{total}^X\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
\end{fulllineitems}

\index{scf\_xtpl\_helgaker\_2() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{index:wrappers.scf_xtpl_helgaker_2}\pysiglinewithargsret{\code{wrappers.}\bfcode{scf\_xtpl\_helgaker\_2}}{\emph{**largs}}{}
Extrapolation scheme for reference energies with two adjacent zeta-level bases.
Used by {\hyperref[index:wrappers.complete_basis_set]{\code{wrappers.complete\_basis\_set()}}}.
\begin{gather}
\begin{split}E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
\end{fulllineitems}

\index{scf\_xtpl\_helgaker\_3() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{index:wrappers.scf_xtpl_helgaker_3}\pysiglinewithargsret{\code{wrappers.}\bfcode{scf\_xtpl\_helgaker\_3}}{\emph{**largs}}{}
Extrapolation scheme for reference energies with three adjacent zeta-level bases.
Used by {\hyperref[index:wrappers.complete_basis_set]{\code{wrappers.complete\_basis\_set()}}}.
\begin{gather}
\begin{split}E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
\end{fulllineitems}

\index{corl\_xtpl\_helgaker\_2() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{index:wrappers.corl_xtpl_helgaker_2}\pysiglinewithargsret{\code{wrappers.}\bfcode{corl\_xtpl\_helgaker\_2}}{\emph{**largs}}{}
Extrapolation scheme for correlation energies with two adjacent zeta-level bases.
Used by {\hyperref[index:wrappers.complete_basis_set]{\code{wrappers.complete\_basis\_set()}}}.
\begin{gather}
\begin{split}E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
\end{fulllineitems}



\chapter{Fractional Occupation}
\label{index:fractional-occupation}\label{index:module-frac}\index{frac (module)}\index{frac\_nuke() (in module frac)}

\begin{fulllineitems}
\phantomsection\label{index:frac.frac_nuke}\pysiglinewithargsret{\code{frac.}\bfcode{frac\_nuke}}{\emph{mol}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{frac\_traverse() (in module frac)}

\begin{fulllineitems}
\phantomsection\label{index:frac.frac_traverse}\pysiglinewithargsret{\code{frac.}\bfcode{frac\_traverse}}{\emph{mol}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{ip\_fitting() (in module frac)}

\begin{fulllineitems}
\phantomsection\label{index:frac.ip_fitting}\pysiglinewithargsret{\code{frac.}\bfcode{ip\_fitting}}{\emph{mol}, \emph{omega\_l}, \emph{omega\_r}, \emph{**kwargs}}{}
\end{fulllineitems}



\chapter{Beginner Psithon Programming}
\label{index:beginner-psithon-programming}
\begin{notice}{note}{Note:}
No recompile of the PSI program is necessary for changes made to
files in \code{\$PSIDATADIR}, including those described below.
\end{notice}


\section{Defining a Method Alias}
\label{index:defining-a-method-alias}
Since quantum chemical methods in PSI4 are accessed through Python functions, and
most important quantities are available as PSI variables, it is straightforward
to create aliases to commonly run calculations or to define hybrid methods. The
\code{\$PSIDATADIR/python/aliases.py} file is intended for editing by the user for
this purpose.

As an example, the MP2.5 method is the average of MP2 and MP3. The latter is
available through the arbitrary order MPn code and returns all lower energies
along with it in PSI variables. The following is basic code that will compute
and return the MP2.5 energy.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{run\PYGZus{}mp2\PYGZus{}5}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}

    \PYG{n}{energy}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp3}\PYG{l+s}{'}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}
    \PYG{n}{e\PYGZus{}scf} \PYG{o}{=} \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{get\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{SCF TOTAL ENERGY}\PYG{l+s}{'}\PYG{p}{)}
    \PYG{n}{ce\PYGZus{}mp2} \PYG{o}{=} \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{get\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{MP2 CORRELATION ENERGY}\PYG{l+s}{'}\PYG{p}{)}
    \PYG{n}{ce\PYGZus{}mp3} \PYG{o}{=} \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{get\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{MP3 CORRELATION ENERGY}\PYG{l+s}{'}\PYG{p}{)}

    \PYG{n}{ce\PYGZus{}mp25} \PYG{o}{=} \PYG{l+m+mf}{0.5} \PYG{o}{*} \PYG{p}{(}\PYG{n}{ce\PYGZus{}mp2} \PYG{o}{+} \PYG{n}{ce\PYGZus{}mp3}\PYG{p}{)}
    \PYG{n}{e\PYGZus{}mp25} \PYG{o}{=} \PYG{n}{e\PYGZus{}scf} \PYG{o}{+} \PYG{n}{ce\PYGZus{}mp25}

    \PYG{k}{print} \PYG{l+s}{"""}\PYG{l+s}{  MP2.5 total energy:                      }\PYG{l+s+si}{\PYGZpc{}16.8f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{e\PYGZus{}mp25}\PYG{p}{)}
    \PYG{k}{print} \PYG{l+s}{"""}\PYG{l+s}{  MP2.5 correlation energy:                }\PYG{l+s+si}{\PYGZpc{}16.8f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{ce\PYGZus{}mp25}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{e\PYGZus{}mp25}
\end{Verbatim}

Compare the above to the method that resides in \code{aliases.py}.
The rationale for the changes is indicated in the comments below.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{run\PYGZus{}mp2\PYGZus{}5}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{lowername} \PYG{o}{=} \PYG{n}{name}\PYG{o}{.}\PYG{n}{lower}\PYG{p}{(}\PYG{p}{)}  \PYG{c}{\PYGZsh{} handy variable with name keyword in lowercase}
    \PYG{n}{kwargs} \PYG{o}{=} \PYG{n}{kwargs\PYGZus{}lower}\PYG{p}{(}\PYG{n}{kwargs}\PYG{p}{)}  \PYG{c}{\PYGZsh{} removes case sensitivity in keyword names}

    \PYG{c}{\PYGZsh{} Run detci calculation and collect conventional quantities}
    \PYG{n}{energy}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp3}\PYG{l+s}{'}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}
    \PYG{n}{e\PYGZus{}scf} \PYG{o}{=} \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{get\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{SCF TOTAL ENERGY}\PYG{l+s}{'}\PYG{p}{)}
    \PYG{n}{ce\PYGZus{}mp2} \PYG{o}{=} \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{get\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{MP2 CORRELATION ENERGY}\PYG{l+s}{'}\PYG{p}{)}
    \PYG{n}{ce\PYGZus{}mp3} \PYG{o}{=} \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{get\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{MP3 CORRELATION ENERGY}\PYG{l+s}{'}\PYG{p}{)}
    \PYG{n}{e\PYGZus{}mp2} \PYG{o}{=} \PYG{n}{e\PYGZus{}scf} \PYG{o}{+} \PYG{n}{ce\PYGZus{}mp2}  \PYG{c}{\PYGZsh{} reform mp2 and mp3 total energies for printing}
    \PYG{n}{e\PYGZus{}mp3} \PYG{o}{=} \PYG{n}{e\PYGZus{}scf} \PYG{o}{+} \PYG{n}{ce\PYGZus{}mp3}

    \PYG{c}{\PYGZsh{} Compute quantities particular to MP2.5}
    \PYG{n}{ce\PYGZus{}mp25} \PYG{o}{=} \PYG{l+m+mf}{0.5} \PYG{o}{*} \PYG{p}{(}\PYG{n}{ce\PYGZus{}mp2} \PYG{o}{+} \PYG{n}{ce\PYGZus{}mp3}\PYG{p}{)}
    \PYG{n}{e\PYGZus{}mp25} \PYG{o}{=} \PYG{n}{e\PYGZus{}scf} \PYG{o}{+} \PYG{n}{ce\PYGZus{}mp25}
    \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{set\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{MP2.5 CORRELATION ENERGY}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{ce\PYGZus{}mp25}\PYG{p}{)}  \PYG{c}{\PYGZsh{} add new method's important results}
    \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{set\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{MP2.5 TOTAL ENERGY}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{e\PYGZus{}mp25}\PYG{p}{)}         \PYG{c}{\PYGZsh{}     to PSI variable repository}
    \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{set\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{CURRENT CORRELATION ENERGY}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{ce\PYGZus{}mp25}\PYG{p}{)}
    \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{set\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{CURRENT ENERGY}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{e\PYGZus{}mp25}\PYG{p}{)}  \PYG{c}{\PYGZsh{} geometry optimizer tracks this variable, permits}
                                                   \PYG{c}{\PYGZsh{}     MP2.5 finite difference optimizations}
    \PYG{c}{\PYGZsh{} build string of title banner and print results}
    \PYG{n}{banners} \PYG{o}{=} \PYG{l+s}{'}\PYG{l+s}{'}
    \PYG{n}{banners} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{"""}\PYG{l+s}{PsiMod.print\PYGZus{}out(}\PYG{l+s}{'}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s}{n}\PYG{l+s}{'}\PYG{l+s}{)}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""}
    \PYG{n}{banners} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{"""}\PYG{l+s}{banner(}\PYG{l+s}{'}\PYG{l+s}{ MP2.5 }\PYG{l+s}{'}\PYG{l+s}{)}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""}
    \PYG{n}{banners} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{"""}\PYG{l+s}{PsiMod.print\PYGZus{}out(}\PYG{l+s}{'}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s}{n}\PYG{l+s}{'}\PYG{l+s}{)}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""}
    \PYG{k}{exec} \PYG{n}{banners}

    \PYG{n}{tables}  \PYG{o}{=} \PYG{l+s}{'}\PYG{l+s}{'}
    \PYG{n}{tables} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{"""}\PYG{l+s}{  SCF total energy:                        }\PYG{l+s+si}{\PYGZpc{}16.8f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{e\PYGZus{}scf}\PYG{p}{)}
    \PYG{n}{tables} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{"""}\PYG{l+s}{  MP2 total energy:                        }\PYG{l+s+si}{\PYGZpc{}16.8f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{e\PYGZus{}mp2}\PYG{p}{)}
    \PYG{n}{tables} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{"""}\PYG{l+s}{  MP2.5 total energy:                      }\PYG{l+s+si}{\PYGZpc{}16.8f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{e\PYGZus{}mp25}\PYG{p}{)}
    \PYG{n}{tables} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{"""}\PYG{l+s}{  MP3 total energy:                        }\PYG{l+s+si}{\PYGZpc{}16.8f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{e\PYGZus{}mp3}\PYG{p}{)}
    \PYG{n}{tables} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{"""}\PYG{l+s}{  MP2 correlation energy:                  }\PYG{l+s+si}{\PYGZpc{}16.8f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{ce\PYGZus{}mp2}\PYG{p}{)}
    \PYG{n}{tables} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{"""}\PYG{l+s}{  MP2.5 correlation energy:                }\PYG{l+s+si}{\PYGZpc{}16.8f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{ce\PYGZus{}mp25}\PYG{p}{)}
    \PYG{n}{tables} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{"""}\PYG{l+s}{  MP3 correlation energy:                  }\PYG{l+s+si}{\PYGZpc{}16.8f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{ce\PYGZus{}mp3}\PYG{p}{)}
    \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{print\PYGZus{}out}\PYG{p}{(}\PYG{n}{tables}\PYG{p}{)}  \PYG{c}{\PYGZsh{} prints nice header and table of all involved quantities to output file}

    \PYG{k}{return} \PYG{n}{e\PYGZus{}mp25}
\end{Verbatim}

One final step is necessary. At the end of the \code{aliases.py} file, add
the following line.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{procedures}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{energy}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{mp2.5}\PYG{l+s}{'}\PYG{p}{]} \PYG{o}{=} \PYG{n}{run\PYGZus{}mp2\PYGZus{}5}
\end{Verbatim}

This permits the newly defined MP2.5 method to be called in the input file
with the following command.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{energy}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp2.5}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}


\section{Creating a New Database}
\label{index:creating-a-new-database}
A necessary consideration in constructing a database is the distinction
between reagents and reactions. A reagent is a single molecular system
(may be a dimer) whose geometry you are possession of and whose electronic
energy may be of interest. A reaction is a combination of one or more
reagent energies whose value you are interested in and a reference value
for which you may or may not be in possession of. A few examples follow.
In a database of interaction energies, the reagents are dimers and their
component monomers (usually derived from the dimer geometry), and the
reactions are the dimer less monomers energies. In a database of barrier
heights, the reagents are reactants, products, and transition-state
structures, and the reactions are the transition-states less
minimum-energy structures. Possibly you may have a collection of
structures to simply be acted upon in parallel, in which case the
structures are both the reagents and the reactions. The role of the
database.py file is to collect arrays and dictionaries that define the
geometries of reagents (GEOS), their combination into reactions (RXNM \&
ACTV), available reference values for reactions (BIND), and brief comments
for reagents and reactions (TAGL). The journey from reagent geometries to
functional database.py file is largely automated, in a process described
below.
\begin{itemize}
\item {} \begin{description}
\item[{Prepare geometry files}] \leavevmode
Assemble xyz files for all intended reagent systems in a directory.
Follow the rules below for best results. The filename for each xyz
file should be the name of the system. lowercase or MixedCase is
preferable (according to Sherrill lab convention). Avoid dashes and
dots in the name as python won't allow them. If you're determined to
have dashes and dots, they must be replaced by other characters in the
process\_input line, then translated back in the GEOS section; see
NBC10.py for an example.
\begin{itemize}
\item {} 
The first line for each xyz file should be the number of atoms in the system.

\item {} 
The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).

\item {} 
The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what's the use in cartesian form).  For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step.

\end{itemize}

\end{description}

\item {} 
Run script ixyz2database.pl
\begin{quote}

Move into the directory where all your xyz files are located. Run the
script in place, probably as
\code{\$PSIDATADIR/databases/ixyz2database.pl}. It will ask a number of
questions about your intended database and generate a python file
named for your database. Uppercase is preferable for database names
(according to Sherrill lab convention). Note your choice for the route
variable for the next step.
\end{quote}

\item {} 
Edit file database.py
\begin{itemize}
\item {} 
All routes. Optionally, rearrange the order of reactions in HRXN as this will define the order for the database.

\item {} 
All routes. Optionally, add sources for geometries and any reference data to commented lines above the dbse variable.

\item {} 
All routes. Optionally, the comment lines of TAGL may be edited in plain text.

\item {} 
All routes. Optionally, fill in reference values (in kcal/mol) into BIND.

\item {} 
All routes. Optionally, define alternate sets of reference values in the array BIND\_ALTREF in the database.py file to be called in a psi4 input file as benchmark='ALTREF' . See S22.py as an example.

\item {} 
All routes. Optionally, fill in the least computationally expensive 2-3 reactions into HRXN\_SM and the most expensive into HRXN\_LG

\item {} 
All routes. Optionally, define subsets of reactions in the array SUBSETARRAY = {[}'reaction', `reaction'{]} in the database.py file to be called in a psi4 input file as subset='SUBSETARRAY'. See NBC10.py as an example.

\item {} 
All routes. Necessarily (if charge and multiplicity not read in through line2 = cgmp and nor all neutral singlets), assign correct charge and multiplicity to all reagents.

\item {} 
Route 3. Necessarily (if any charge and multiplicity specified for the whole reagent is not intended for fragmentA with neutral singlet fragmentB), apportion charge and multiplicity properly between fragmentA and fragmentB. This is not likely necessary if all subsystems are neutral singlets.

\item {} 
Route 2. Necessarily, define the reagents that contribute to each reaction by filling in the empty single-quotes in ACTV. Add or delete lines as necessary if for each reaction more or fewer than three reagents contribute. See NHTBH.py as an example.

\item {} 
Route 2. Necessarily, define the mathematical contribution of reagents to reactions by adding a number (most often +1 or -1) for each reagent to the RXNM of each reaction. See NHTBH.py as an example.

\item {} 
All routes. Necessarily, copy your new database into \code{\$PSIDATADIR/databases}.

\end{itemize}

\end{itemize}


\chapter{Function Intercalls}
\label{index:function-intercalls}
For many of the PSI4 Python functions described above, it makes scientific sense that they could be called in combination. For instance, one could optimize all the reagents in a database or compute a counterpoise-corrected interaction energy with an extrapolated method. The table below outlines permitted intercalls between functions, showing that db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This table is not yet validated for calls with cp().
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|L|L|L|L|}
\hline
\textbf{
Caller
} &  \multicolumn{5}{l|}{\textbf{
Callee
}}\\\hline
\textbf{} & \textbf{
cp
} & \textbf{
db
} & \textbf{
opt
} & \textbf{
cbs
} & \textbf{
energy
}\\\hline

cp
 &  & 
---
 & 
Y
 & 
Y
 & 
Y
\\\hline

db
 & 
---
 &  & 
Y
 & 
Y
 & 
Y
\\\hline

opt
 & 
---
 & 
---
 &  & 
Y
 & 
Y
\\\hline

cbs
 & 
---
 & 
---
 & 
---
 &  & 
Y
\\\hline

energy
 & 
---
 & 
---
 & 
---
 & 
---
 & \\\hline
\end{tabulary}

\end{quote}
\begin{itemize}
\item {} 
The command db(opt(cbs(energy()))) is actually expressed as \code{db(..., db\_func=opt, opt\_func=cbs)}. The perhaps expected final argument of \code{cbs\_func=energy} is not necessary since energy() is always the function called by default. Also, the outermost internal function call (\code{db\_func} above can be called as just \code{func}. Several examples of intercalls between Python functions can be found in sample input \emph{pywrap\_all}.

\item {} 
All keyword arguments are passed along to each function traversed in the Python driver, so there should be no concern for separating them, grouping them, or designating them for a particular function when undertaking a nested calculation. Where the same keyword is used by multiple functions, prefixes are added, e.g., \textbf{db\_mode} and \textbf{opt\_mode}.

\item {} 
Function intercalls should not be used in sow/reap mode.

\end{itemize}


\chapter{Embarrassing Parallelism}
\label{index:embarrassing-parallelism}
what functions; no intercalls; no local set; special section in parameter list


\chapter{Psithon Programming Best Practices}
\label{index:psithon-programming-best-practices}\begin{itemize}
\item {} 
Thy python functions shall always have final argument **kwargs, that they may take in and pass on keywords meant for other functions. Yea, even the run\_mcscf(), and run\_ccsd() -type functions that have no use for kwargs. The exceptions are python functions that are only helpers called by a driver function.

\item {} 
Python functions should read the kwargs dictionary and (possibly) add to it. Functions should not pop or remove keywords from kwargs, even those keywords meaningful only to itself. This will ensure that the complete kwargs is available for pickling and sow/reap procedures. The exception is the molecule argument, which is read by the first function that gets ahold of it. This first function activates the molecule and pops it out of kwargs, effectively setting molecule for all subsequent functions. The code below should suffice.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Make sure the molecule the user provided is the active one}
\PYG{k}{if} \PYG{l+s}{'}\PYG{l+s}{molecule}\PYG{l+s}{'} \PYG{o+ow}{in} \PYG{n}{kwargs}\PYG{p}{:}
    \PYG{n}{activate}\PYG{p}{(}\PYG{n}{kwargs}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{molecule}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{del} \PYG{n}{kwargs}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{molecule}\PYG{l+s}{'}\PYG{p}{]}
\PYG{n}{molecule} \PYG{o}{=} \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{get\PYGZus{}active\PYGZus{}molecule}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{molecule}\PYG{o}{.}\PYG{n}{update\PYGZus{}geometry}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\item {} 
Preferrably, the python function signature (for functions intended to be called in input files) is \code{function(name, **kwargs)}. For functions that have other positional keywords, please bundle them into kwargs at earliest convenience (see {\hyperref[index:wrappers.database]{\code{wrappers.database()}}} argument db\_name for example).

\item {} 
After the docstring, the first two lines of your function should be the ones below. The first provides a case insensitive handle to the name argument value. The second converts all the kwargs dictionary keys to lowercase versions of themselves, so that input files can be case insensitive.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{lowername} \PYG{o}{=} \PYG{n}{name}\PYG{o}{.}\PYG{n}{lower}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{kwargs} \PYG{o}{=} \PYG{n}{kwargs\PYGZus{}lower}\PYG{p}{(}\PYG{n}{kwargs}\PYG{p}{)}
\end{Verbatim}

\item {} 
Case sensitivity for kwargs dictionary values still needs to be handled. The first line below shows how to convert argument values to lowercase for matching. When not matching a whole value such that regular expressions are needed, the second line below performs a case insensitive match.

\begin{Verbatim}[commandchars=\\\{\}]
if (kwargs['db\_mode'].lower() == 'continuous'):
if re.match(r'\textasciicircum{}sapt', name, flags=re.IGNORECASE):
\end{Verbatim}

\item {} 
Match boolean keywords (db\_cp in the example below) with expressions like the following, which allow case insensitive yes/true/on/1/no/false/off/0 user input. If your argument's value is a derivative level, similarly, use input.der0th, input.der1st, and input.der2nd.

\begin{Verbatim}[commandchars=\\\{\}]
if input.yes.match(str(db\_cp)):
elif input.no.match(str(db\_cp)):
\end{Verbatim}

\item {} 
For keywords that might be used in other functions as well as your own, prepend the argument name with a short representation of your function name. For example, there are keywords cp\_func, db\_func, and opt\_func to request what python function, if not energy(), is called by cp(), database(), and optimize().

\item {} 
Upon checking in a new python file, edit the file \code{psi4/doc/userman/source/index.rst} and follow the instructions therein that your file may be autodocumented here.

\item {} 
Write docstrings! For a major function intended for use in input files, start with the skeleton docstring in \code{psi4/lib/python/example\_docstring} and replace anything that looks like \code{\textless{}this\textgreater{}}. For a behind-the-scenes function or if you don't want the bother of dealing with \href{http://docutils.sourceforge.net/docs/user/rst/quickref.html}{reStructuredText}, just write an ordinary docstring. It will get slurped into the documentation in plain text.

\item {} 
Your python function should follow \href{http://www.python.org/dev/peps/pep-0008/}{PEP8} conventions (without the line-length restriction). I'm aiming for files to pass the line below, unless for good reason.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{pep8}\PYG{o}{.}\PYG{n}{py} \PYG{o}{-}\PYG{n}{r} \PYG{o}{-}\PYG{o}{-}\PYG{n}{ignore}\PYG{o}{=}\PYG{n}{E501} \PYG{n}{pythonfile}\PYG{o}{.}\PYG{n}{py}
\end{Verbatim}

\item {} 
Your python function should not prevent any test case (\code{make tests}, NOT \code{make longtests}) from passing. A test case(s) should be written and checked in for any major python function, so that others do not break your code. If most of your work was on the python (as opposed to c++) side, the test case prefix pywrap\_ is suggested.

\item {} 
Be sure to set any new PSI variables through lines like those below. Especially if the function returns an energy, set the `current energy' variable. This last is needed to communicate with the optimizer.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{set\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{MP2.5 CORRELATION ENERGY}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{ce\PYGZus{}mp25}\PYG{p}{)}
\PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{set\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{MP2.5 TOTAL ENERGY}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{e\PYGZus{}mp25}\PYG{p}{)}
\PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{set\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{CURRENT ENERGY}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{e\PYGZus{}mp25}\PYG{p}{)}
\end{Verbatim}

\item {} 
Once your python function is fairly stable on its own, it's potential for interoperability with energy()/opt()/cp()/db()/cbs()/etc. should be evaluated. If it makes physical sense that it should work, you should strive to make that interoperability a reality. Some steps:
\begin{itemize}
\item {} 
If any interoperability is possible, define an argument xx\_func, where xx is a short name for your function. Add near the top of your function code like the below (less the final two lines). The net result of this code is that if the user specifies no *\_func arguments, then energy() gets called. If the user defines xx\_func, then its value gets called. If the user defines func, then its value gets reassigned to xx\_func, func itself is deleted, and xx\_func() gets called. Whatever is getting called is stored in func within the function.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Establish function to call}
\PYG{k}{if} \PYG{o+ow}{not}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{xx\PYGZus{}func}\PYG{l+s}{'} \PYG{o+ow}{in} \PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{func}\PYG{l+s}{'} \PYG{o+ow}{in} \PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{kwargs}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{xx\PYGZus{}func}\PYG{l+s}{'}\PYG{p}{]} \PYG{o}{=} \PYG{n}{kwargs}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{func}\PYG{l+s}{'}\PYG{p}{]}
        \PYG{k}{del} \PYG{n}{kwargs}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{func}\PYG{l+s}{'}\PYG{p}{]}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{kwargs}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{xx\PYGZus{}func}\PYG{l+s}{'}\PYG{p}{]} \PYG{o}{=} \PYG{n}{energy}
\PYG{n}{func} \PYG{o}{=} \PYG{n}{kwargs}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{xx\PYGZus{}func}\PYG{l+s}{'}\PYG{p}{]}
\PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{func}\PYG{p}{:}
    \PYG{k}{raise} \PYG{n}{ValidationError}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{Function }\PYG{l+s+se}{\PYGZbs{}'}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+se}{\PYGZbs{}'}\PYG{l+s}{ does not exist to be called by wrapper counterpoise\PYGZus{}correct.}\PYG{l+s}{'} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{func}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{func} \PYG{o+ow}{is} \PYG{n}{db}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{raise} \PYG{n}{ValidationError}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{Wrapper xx is unhappy to be calling function }\PYG{l+s+se}{\PYGZbs{}'}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+se}{\PYGZbs{}'}\PYG{l+s}{.}\PYG{l+s}{'} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{func}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\item {} 
If specific interoperabilities are known, code them in. For example, if xx shouldn't call db, add the last two lines above to the xx function. If db shouldn't call xx, add the following two lines below to the db function.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{p}{(}\PYG{n}{func} \PYG{o+ow}{is} \PYG{n}{xx}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{raise} \PYG{n}{ValidationError}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{Wrapper database is unhappy to be calling function }\PYG{l+s+se}{\PYGZbs{}'}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+se}{\PYGZbs{}'}\PYG{l+s}{.}\PYG{l+s}{'} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{func}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\item {} 
Create a multipart test case that runs some intercalls between your function and others (akin to pywrap\_all). In trials, permute the order of calls a few times to expose any calls that don't clean up after themselves and need further attention.

\item {} 
When all is validated, add your findings to the great interoperability table in the documentation.

\end{itemize}

\end{itemize}


\chapter{PsiMod Methods}
\label{index:psimod-methods}

\chapter{Molecule Methods}
\label{index:molecule-methods}

\chapter{Expert}
\label{index:expert}

\section{aliases}
\label{index:module-aliases}\label{index:aliases}\index{aliases (module)}
Module with functions that call upon those in modules
{\hyperref[index:module-proc]{\code{proc}}}, {\hyperref[index:module-driver]{\code{driver}}}, and {\hyperref[index:module-wrappers]{\code{wrappers}}}.
\begin{description}
\item[{Place in this file quickly defined procedures such as}] \leavevmode\begin{itemize}
\item {} 
aliases for complex methods

\item {} 
simple modifications to existing methods

\end{itemize}

\end{description}
\index{run\_mp2\_5() (in module aliases)}

\begin{fulllineitems}
\phantomsection\label{index:aliases.run_mp2_5}\pysiglinewithargsret{\code{aliases.}\bfcode{run\_mp2\_5}}{\emph{name}, \emph{**kwargs}}{}
Function that computes MP2.5 energy from results of a DETCI
MP3 calculation.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{energy}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp2.5}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{run\_plugin\_ccsd\_serial() (in module aliases)}

\begin{fulllineitems}
\phantomsection\label{index:aliases.run_plugin_ccsd_serial}\pysiglinewithargsret{\code{aliases.}\bfcode{run\_plugin\_ccsd\_serial}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module and plugin calls so that
Eugene DePrince's ccsd\_serial plugin can be called via {\hyperref[index:driver.energy]{\code{driver.energy()}}}.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{energy}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{plugin\PYGZus{}ccsd\PYGZus{}serial}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{run\_plugin\_omega() (in module aliases)}

\begin{fulllineitems}
\phantomsection\label{index:aliases.run_plugin_omega}\pysiglinewithargsret{\code{aliases.}\bfcode{run\_plugin\_omega}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module and plugin calls, as well
as typical options, to access Rob Parrish's omega plugin.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{energy}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{plugin\PYGZus{}omega}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{sherrillgroup\_gold\_standard() (in module aliases)}

\begin{fulllineitems}
\phantomsection\label{index:aliases.sherrillgroup_gold_standard}\pysiglinewithargsret{\code{aliases.}\bfcode{sherrillgroup\_gold\_standard}}{\emph{name='mp2'}, \emph{**kwargs}}{}
Function to call the quantum chemical method known as `Gold Standard'
in the Sherrill group. Uses {\hyperref[index:wrappers.complete_basis_set]{\code{wrappers.complete\_basis\_set()}}} to evaluateo
the following expression. Two-point extrapolation of the correlation energy
performed according to {\hyperref[index:wrappers.corl_xtpl_helgaker_2]{\code{wrappers.corl\_xtpl\_helgaker\_2()}}}.
\begin{gather}
\begin{split}E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{energy}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{sherrillgroup\PYGZus{}gold\PYGZus{}standard}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}



\section{driver}
\label{index:module-driver}\label{index:driver}\index{driver (module)}
Module with a \emph{procedures} dictionary specifying available quantum
chemical methods and functions driving the main quantum chemical
functionality, namely single-point energies, geometry optimizations,
response properties, and vibrational frequency calculations.
\index{gradient() (in module driver)}

\begin{fulllineitems}
\phantomsection\label{index:driver.gradient}\pysiglinewithargsret{\code{driver.}\bfcode{gradient}}{\emph{name}, \emph{**kwargs}}{}
Function complementary to optimize(). Carries out one gradient pass,
deciding analytic or finite difference.

\end{fulllineitems}

\index{hessian() (in module driver)}

\begin{fulllineitems}
\phantomsection\label{index:driver.hessian}\pysiglinewithargsret{\code{driver.}\bfcode{hessian}}{\emph{name}, \emph{**kwargs}}{}
Function to compute force constants. Presently identical to frequency().

\end{fulllineitems}

\index{parse\_arbitrary\_order() (in module driver)}

\begin{fulllineitems}
\phantomsection\label{index:driver.parse_arbitrary_order}\pysiglinewithargsret{\code{driver.}\bfcode{parse\_arbitrary\_order}}{\emph{name}}{}
Function to parse name string into a method family like CI or MRCC and specific
level information like 4 for CISDTQ or MRCCSDTQ.

\end{fulllineitems}



\section{input}
\label{index:input}\label{index:module-input}\index{input (module)}
Module with functions to parse the input file and convert
Psithon into standard Python. Particularly, forms PsiMod
module calls that access the C++ side of Psi4.
\index{bad\_option\_syntax() (in module input)}

\begin{fulllineitems}
\phantomsection\label{index:input.bad_option_syntax}\pysiglinewithargsret{\code{input.}\bfcode{bad\_option\_syntax}}{\emph{line}}{}
Function to report bad syntax to screen and output file.

\end{fulllineitems}

\index{check\_parentheses\_and\_brackets() (in module input)}

\begin{fulllineitems}
\phantomsection\label{index:input.check_parentheses_and_brackets}\pysiglinewithargsret{\code{input.}\bfcode{check\_parentheses\_and\_brackets}}{\emph{input\_string}, \emph{exit\_on\_error}}{}
Function to check that all parenthesis and brackets
in \emph{input\_string} are paired. On that condition, \emph{exit\_on\_error} =1,
otherwise 0.

\end{fulllineitems}

\index{parse\_multiline\_array() (in module input)}

\begin{fulllineitems}
\phantomsection\label{index:input.parse_multiline_array}\pysiglinewithargsret{\code{input.}\bfcode{parse\_multiline\_array}}{\emph{input\_list}}{}
Function to squash multiline arrays into a single line
until all parentheses and brackets are fully paired.

\end{fulllineitems}

\index{process\_basis\_block() (in module input)}

\begin{fulllineitems}
\phantomsection\label{index:input.process_basis_block}\pysiglinewithargsret{\code{input.}\bfcode{process\_basis\_block}}{\emph{matchobj}}{}
Function to process match of \code{basis name \{ ... \}}.

\end{fulllineitems}

\index{process\_basis\_file() (in module input)}

\begin{fulllineitems}
\phantomsection\label{index:input.process_basis_file}\pysiglinewithargsret{\code{input.}\bfcode{process\_basis\_file}}{\emph{matchobj}}{}
Function to process match of \code{basis file ...}.

\end{fulllineitems}

\index{process\_external\_command() (in module input)}

\begin{fulllineitems}
\phantomsection\label{index:input.process_external_command}\pysiglinewithargsret{\code{input.}\bfcode{process\_external\_command}}{\emph{matchobj}}{}
Function to process match of \code{external name? \{ ... \}}.

\end{fulllineitems}

\index{process\_extract\_command() (in module input)}

\begin{fulllineitems}
\phantomsection\label{index:input.process_extract_command}\pysiglinewithargsret{\code{input.}\bfcode{process\_extract\_command}}{\emph{matchobj}}{}
Function to process match of \code{extract\_subsets}.

\end{fulllineitems}

\index{process\_input() (in module input)}

\begin{fulllineitems}
\phantomsection\label{index:input.process_input}\pysiglinewithargsret{\code{input.}\bfcode{process\_input}}{\emph{raw\_input}, \emph{print\_level=1}}{}
Function to preprocess \emph{raw input}, the text of the input file, then
parse it, validate it for format, and convert it into legitimate Python.
\emph{raw\_input} is printed to the output file unless \emph{print\_level} =0. Does
a series of regular expression filters, where the matching portion of the
input is replaced by the output of the corresponding function (in this
module) call. Returns a string concatenating module import lines, a copy
of the user's .psi4rc files, a setting of the scratch directory, a dummy
molecule, and the processed \emph{raw\_input}.

\end{fulllineitems}

\index{process\_memory\_command() (in module input)}

\begin{fulllineitems}
\phantomsection\label{index:input.process_memory_command}\pysiglinewithargsret{\code{input.}\bfcode{process\_memory\_command}}{\emph{matchobj}}{}
Function to process match of \code{memory ...}.

\end{fulllineitems}

\index{process\_molecule\_command() (in module input)}

\begin{fulllineitems}
\phantomsection\label{index:input.process_molecule_command}\pysiglinewithargsret{\code{input.}\bfcode{process\_molecule\_command}}{\emph{matchobj}}{}
Function to process match of \code{molecule name? \{ ... \}}.

\end{fulllineitems}

\index{process\_multiline\_arrays() (in module input)}

\begin{fulllineitems}
\phantomsection\label{index:input.process_multiline_arrays}\pysiglinewithargsret{\code{input.}\bfcode{process\_multiline\_arrays}}{\emph{inputfile}}{}
Function to find array inputs that are spread across multiple
lines and squash them into a single line.

\end{fulllineitems}

\index{process\_option() (in module input)}

\begin{fulllineitems}
\phantomsection\label{index:input.process_option}\pysiglinewithargsret{\code{input.}\bfcode{process\_option}}{\emph{spaces}, \emph{module}, \emph{key}, \emph{value}, \emph{line}}{}
Function to process a line with set or in a set block
into global/local domain and keyword/value.

\end{fulllineitems}

\index{process\_print\_command() (in module input)}

\begin{fulllineitems}
\phantomsection\label{index:input.process_print_command}\pysiglinewithargsret{\code{input.}\bfcode{process\_print\_command}}{\emph{matchobj}}{}
Function to process match of \code{print} and transform
it to \code{PsiMod.print\_out()}.

\end{fulllineitems}

\index{process\_pubchem\_command() (in module input)}

\begin{fulllineitems}
\phantomsection\label{index:input.process_pubchem_command}\pysiglinewithargsret{\code{input.}\bfcode{process\_pubchem\_command}}{\emph{matchobj}}{}
Function to process match of \code{pubchem} in molecule block.

\end{fulllineitems}

\index{process\_set\_command() (in module input)}

\begin{fulllineitems}
\phantomsection\label{index:input.process_set_command}\pysiglinewithargsret{\code{input.}\bfcode{process\_set\_command}}{\emph{matchobj}}{}
Function to process match of all individual \code{set (module\_list)
key \{{[}value\_list{]} or \$value or value\}}.

\end{fulllineitems}

\index{process\_set\_commands() (in module input)}

\begin{fulllineitems}
\phantomsection\label{index:input.process_set_commands}\pysiglinewithargsret{\code{input.}\bfcode{process\_set\_commands}}{\emph{matchobj}}{}
Function to process match of \code{set name? \{ ... \}}.

\end{fulllineitems}

\index{process\_word\_quotes() (in module input)}

\begin{fulllineitems}
\phantomsection\label{index:input.process_word_quotes}\pysiglinewithargsret{\code{input.}\bfcode{process\_word\_quotes}}{\emph{matchobj}}{}
Function to determine if argument needs wrapping in quotes as string.

\end{fulllineitems}

\index{quotify() (in module input)}

\begin{fulllineitems}
\phantomsection\label{index:input.quotify}\pysiglinewithargsret{\code{input.}\bfcode{quotify}}{\emph{string}}{}
Function to wrap anything that looks like a string in quotes
and to remove leading dollar signs from python variables.

\end{fulllineitems}



\section{molutil}
\label{index:module-molutil}\label{index:molutil}\index{molutil (module)}
Module with utility functions that act on molecule objects.
\index{activate() (in module molutil)}

\begin{fulllineitems}
\phantomsection\label{index:molutil.activate}\pysiglinewithargsret{\code{molutil.}\bfcode{activate}}{\emph{mol}}{}
Function to set molecule object \emph{mol} as the current active molecule.

\end{fulllineitems}

\index{dynamic\_variable\_bind() (in module molutil)}

\begin{fulllineitems}
\phantomsection\label{index:molutil.dynamic_variable_bind}\pysiglinewithargsret{\code{molutil.}\bfcode{dynamic\_variable\_bind}}{\emph{cls}}{}
Function to bind PsiMod.Molecule class.

\end{fulllineitems}

\index{extract\_cluster\_indexing() (in module molutil)}

\begin{fulllineitems}
\phantomsection\label{index:molutil.extract_cluster_indexing}\pysiglinewithargsret{\code{molutil.}\bfcode{extract\_cluster\_indexing}}{\emph{mol}, \emph{cluster\_size=0}}{}
Function to returns a LIST of all subclusters of the molecule \emph{mol} of
real size \emph{cluster\_size}. If \emph{cluster\_size} = 0, returns all possible
combinations of cluster size.

\end{fulllineitems}

\index{extract\_clusters() (in module molutil)}

\begin{fulllineitems}
\phantomsection\label{index:molutil.extract_clusters}\pysiglinewithargsret{\code{molutil.}\bfcode{extract\_clusters}}{\emph{mol}, \emph{ghost=True}, \emph{cluster\_size=0}}{}
Function to return all subclusters of the molecule \emph{mol} of
real size \emph{cluster\_size} and all other atoms ghosted if \emph{ghost}
equals true, all other atoms discarded if \emph{ghost} is false. If
\emph{cluster\_size} = 0, returns all possible combinations of cluster size.

\end{fulllineitems}

\index{geometry() (in module molutil)}

\begin{fulllineitems}
\phantomsection\label{index:molutil.geometry}\pysiglinewithargsret{\code{molutil.}\bfcode{geometry}}{\emph{geom}, \emph{name='default'}}{}
Function to create a molecule object of name \emph{name}
from the geometry in string \emph{geom}.

\end{fulllineitems}

\index{new\_get\_attr() (in module molutil)}

\begin{fulllineitems}
\phantomsection\label{index:molutil.new_get_attr}\pysiglinewithargsret{\code{molutil.}\bfcode{new\_get\_attr}}{\emph{self}, \emph{name}}{}
Function to redefine get\_attr method of molecule class.

\end{fulllineitems}

\index{new\_set\_attr() (in module molutil)}

\begin{fulllineitems}
\phantomsection\label{index:molutil.new_set_attr}\pysiglinewithargsret{\code{molutil.}\bfcode{new\_set\_attr}}{\emph{self}, \emph{name}, \emph{value}}{}
Function to redefine set\_attr method of molecule class.

\end{fulllineitems}



\section{physconst}
\label{index:physconst}\label{index:module-physconst}\index{physconst (module)}

\section{proc}
\label{index:proc}\label{index:module-proc}\index{proc (module)}
Module with functions that encode the sequence of PSI module
calls for each of the \emph{name} values of the energy(), optimize(),
response(), and frequency() function.
\index{run\_adc() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_adc}\pysiglinewithargsret{\code{proc.}\bfcode{run\_adc}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
an algebraic diagrammatic construction calculation.

\begin{notice}{caution}{Caution:}
Get rid of active molecule lines- should be handled in energy.
\end{notice}

\end{fulllineitems}

\index{run\_bccd() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_bccd}\pysiglinewithargsret{\code{proc.}\bfcode{run\_bccd}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a Brueckner CCD calculation.

\end{fulllineitems}

\index{run\_bccd\_t() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_bccd_t}\pysiglinewithargsret{\code{proc.}\bfcode{run\_bccd\_t}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a Brueckner CCD(T) calculation.

\end{fulllineitems}

\index{run\_cc\_gradient() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_cc_gradient}\pysiglinewithargsret{\code{proc.}\bfcode{run\_cc\_gradient}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a CCSD and CCSD(T) gradient calculation.

\end{fulllineitems}

\index{run\_cc\_response() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_cc_response}\pysiglinewithargsret{\code{proc.}\bfcode{run\_cc\_response}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a CC2 and CCSD calculation.

\end{fulllineitems}

\index{run\_ccenergy() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_ccenergy}\pysiglinewithargsret{\code{proc.}\bfcode{run\_ccenergy}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a CCSD, CC2, and CC3 calculation.

\end{fulllineitems}

\index{run\_dcft() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_dcft}\pysiglinewithargsret{\code{proc.}\bfcode{run\_dcft}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a density cumulant functional theory calculation.

\end{fulllineitems}

\index{run\_detci() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_detci}\pysiglinewithargsret{\code{proc.}\bfcode{run\_detci}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a configuration interaction calculation, namely FCI,
CIn, MPn, and ZAPTn.

\end{fulllineitems}

\index{run\_dfcc() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_dfcc}\pysiglinewithargsret{\code{proc.}\bfcode{run\_dfcc}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a density-fitted coupled-cluster calculation.

\end{fulllineitems}

\index{run\_dfmp2() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_dfmp2}\pysiglinewithargsret{\code{proc.}\bfcode{run\_dfmp2}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a density-fitted MP2 calculation.

\begin{notice}{caution}{Caution:}
Get rid of madness-era restart file
\end{notice}

\end{fulllineitems}

\index{run\_eom\_cc() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_eom_cc}\pysiglinewithargsret{\code{proc.}\bfcode{run\_eom\_cc}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3.

\end{fulllineitems}

\index{run\_eom\_cc\_gradient() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_eom_cc_gradient}\pysiglinewithargsret{\code{proc.}\bfcode{run\_eom\_cc\_gradient}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
an EOM-CCSD gradient calculation.

\end{fulllineitems}

\index{run\_libfock() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_libfock}\pysiglinewithargsret{\code{proc.}\bfcode{run\_libfock}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a calculation through libfock, namely RCPHF,
RCIS, RTDHF, RTDA, and RTDDFT.

\end{fulllineitems}

\index{run\_mcscf() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_mcscf}\pysiglinewithargsret{\code{proc.}\bfcode{run\_mcscf}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a multiconfigurational self-consistent-field calculation.

\end{fulllineitems}

\index{run\_mp2() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_mp2}\pysiglinewithargsret{\code{proc.}\bfcode{run\_mp2}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a MP2 calculation.

\end{fulllineitems}

\index{run\_mp2\_gradient() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_mp2_gradient}\pysiglinewithargsret{\code{proc.}\bfcode{run\_mp2\_gradient}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a MP2 gradient calculation.

\end{fulllineitems}

\index{run\_mp2c() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_mp2c}\pysiglinewithargsret{\code{proc.}\bfcode{run\_mp2c}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a coupled MP2 calculation.

\end{fulllineitems}

\index{run\_mp2drpa() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_mp2drpa}\pysiglinewithargsret{\code{proc.}\bfcode{run\_mp2drpa}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a MP2-DRPA calculation.

\end{fulllineitems}

\index{run\_mrcc() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_mrcc}\pysiglinewithargsret{\code{proc.}\bfcode{run\_mrcc}}{\emph{name}, \emph{**kwargs}}{}
Function that prepares environment and input files
for a calculation calling Kallay's MRCC code.

\end{fulllineitems}

\index{run\_psimrcc() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_psimrcc}\pysiglinewithargsret{\code{proc.}\bfcode{run\_psimrcc}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for a PSIMRCC computation
using a reference from the MCSCF module

\end{fulllineitems}

\index{run\_psimrcc\_scf() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_psimrcc_scf}\pysiglinewithargsret{\code{proc.}\bfcode{run\_psimrcc\_scf}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for a PSIMRCC computation
using a reference from the SCF module

\end{fulllineitems}

\index{run\_sapt() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_sapt}\pysiglinewithargsret{\code{proc.}\bfcode{run\_sapt}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a SAPT calculation of any level.

\end{fulllineitems}

\index{run\_sapt\_ct() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_sapt_ct}\pysiglinewithargsret{\code{proc.}\bfcode{run\_sapt\_ct}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a charge-transfer SAPT calcuation of any level.

\end{fulllineitems}

\index{run\_scf() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_scf}\pysiglinewithargsret{\code{proc.}\bfcode{run\_scf}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a self-consistent-field theory (HF \& DFT) calculation.

\end{fulllineitems}

\index{run\_scf\_gradient() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_scf_gradient}\pysiglinewithargsret{\code{proc.}\bfcode{run\_scf\_gradient}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a SCF gradient calculation.

\end{fulllineitems}

\index{scf\_helper() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.scf_helper}\pysiglinewithargsret{\code{proc.}\bfcode{scf\_helper}}{\emph{name}, \emph{**kwargs}}{}
Function serving as helper to SCF, choosing whether to cast
up or just run SCF with a standard guess. This preserves
previous SCF options set by other procedures (e.g., SAPT
output file types for SCF).

\end{fulllineitems}



\section{procutil}
\label{index:procutil}\label{index:module-procutil}\index{procutil (module)}
Module with utility functions used by several Python functions.
\index{format\_kwargs\_for\_input() (in module procutil)}

\begin{fulllineitems}
\phantomsection\label{index:procutil.format_kwargs_for_input}\pysiglinewithargsret{\code{procutil.}\bfcode{format\_kwargs\_for\_input}}{\emph{filename}, \emph{lmode=1}, \emph{**kwargs}}{}
Function to pickle to file \emph{filename} the options dictionary
\emph{kwargs}. Mode \emph{lmode} =2 pickles appropriate settings for
reap mode. Used to capture Python options information for
distributed (sow/reap) input files.

\end{fulllineitems}

\index{format\_molecule\_for\_input() (in module procutil)}

\begin{fulllineitems}
\phantomsection\label{index:procutil.format_molecule_for_input}\pysiglinewithargsret{\code{procutil.}\bfcode{format\_molecule\_for\_input}}{\emph{mol}}{}
Function to return a string of the output of
{\hyperref[index:input.process_input]{\code{input.process\_input()}}} applied to the XYZ
format of molecule \emph{mol}. Used to capture molecule
information for distributed (sow/reap) input files.

\end{fulllineitems}

\index{format\_options\_for\_input() (in module procutil)}

\begin{fulllineitems}
\phantomsection\label{index:procutil.format_options_for_input}\pysiglinewithargsret{\code{procutil.}\bfcode{format\_options\_for\_input}}{}{}
Function to return a string of commands to replicate the
current state of user-modified options. Used to capture C++
options information for distributed (sow/reap) input files.

\begin{notice}{caution}{Caution:}
Some features are not yet implemented. Buy a developer a coffee.
\begin{itemize}
\item {} 
Does not cover local (as opposed to global) options.

\item {} 
Does not work with array-type options.

\end{itemize}
\end{notice}

\end{fulllineitems}

\index{get\_psifile() (in module procutil)}

\begin{fulllineitems}
\phantomsection\label{index:procutil.get_psifile}\pysiglinewithargsret{\code{procutil.}\bfcode{get\_psifile}}{\emph{fileno}, \emph{pidspace=`63993'}}{}
Function to return the full path and filename for psi file
\emph{fileno} (e.g., psi.32) in current namespace \emph{pidspace}.

\end{fulllineitems}

\index{kwargs\_lower() (in module procutil)}

\begin{fulllineitems}
\phantomsection\label{index:procutil.kwargs_lower}\pysiglinewithargsret{\code{procutil.}\bfcode{kwargs\_lower}}{\emph{kwargs}}{}
Function to rebuild and return \emph{kwargs} dictionary
with all keys made lowercase. Should be called by every
function that could be called directly by the user.

\end{fulllineitems}



\section{psiexceptions}
\label{index:module-psiexceptions}\label{index:psiexceptions}\index{psiexceptions (module)}
Module with non-generic exceptions classes.
\index{PsiException}

\begin{fulllineitems}
\phantomsection\label{index:psiexceptions.PsiException}\pysigline{\strong{exception }\code{psiexceptions.}\bfcode{PsiException}}
Error class for Psi.

\end{fulllineitems}

\index{ValidationError}

\begin{fulllineitems}
\phantomsection\label{index:psiexceptions.ValidationError}\pysiglinewithargsret{\strong{exception }\code{psiexceptions.}\bfcode{ValidationError}}{\emph{msg}}{}
Error called for problems with the input file. Prints
error message \emph{msg} to standard output stream and output file.

\end{fulllineitems}



\section{pubchem}
\label{index:pubchem}\label{index:module-pubchem}\index{pubchem (module)}
Queries the PubChem database using a compound name (i.e. 1,3,5-hexatriene)
to obtain a molecule string that can be passed to Molecule.

\begin{Verbatim}[commandchars=\\\{\}]
results = getPubChemObj("1,3,5-hexatriene")

Results is an array of results from PubChem matches to your query.
  for entry in results:
     entry["CID"]         =\textgreater{} PubChem compound identifer
     entry["IUPAC"]       =\textgreater{} IUPAC name for the resulting compound
     entry["PubChemObj"]  =\textgreater{} instance of PubChemObj for this compound

     entry["PubChemObj"].getMoleculeString()   =\textgreater{} returns a string compatible
                                                  with PSI4's Molecule creation
\end{Verbatim}
\index{PubChemObj (class in pubchem)}

\begin{fulllineitems}
\phantomsection\label{index:pubchem.PubChemObj}\pysiglinewithargsret{\strong{class }\code{pubchem.}\bfcode{PubChemObj}}{\emph{cid}, \emph{mf}, \emph{iupac}}{}~\index{getCartesian() (pubchem.PubChemObj method)}

\begin{fulllineitems}
\phantomsection\label{index:pubchem.PubChemObj.getCartesian}\pysiglinewithargsret{\bfcode{getCartesian}}{}{}
Function to return a string of the atom symbol and XYZ
coordinates of the PubChem object.

\end{fulllineitems}

\index{getMoleculeString() (pubchem.PubChemObj method)}

\begin{fulllineitems}
\phantomsection\label{index:pubchem.PubChemObj.getMoleculeString}\pysiglinewithargsret{\bfcode{getMoleculeString}}{}{}
Function to obtain a molecule string through
getCartesian() or fail.

\end{fulllineitems}

\index{getSDF() (pubchem.PubChemObj method)}

\begin{fulllineitems}
\phantomsection\label{index:pubchem.PubChemObj.getSDF}\pysiglinewithargsret{\bfcode{getSDF}}{}{}
Function to return the SDF (structure-data file) of the PubChem object.

\end{fulllineitems}

\index{getXYZFile() (pubchem.PubChemObj method)}

\begin{fulllineitems}
\phantomsection\label{index:pubchem.PubChemObj.getXYZFile}\pysiglinewithargsret{\bfcode{getXYZFile}}{}{}
Function to obtain preferentially a molecule string
through getCartesian() or a query string otherwise.

\end{fulllineitems}

\index{name() (pubchem.PubChemObj method)}

\begin{fulllineitems}
\phantomsection\label{index:pubchem.PubChemObj.name}\pysiglinewithargsret{\bfcode{name}}{}{}
Function to return the IUPAC name of the PubChem object.

\end{fulllineitems}


\end{fulllineitems}

\index{getPubChemResults() (in module pubchem)}

\begin{fulllineitems}
\phantomsection\label{index:pubchem.getPubChemResults}\pysiglinewithargsret{\code{pubchem.}\bfcode{getPubChemResults}}{\emph{name}}{}
Function to query the PubChem database for molecules matching the
input string. Builds a PubChem object if found.

\end{fulllineitems}



\section{qmmm}
\label{index:qmmm}\label{index:module-qmmm}\index{qmmm (module)}\index{Diffuse (class in qmmm)}

\begin{fulllineitems}
\phantomsection\label{index:qmmm.Diffuse}\pysiglinewithargsret{\strong{class }\code{qmmm.}\bfcode{Diffuse}}{\emph{molecule}, \emph{basisname}, \emph{ribasisname}}{}~\index{fitGeneral() (qmmm.Diffuse method)}

\begin{fulllineitems}
\phantomsection\label{index:qmmm.Diffuse.fitGeneral}\pysiglinewithargsret{\bfcode{fitGeneral}}{}{}
\end{fulllineitems}

\index{fitScf() (qmmm.Diffuse method)}

\begin{fulllineitems}
\phantomsection\label{index:qmmm.Diffuse.fitScf}\pysiglinewithargsret{\bfcode{fitScf}}{}{}
\end{fulllineitems}

\index{populateExtern() (qmmm.Diffuse method)}

\begin{fulllineitems}
\phantomsection\label{index:qmmm.Diffuse.populateExtern}\pysiglinewithargsret{\bfcode{populateExtern}}{\emph{extern}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{QMMM (class in qmmm)}

\begin{fulllineitems}
\phantomsection\label{index:qmmm.QMMM}\pysigline{\strong{class }\code{qmmm.}\bfcode{QMMM}}~\index{addChargeAngstrom() (qmmm.QMMM method)}

\begin{fulllineitems}
\phantomsection\label{index:qmmm.QMMM.addChargeAngstrom}\pysiglinewithargsret{\bfcode{addChargeAngstrom}}{\emph{Q}, \emph{x}, \emph{y}, \emph{z}}{}
\end{fulllineitems}

\index{addChargeBohr() (qmmm.QMMM method)}

\begin{fulllineitems}
\phantomsection\label{index:qmmm.QMMM.addChargeBohr}\pysiglinewithargsret{\bfcode{addChargeBohr}}{\emph{Q}, \emph{x}, \emph{y}, \emph{z}}{}
\end{fulllineitems}

\index{addDiffuse() (qmmm.QMMM method)}

\begin{fulllineitems}
\phantomsection\label{index:qmmm.QMMM.addDiffuse}\pysiglinewithargsret{\bfcode{addDiffuse}}{\emph{diffuse}}{}
\end{fulllineitems}

\index{populateExtern() (qmmm.QMMM method)}

\begin{fulllineitems}
\phantomsection\label{index:qmmm.QMMM.populateExtern}\pysiglinewithargsret{\bfcode{populateExtern}}{}{}
\end{fulllineitems}


\end{fulllineitems}



\section{text}
\label{index:text}\label{index:module-text}\index{text (module)}
Module with utility classes and functions related
to data tables and text.
\index{Table (class in text)}

\begin{fulllineitems}
\phantomsection\label{index:text.Table}\pysiglinewithargsret{\strong{class }\code{text.}\bfcode{Table}}{\emph{rows=()}, \emph{row\_label\_width=10}, \emph{row\_label\_precision=4}, \emph{cols=()}, \emph{width=16}, \emph{precision=10}}{}
Class defining a flexible Table object for storing data.
\index{absolute\_to\_relative() (text.Table method)}

\begin{fulllineitems}
\phantomsection\label{index:text.Table.absolute_to_relative}\pysiglinewithargsret{\bfcode{absolute\_to\_relative}}{\emph{Factor=627.5095}}{}
Function to shift the data of each column of the Table object
such that the lowest value is zero. A scaling factor of \emph{Factor} is applied.

\end{fulllineitems}

\index{copy() (text.Table method)}

\begin{fulllineitems}
\phantomsection\label{index:text.Table.copy}\pysiglinewithargsret{\bfcode{copy}}{}{}
Function to return a copy of the Table object.

\end{fulllineitems}

\index{format\_label() (text.Table method)}

\begin{fulllineitems}
\phantomsection\label{index:text.Table.format_label}\pysiglinewithargsret{\bfcode{format\_label}}{}{}
Function to pad the width of Table object labels.

\end{fulllineitems}

\index{format\_values() (text.Table method)}

\begin{fulllineitems}
\phantomsection\label{index:text.Table.format_values}\pysiglinewithargsret{\bfcode{format\_values}}{\emph{values}}{}
Function to pad the width of Table object data cells.

\end{fulllineitems}

\index{save() (text.Table method)}

\begin{fulllineitems}
\phantomsection\label{index:text.Table.save}\pysiglinewithargsret{\bfcode{save}}{\emph{file}}{}
Function to save string of the Table object to \emph{file}.

\end{fulllineitems}

\index{scale() (text.Table method)}

\begin{fulllineitems}
\phantomsection\label{index:text.Table.scale}\pysiglinewithargsret{\bfcode{scale}}{\emph{Factor=627.5095}}{}
Function to apply a scaling factor \emph{Factor} to the
data of the Table object.

\end{fulllineitems}


\end{fulllineitems}

\index{banner() (in module text)}

\begin{fulllineitems}
\phantomsection\label{index:text.banner}\pysiglinewithargsret{\code{text.}\bfcode{banner}}{\emph{text}, \emph{type=1}, \emph{width=35}}{}
Function to print \emph{text} to output file in a banner of
minimum width \emph{width} and minimum three-line height for
\emph{type} = 1 or one-line height for \emph{type} = 2.

\end{fulllineitems}

\index{print\_stderr() (in module text)}

\begin{fulllineitems}
\phantomsection\label{index:text.print_stderr}\pysiglinewithargsret{\code{text.}\bfcode{print\_stderr}}{\emph{stuff}}{}
Function to print \emph{stuff} to standard error stream.

\end{fulllineitems}

\index{print\_stdout() (in module text)}

\begin{fulllineitems}
\phantomsection\label{index:text.print_stdout}\pysiglinewithargsret{\code{text.}\bfcode{print\_stdout}}{\emph{stuff}}{}
Function to print \emph{stuff} to standard output stream.

\end{fulllineitems}



\section{util}
\label{index:util}\label{index:module-util}\index{util (module)}
Module with utility functions for use in input files.
\index{compare\_integers() (in module util)}

\begin{fulllineitems}
\phantomsection\label{index:util.compare_integers}\pysiglinewithargsret{\code{util.}\bfcode{compare\_integers}}{\emph{expected}, \emph{computed}, \emph{label}}{}
Function to compare two integers. Prints {\hyperref[index:util.success]{\code{util.success()}}}
when value \emph{computed} matches value \emph{expected}.
Performs a system exit on failure. Used in input files in the test suite.

\end{fulllineitems}

\index{compare\_matrices() (in module util)}

\begin{fulllineitems}
\phantomsection\label{index:util.compare_matrices}\pysiglinewithargsret{\code{util.}\bfcode{compare\_matrices}}{\emph{expected}, \emph{computed}, \emph{digits}, \emph{label}}{}
Function to compare two matrices. Prints {\hyperref[index:util.success]{\code{util.success()}}}
when elements of matrix \emph{computed} match elements of matrix \emph{expected} to
number of \emph{digits}. Performs a system exit on failure to match symmetry
structure, dimensions, or element values. Used in input files in the test suite.

\end{fulllineitems}

\index{compare\_strings() (in module util)}

\begin{fulllineitems}
\phantomsection\label{index:util.compare_strings}\pysiglinewithargsret{\code{util.}\bfcode{compare\_strings}}{\emph{expected}, \emph{computed}, \emph{label}}{}
Function to compare two strings. Prints {\hyperref[index:util.success]{\code{util.success()}}}
when string \emph{computed} exactly matches string \emph{expected}.
Performs a system exit on failure. Used in input files in the test suite.

\end{fulllineitems}

\index{compare\_values() (in module util)}

\begin{fulllineitems}
\phantomsection\label{index:util.compare_values}\pysiglinewithargsret{\code{util.}\bfcode{compare\_values}}{\emph{expected}, \emph{computed}, \emph{digits}, \emph{label}}{}
Function to compare two values. Prints {\hyperref[index:util.success]{\code{util.success()}}}
when value \emph{computed} matches value \emph{expected} to number of \emph{digits}.
Performs a system exit on failure. Used in input files in the test suite.

\end{fulllineitems}

\index{compare\_vectors() (in module util)}

\begin{fulllineitems}
\phantomsection\label{index:util.compare_vectors}\pysiglinewithargsret{\code{util.}\bfcode{compare\_vectors}}{\emph{expected}, \emph{computed}, \emph{digits}, \emph{label}}{}
Function to compare two vectors. Prints {\hyperref[index:util.success]{\code{util.success()}}}
when elements of vector \emph{computed} match elements of vector \emph{expected} to
number of \emph{digits}. Performs a system exit on failure to match symmetry
structure, dimension, or element values. Used in input files in the test suite.

\end{fulllineitems}

\index{get\_memory() (in module util)}

\begin{fulllineitems}
\phantomsection\label{index:util.get_memory}\pysiglinewithargsret{\code{util.}\bfcode{get\_memory}}{}{}
Function to return the total memory allocation.

\end{fulllineitems}

\index{get\_num\_threads() (in module util)}

\begin{fulllineitems}
\phantomsection\label{index:util.get_num_threads}\pysiglinewithargsret{\code{util.}\bfcode{get\_num\_threads}}{}{}
Function to return the number of threads to parallelize across.

\end{fulllineitems}

\index{set\_memory() (in module util)}

\begin{fulllineitems}
\phantomsection\label{index:util.set_memory}\pysiglinewithargsret{\code{util.}\bfcode{set\_memory}}{\emph{bytes}}{}
Function to reset the total memory allocation.

\end{fulllineitems}

\index{set\_num\_threads() (in module util)}

\begin{fulllineitems}
\phantomsection\label{index:util.set_num_threads}\pysiglinewithargsret{\code{util.}\bfcode{set\_num\_threads}}{\emph{nthread}}{}
Function to reset the number of threads to parallelize across.

\end{fulllineitems}

\index{success() (in module util)}

\begin{fulllineitems}
\phantomsection\label{index:util.success}\pysiglinewithargsret{\code{util.}\bfcode{success}}{\emph{label}}{}
Function to print a `\emph{label}...PASSED' line to screen.
Used by {\hyperref[index:util.compare_values]{\code{util.compare\_values()}}} family when functions pass.

\end{fulllineitems}



\section{wrappers}
\label{index:wrappers}\label{index:module-wrappers}\index{wrappers (module)}
Module with functions that call the four main {\hyperref[index:module-driver]{\code{driver}}}
functions: {\hyperref[index:driver.energy]{\code{driver.energy}}}, {\hyperref[index:driver.optimize]{\code{driver.optimize}}},
{\hyperref[index:driver.response]{\code{driver.response}}}, and {\hyperref[index:driver.frequency]{\code{driver.frequency}}}.
\index{call\_function\_in\_1st\_argument() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{index:wrappers.call_function_in_1st_argument}\pysiglinewithargsret{\code{wrappers.}\bfcode{call\_function\_in\_1st\_argument}}{\emph{funcarg}, \emph{**largs}}{}
Function to make primary function call to energy(), opt(), etc.
with options dictionary \emph{largs}.
Useful when \emph{funcarg} to call is stored in variable.

\end{fulllineitems}

\index{drop\_duplicates() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{index:wrappers.drop_duplicates}\pysiglinewithargsret{\code{wrappers.}\bfcode{drop\_duplicates}}{\emph{seq}}{}
Function that given an array \emph{seq}, returns an array without any duplicate
entries. There is no guarantee of which duplicate entry is dropped.

\end{fulllineitems}

\index{n\_body() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{index:wrappers.n_body}\pysiglinewithargsret{\code{wrappers.}\bfcode{n\_body}}{\emph{name}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{reconstitute\_bracketed\_basis() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{index:wrappers.reconstitute_bracketed_basis}\pysiglinewithargsret{\code{wrappers.}\bfcode{reconstitute\_bracketed\_basis}}{\emph{needarray}}{}
Function to reform a bracketed basis set string from a sequential series
of basis sets (e.g, form `cc-pv{[}q5{]}z' from array {[}cc-pvqz, cc-pv5z{]}). The
basis set array is extracted from the \emph{f\_basis} field of a \emph{NEED} dictionary in
{\hyperref[index:wrappers.complete_basis_set]{\code{wrappers.complete\_basis\_set()}}}. Result is used to print a nicely
formatted basis set string in the results table.

\end{fulllineitems}

\index{split\_menial() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{index:wrappers.split_menial}\pysiglinewithargsret{\code{wrappers.}\bfcode{split\_menial}}{\emph{menial}}{}
Function used by {\hyperref[index:wrappers.complete_basis_set]{\code{wrappers.complete\_basis\_set()}}} to separate
\emph{menial} `scftot' into {[}scf, tot{]} and `mp2corl' into {[}mp2, corl{]}.

\end{fulllineitems}

\index{tblhead() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{index:wrappers.tblhead}\pysiglinewithargsret{\code{wrappers.}\bfcode{tblhead}}{\emph{tbl\_maxrgt}, \emph{tbl\_delimit}, \emph{ttype}}{}
Function that prints the header for the changable-width results tables in db().
\emph{tbl\_maxrgt} is the number of reagent columns the table must plan for. \emph{tbl\_delimit}
is a string of dashes of the correct length to set off the table. \emph{ttype} is 1 for
tables comparing the computed values to the reference or 2 for simple tabulation
and sum of the computed values.

\end{fulllineitems}

\index{validate\_bracketed\_basis() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{index:wrappers.validate_bracketed_basis}\pysiglinewithargsret{\code{wrappers.}\bfcode{validate\_bracketed\_basis}}{\emph{basisstring}}{}
Function to transform and validate basis sets for cbs(). A basis set with no
paired square brackets is passed through with zeta level 0 (e.g., `6-31+G(d,p)'
is returned as {[}6-31+G(d,p){]} and {[}0{]}). A basis set with square brackets is
checked for sensible sequence and Dunning-ness and returned as separate basis
sets (e.g., `cc-pV{[}Q5{]}Z' is returned as {[}cc-pVQZ, cc-pV5Z{]} and {[}4, 5{]}). Note
that this function has no communication with the basis set library to check
if the basis actually exists. Used by {\hyperref[index:wrappers.complete_basis_set]{\code{wrappers.complete\_basis\_set()}}}.

\end{fulllineitems}

\index{validate\_scheme\_args() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{index:wrappers.validate_scheme_args}\pysiglinewithargsret{\code{wrappers.}\bfcode{validate\_scheme\_args}}{\emph{functionname}, \emph{**largs}}{}
Function called by each extrapolation scheme in {\hyperref[index:wrappers.complete_basis_set]{\code{wrappers.complete\_basis\_set()}}}.
Checks that all the input arguments are present and suitable so that
the scheme function can focus on defining the extrapolation.

\end{fulllineitems}



\chapter{Indices and Tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{a}
\item {\texttt{aliases}}, \pageref{index:module-aliases}
\indexspace
\bigletter{d}
\item {\texttt{driver}}, \pageref{index:module-driver}
\indexspace
\bigletter{f}
\item {\texttt{frac}}, \pageref{index:module-frac}
\indexspace
\bigletter{i}
\item {\texttt{input}}, \pageref{index:module-input}
\indexspace
\bigletter{m}
\item {\texttt{molutil}}, \pageref{index:module-molutil}
\indexspace
\bigletter{p}
\item {\texttt{physconst}}, \pageref{index:module-physconst}
\item {\texttt{proc}}, \pageref{index:module-proc}
\item {\texttt{procutil}}, \pageref{index:module-procutil}
\item {\texttt{psiexceptions}}, \pageref{index:module-psiexceptions}
\item {\texttt{pubchem}}, \pageref{index:module-pubchem}
\indexspace
\bigletter{q}
\item {\texttt{qmmm}}, \pageref{index:module-qmmm}
\indexspace
\bigletter{t}
\item {\texttt{text}}, \pageref{index:module-text}
\indexspace
\bigletter{u}
\item {\texttt{util}}, \pageref{index:module-util}
\indexspace
\bigletter{w}
\item {\texttt{wrappers}}, \pageref{index:module-wrappers}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
