% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{Psithon Documentation}
\date{March 15, 2012}
\release{4.01}
\author{Psi4 Project}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}
\begin{notice}{note}{Note:}
No recompile of the PSI program is necessary for changes made to
files in \code{\$PSIDATADIR}, including those described below.
\end{notice}



Since quantum chemical methods in PSI4 are accessed through Python functions, and
most important quantities are available as PSI variables, it is straightforward
to create aliases to commonly run calculations or to define hybrid methods. The
\code{\$PSIDATADIR/python/aliases.py} file is intended for editing by the user for
this purpose.

As an example, the MP2.5 method is the average of MP2 and MP3. The latter is
available through the arbitrary order MPn code and returns all lower energies
along with it in PSI variables. The following is basic code that will compute
and return the MP2.5 energy.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{run\PYGZus{}mp2\PYGZus{}5}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}

    \PYG{n}{energy}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp3}\PYG{l+s}{'}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}
    \PYG{n}{e\PYGZus{}scf} \PYG{o}{=} \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{get\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{SCF TOTAL ENERGY}\PYG{l+s}{'}\PYG{p}{)}
    \PYG{n}{ce\PYGZus{}mp2} \PYG{o}{=} \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{get\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{MP2 CORRELATION ENERGY}\PYG{l+s}{'}\PYG{p}{)}
    \PYG{n}{ce\PYGZus{}mp3} \PYG{o}{=} \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{get\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{MP3 CORRELATION ENERGY}\PYG{l+s}{'}\PYG{p}{)}

    \PYG{n}{ce\PYGZus{}mp25} \PYG{o}{=} \PYG{l+m+mf}{0.5} \PYG{o}{*} \PYG{p}{(}\PYG{n}{ce\PYGZus{}mp2} \PYG{o}{+} \PYG{n}{ce\PYGZus{}mp3}\PYG{p}{)}
    \PYG{n}{e\PYGZus{}mp25} \PYG{o}{=} \PYG{n}{e\PYGZus{}scf} \PYG{o}{+} \PYG{n}{ce\PYGZus{}mp25}

    \PYG{k}{print} \PYG{l+s}{"""}\PYG{l+s}{  MP2.5 total energy:                      }\PYG{l+s+si}{\PYGZpc{}16.8f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{e\PYGZus{}mp25}\PYG{p}{)}
    \PYG{k}{print} \PYG{l+s}{"""}\PYG{l+s}{  MP2.5 correlation energy:                }\PYG{l+s+si}{\PYGZpc{}16.8f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{ce\PYGZus{}mp25}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{e\PYGZus{}mp25}
\end{Verbatim}

Compare the above to the method that resides in \code{aliases.py}.
The rationale for the changes is indicated in the comments below.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{run\PYGZus{}mp2\PYGZus{}5}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{lowername} \PYG{o}{=} \PYG{n}{name}\PYG{o}{.}\PYG{n}{lower}\PYG{p}{(}\PYG{p}{)}  \PYG{c}{\PYGZsh{} handy variable with name keyword in lowercase}
    \PYG{n}{kwargs} \PYG{o}{=} \PYG{n}{kwargs\PYGZus{}lower}\PYG{p}{(}\PYG{n}{kwargs}\PYG{p}{)}  \PYG{c}{\PYGZsh{} removes case sensitivity in keyword names}

    \PYG{c}{\PYGZsh{} Run detci calculation and collect conventional quantities}
    \PYG{n}{energy}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp3}\PYG{l+s}{'}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}
    \PYG{n}{e\PYGZus{}scf} \PYG{o}{=} \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{get\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{SCF TOTAL ENERGY}\PYG{l+s}{'}\PYG{p}{)}
    \PYG{n}{ce\PYGZus{}mp2} \PYG{o}{=} \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{get\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{MP2 CORRELATION ENERGY}\PYG{l+s}{'}\PYG{p}{)}
    \PYG{n}{ce\PYGZus{}mp3} \PYG{o}{=} \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{get\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{MP3 CORRELATION ENERGY}\PYG{l+s}{'}\PYG{p}{)}
    \PYG{n}{e\PYGZus{}mp2} \PYG{o}{=} \PYG{n}{e\PYGZus{}scf} \PYG{o}{+} \PYG{n}{ce\PYGZus{}mp2}  \PYG{c}{\PYGZsh{} reform mp2 and mp3 total energies for printing}
    \PYG{n}{e\PYGZus{}mp3} \PYG{o}{=} \PYG{n}{e\PYGZus{}scf} \PYG{o}{+} \PYG{n}{ce\PYGZus{}mp3}

    \PYG{c}{\PYGZsh{} Compute quantities particular to MP2.5}
    \PYG{n}{ce\PYGZus{}mp25} \PYG{o}{=} \PYG{l+m+mf}{0.5} \PYG{o}{*} \PYG{p}{(}\PYG{n}{ce\PYGZus{}mp2} \PYG{o}{+} \PYG{n}{ce\PYGZus{}mp3}\PYG{p}{)}
    \PYG{n}{e\PYGZus{}mp25} \PYG{o}{=} \PYG{n}{e\PYGZus{}scf} \PYG{o}{+} \PYG{n}{ce\PYGZus{}mp25}
    \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{set\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{MP2.5 CORRELATION ENERGY}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{ce\PYGZus{}mp25}\PYG{p}{)}  \PYG{c}{\PYGZsh{} add new method's important results}
    \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{set\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{MP2.5 TOTAL ENERGY}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{e\PYGZus{}mp25}\PYG{p}{)}         \PYG{c}{\PYGZsh{}     to PSI variable repository}
    \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{set\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{CURRENT CORRELATION ENERGY}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{ce\PYGZus{}mp25}\PYG{p}{)}
    \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{set\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{CURRENT ENERGY}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{e\PYGZus{}mp25}\PYG{p}{)}  \PYG{c}{\PYGZsh{} geometry optimizer tracks this variable, permits}
                                                   \PYG{c}{\PYGZsh{}     MP2.5 finite difference optimizations}
    \PYG{c}{\PYGZsh{} build string of title banner and print results}
    \PYG{n}{banners} \PYG{o}{=} \PYG{l+s}{'}\PYG{l+s}{'}
    \PYG{n}{banners} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{"""}\PYG{l+s}{PsiMod.print\PYGZus{}out(}\PYG{l+s}{'}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s}{n}\PYG{l+s}{'}\PYG{l+s}{)}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""}
    \PYG{n}{banners} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{"""}\PYG{l+s}{banner(}\PYG{l+s}{'}\PYG{l+s}{ MP2.5 }\PYG{l+s}{'}\PYG{l+s}{)}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""}
    \PYG{n}{banners} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{"""}\PYG{l+s}{PsiMod.print\PYGZus{}out(}\PYG{l+s}{'}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s}{n}\PYG{l+s}{'}\PYG{l+s}{)}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""}
    \PYG{k}{exec} \PYG{n}{banners}

    \PYG{n}{tables}  \PYG{o}{=} \PYG{l+s}{'}\PYG{l+s}{'}
    \PYG{n}{tables} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{"""}\PYG{l+s}{  SCF total energy:                        }\PYG{l+s+si}{\PYGZpc{}16.8f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{e\PYGZus{}scf}\PYG{p}{)}
    \PYG{n}{tables} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{"""}\PYG{l+s}{  MP2 total energy:                        }\PYG{l+s+si}{\PYGZpc{}16.8f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{e\PYGZus{}mp2}\PYG{p}{)}
    \PYG{n}{tables} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{"""}\PYG{l+s}{  MP2.5 total energy:                      }\PYG{l+s+si}{\PYGZpc{}16.8f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{e\PYGZus{}mp25}\PYG{p}{)}
    \PYG{n}{tables} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{"""}\PYG{l+s}{  MP3 total energy:                        }\PYG{l+s+si}{\PYGZpc{}16.8f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{e\PYGZus{}mp3}\PYG{p}{)}
    \PYG{n}{tables} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{"""}\PYG{l+s}{  MP2 correlation energy:                  }\PYG{l+s+si}{\PYGZpc{}16.8f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{ce\PYGZus{}mp2}\PYG{p}{)}
    \PYG{n}{tables} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{"""}\PYG{l+s}{  MP2.5 correlation energy:                }\PYG{l+s+si}{\PYGZpc{}16.8f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{ce\PYGZus{}mp25}\PYG{p}{)}
    \PYG{n}{tables} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{"""}\PYG{l+s}{  MP3 correlation energy:                  }\PYG{l+s+si}{\PYGZpc{}16.8f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{ce\PYGZus{}mp3}\PYG{p}{)}
    \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{print\PYGZus{}out}\PYG{p}{(}\PYG{n}{tables}\PYG{p}{)}  \PYG{c}{\PYGZsh{} prints nice header and table of all involved quantities to output file}

    \PYG{k}{return} \PYG{n}{e\PYGZus{}mp25}
\end{Verbatim}

One final step is necessary. At the end of the \code{aliases.py} file, add
the following line.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{procedures}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{energy}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{mp2.5}\PYG{l+s}{'}\PYG{p}{]} \PYG{o}{=} \PYG{n}{run\PYGZus{}mp2\PYGZus{}5}
\end{Verbatim}

This permits the newly defined MP2.5 method to be called in the input file
with the following command.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{energy}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp2.5}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}


\chapter{Creating a Database}
\label{beginner:defining-a-method-alias}\label{beginner:creating-a-database}\label{beginner::doc}
A necessary consideration in constructing a database is the distinction
between reagents and reactions. A reagent is a single molecular system
(may be a dimer) whose geometry you are possession of and whose electronic
energy may be of interest. A reaction is a combination of one or more
reagent energies whose value you are interested in and a reference value
for which you may or may not be in possession of. A few examples follow.
In a database of interaction energies, the reagents are dimers and their
component monomers (usually derived from the dimer geometry), and the
reactions are the dimer less monomers energies. In a database of barrier
heights, the reagents are reactants, products, and transition-state
structures, and the reactions are the transition-states less
minimum-energy structures. Possibly you may have a collection of
structures to simply be acted upon in parallel, in which case the
structures are both the reagents and the reactions. The role of the
database.py file is to collect arrays and dictionaries that define the
geometries of reagents (GEOS), their combination into reactions (RXNM \&
ACTV), available reference values for reactions (BIND), and brief comments
for reagents and reactions (TAGL). The journey from reagent geometries to
functional database.py file is largely automated, in a process described
below.
\begin{itemize}
\item {} \begin{description}
\item[{Prepare geometry files}] \leavevmode
Assemble xyz files for all intended reagent systems in a directory.
Follow the rules below for best results. The filename for each xyz
file should be the name of the system. lowercase or MixedCase is
preferable (according to Sherrill lab convention). Avoid dashes and
dots in the name as python won't allow them. If you're determined to
have dashes and dots, they must be replaced by other characters in the
process\_input line, then translated back in the GEOS section; see
NBC10.py for an example.
\begin{itemize}
\item {} 
The first line for each xyz file should be the number of atoms in the system.

\item {} 
The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).

\item {} 
The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what's the use in cartesian form).  For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step.

\end{itemize}

\end{description}

\item {} 
Run script ixyz2database.pl
\begin{quote}

Move into the directory where all your xyz files are located. Run the
script in place, probably as
\code{\$PSIDATADIR/databases/ixyz2database.pl}. It will ask a number of
questions about your intended database and generate a python file
named for your database. Uppercase is preferable for database names
(according to Sherrill lab convention). Note your choice for the route
variable for the next step.
\end{quote}

\item {} 
Edit file database.py
\begin{quote}

According to your responses in to questions in the ixyz2database.pl script,
several bullets will be printed of edits you necessarily or optionally
should make. Copy your new database into \code{\$PSIDATADIR/databases}.
\end{quote}

\end{itemize}
\begin{itemize}
\item {} 
Thy python functions shall always have final argument **kwargs, that they may take in and pass on keywords meant for other functions. Yea, even the run\_mcscf(), and run\_ccsd() -type functions that have no use for kwargs. The exceptions are python functions that are only helpers called by a driver function.

\item {} 
Python functions should read the kwargs dictionary and (possibly) add to it. Functions should not pop or remove keywords from kwargs, even those keywords meaningful only to itself. This will ensure that the complete kwargs is available for pickling and sow/reap procedures. The exception is the molecule argument, which is read by the first function that gets ahold of it. This first function activates the molecule and pops it out of kwargs, effectively setting molecule for all subsequent functions. The code below should suffice.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Make sure the molecule the user provided is the active one}
\PYG{k}{if} \PYG{l+s}{'}\PYG{l+s}{molecule}\PYG{l+s}{'} \PYG{o+ow}{in} \PYG{n}{kwargs}\PYG{p}{:}
    \PYG{n}{activate}\PYG{p}{(}\PYG{n}{kwargs}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{molecule}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{del} \PYG{n}{kwargs}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{molecule}\PYG{l+s}{'}\PYG{p}{]}
\PYG{n}{molecule} \PYG{o}{=} \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{get\PYGZus{}active\PYGZus{}molecule}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{molecule}\PYG{o}{.}\PYG{n}{update\PYGZus{}geometry}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\item {} 
Preferrably, the python function signature (for functions intended to be called in input files) is \code{function(name, **kwargs)}. For functions that have other positional keywords, please bundle them into kwargs at earliest convenience (see {\color{red}\bfseries{}{}`Database{}`\_} argument db\_name for example).

\item {} 
After the docstring, the first two lines of your function should be the ones below. The first provides a case insensitive handle to the name argument value. The second converts all the kwargs dictionary keys to lowercase versions of themselves, so that input files can be case insensitive.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{lowername} \PYG{o}{=} \PYG{n}{name}\PYG{o}{.}\PYG{n}{lower}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{kwargs} \PYG{o}{=} \PYG{n}{kwargs\PYGZus{}lower}\PYG{p}{(}\PYG{n}{kwargs}\PYG{p}{)}
\end{Verbatim}

\item {} 
Case sensitivity for kwargs dictionary values still needs to be handled. The first line below shows how to convert argument values to lowercase for matching. When not matching a whole value such that regular expressions are needed, the second line below performs a case insensitive match.

\begin{Verbatim}[commandchars=\\\{\}]
if (kwargs['db\_mode'].lower() == 'continuous'):
if re.match(r'\textasciicircum{}sapt', name, flags=re.IGNORECASE):
\end{Verbatim}

\item {} 
Match boolean keywords (db\_cp in the example below) with expressions like the following, which allow case insensitive yes/true/on/1/no/false/off/0 user input. If your argument's value is a derivative level, similarly, use input.der0th, input.der1st, and input.der2nd.

\begin{Verbatim}[commandchars=\\\{\}]
if input.yes.match(str(db\_cp)):
elif input.no.match(str(db\_cp)):
\end{Verbatim}

\item {} 
For keywords that might be used in other functions as well as your own, prepend the argument name with a short representation of your function name. For example, there are keywords cp\_func, db\_func, and opt\_func to request what python function, if not energy(), is called by cp(), database(), and optimize().

\item {} 
Upon checking in a new python file, edit the file \code{psi4/doc/userman/source/index.rst} and follow the instructions therein that your file may be autodocumented here.

\item {} 
Write docstrings! For a major function intended for use in input files, start with the skeleton docstring in \code{psi4/lib/python/example\_docstring} and replace anything that looks like \code{\textless{}this\textgreater{}}. For a behind-the-scenes function or if you don't want the bother of dealing with \href{http://docutils.sourceforge.net/docs/user/rst/quickref.html}{reStructuredText}, just write an ordinary docstring. It will get slurped into the documentation in plain text.

\item {} 
Your python function should follow \href{http://www.python.org/dev/peps/pep-0008/}{PEP8} conventions (without the line-length restriction). I'm aiming for files to pass the line below, unless for good reason. The second line is for database Python files.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{pep8}\PYG{o}{.}\PYG{n}{py} \PYG{o}{-}\PYG{n}{r} \PYG{o}{-}\PYG{o}{-}\PYG{n}{ignore}\PYG{o}{=}\PYG{n}{E501} \PYG{n}{pythonfile}\PYG{o}{.}\PYG{n}{py}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{pep8}\PYG{o}{.}\PYG{n}{py} \PYG{o}{-}\PYG{n}{r} \PYG{o}{-}\PYG{o}{-}\PYG{n}{ignore}\PYG{o}{=}\PYG{n}{E501}\PYG{p}{,}\PYG{n}{E221}\PYG{p}{,}\PYG{n}{E222}\PYG{p}{,}\PYG{n}{E241}\PYG{p}{,}\PYG{n}{E201}\PYG{p}{,}\PYG{n}{E202} \PYG{n}{databasefile}\PYG{o}{.}\PYG{n}{py}
\end{Verbatim}

\item {} 
Your python function should not prevent any test case (\code{make tests}, NOT \code{make longtests}) from passing. A test case(s) should be written and checked in for any major python function, so that others do not break your code. If most of your work was on the python (as opposed to c++) side, the test case prefix pywrap\_ is suggested.

\item {} 
Be sure to set any new PSI variables through lines like those below. Especially if the function returns an energy, set the `current energy' variable. This last is needed to communicate with the optimizer.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{set\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{MP2.5 CORRELATION ENERGY}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{ce\PYGZus{}mp25}\PYG{p}{)}
\PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{set\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{MP2.5 TOTAL ENERGY}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{e\PYGZus{}mp25}\PYG{p}{)}
\PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{set\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{CURRENT ENERGY}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{e\PYGZus{}mp25}\PYG{p}{)}
\end{Verbatim}

\item {} 
Once your python function is fairly stable on its own, it's potential for interoperability with energy()/opt()/cp()/db()/cbs()/etc. should be evaluated. If it makes physical sense that it should work, you should strive to make that interoperability a reality. Some steps:
\begin{itemize}
\item {} 
If any interoperability is possible, define an argument xx\_func, where xx is a short name for your function. Add near the top of your function code like the below (less the final two lines). The net result of this code is that if the user specifies no *\_func arguments, then energy() gets called. If the user defines xx\_func, then its value gets called. If the user defines func, then its value gets reassigned to xx\_func, func itself is deleted, and xx\_func() gets called. Whatever is getting called is stored in func within the function.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Establish function to call}
\PYG{k}{if} \PYG{o+ow}{not}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{xx\PYGZus{}func}\PYG{l+s}{'} \PYG{o+ow}{in} \PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{func}\PYG{l+s}{'} \PYG{o+ow}{in} \PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{kwargs}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{xx\PYGZus{}func}\PYG{l+s}{'}\PYG{p}{]} \PYG{o}{=} \PYG{n}{kwargs}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{func}\PYG{l+s}{'}\PYG{p}{]}
        \PYG{k}{del} \PYG{n}{kwargs}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{func}\PYG{l+s}{'}\PYG{p}{]}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{kwargs}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{xx\PYGZus{}func}\PYG{l+s}{'}\PYG{p}{]} \PYG{o}{=} \PYG{n}{energy}
\PYG{n}{func} \PYG{o}{=} \PYG{n}{kwargs}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{xx\PYGZus{}func}\PYG{l+s}{'}\PYG{p}{]}
\PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{func}\PYG{p}{:}
    \PYG{k}{raise} \PYG{n}{ValidationError}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{Function }\PYG{l+s+se}{\PYGZbs{}'}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+se}{\PYGZbs{}'}\PYG{l+s}{ does not exist to be called by wrapper counterpoise\PYGZus{}correct.}\PYG{l+s}{'} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{func}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{func} \PYG{o+ow}{is} \PYG{n}{db}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{raise} \PYG{n}{ValidationError}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{Wrapper xx is unhappy to be calling function }\PYG{l+s+se}{\PYGZbs{}'}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+se}{\PYGZbs{}'}\PYG{l+s}{.}\PYG{l+s}{'} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{func}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\item {} 
If specific interoperabilities are known, code them in. For example, if xx shouldn't call db, add the last two lines above to the xx function. If db shouldn't call xx, add the following two lines below to the db function.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{p}{(}\PYG{n}{func} \PYG{o+ow}{is} \PYG{n}{xx}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{raise} \PYG{n}{ValidationError}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{Wrapper database is unhappy to be calling function }\PYG{l+s+se}{\PYGZbs{}'}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+se}{\PYGZbs{}'}\PYG{l+s}{.}\PYG{l+s}{'} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{func}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\item {} 
Create a multipart test case that runs some intercalls between your function and others (akin to pywrap\_all). In trials, permute the order of calls a few times to expose any calls that don't clean up after themselves and need further attention.

\item {} 
When all is validated, add your findings to the great interoperability table in the documentation.

\end{itemize}

\end{itemize}
\index{complete\_basis\_set() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{cbs:wrappers.complete_basis_set}\pysiglinewithargsret{\code{wrappers.}\bfcode{complete\_basis\_set}}{\emph{name}\optional{, \emph{scf\_basis}, \emph{scf\_scheme}, \emph{corl\_wfn}, \emph{corl\_basis}, \emph{corl\_scheme}, \emph{delta\_wfn}, \emph{delta\_wfn\_lesser}, \emph{delta\_basis}, \emph{delta\_scheme}, \emph{delta2\_wfn}, \emph{delta2\_wfn\_lesser}, \emph{delta2\_basis}, \emph{delta2\_scheme}}}{}
Function to define a multistage energy method from combinations of
basis set extrapolations and delta corrections and condense the
components into a minimum number of calculations.
\begin{quote}\begin{description}
\item[{Aliases }] \leavevmode
cbs()

\item[{Returns}] \leavevmode
(\emph{float}) -- Total electronic energy in Hartrees

\item[{Psi variables}] \leavevmode
\end{description}\end{quote}
\index{environment variable!CBSTOTALENERGY}\index{environment variable!CBSREFERENCEENERGY}\index{environment variable!CBSCORRELATIONENERGY}\index{environment variable!CURRENTENERGY}\index{environment variable!CURRENTREFERENCEENERGY}\index{environment variable!CURRENTCORRELATIONENERGY}

\begin{fulllineitems}
\phantomsection\label{cbs:envvar-CBSTOTALENERGY}\pysigline{\bfcode{CBS~TOTAL~ENERGY}}\phantomsection\label{cbs:envvar-CBSREFERENCEENERGY}\pysigline{\bfcode{CBS~REFERENCE~ENERGY}}\phantomsection\label{cbs:envvar-CBSCORRELATIONENERGY}\pysigline{\bfcode{CBS~CORRELATION~ENERGY}}\phantomsection\label{cbs:envvar-CURRENTENERGY}\pysigline{\bfcode{CURRENT~ENERGY}}\phantomsection\label{cbs:envvar-CURRENTREFERENCEENERGY}\pysigline{\bfcode{CURRENT~REFERENCE~ENERGY}}\phantomsection\label{cbs:envvar-CURRENTCORRELATIONENERGY}\pysigline{\bfcode{CURRENT~CORRELATION~ENERGY}}
\end{fulllineitems}


\begin{notice}{caution}{Caution:}
Some features are not yet implemented. Buy a developer a coffee.
\begin{itemize}
\item {} 
Methods beyond basic scf, mp2, ccsd, ccsd(t) not yet hooked in through PSI variables, df-mp2 in particular.

\item {} 
No scheme defaults for given basis zeta number, so scheme must be specified explicitly.

\item {} 
No way to tell function to boost fitting basis size for all calculations.

\item {} 
No way to extrapolate def2 family basis sets

\item {} 
Need to add more extrapolation schemes

\end{itemize}
\end{notice}

As represented in the equation below, a CBS energy method is defined in four
sequential stages (scf, corl, delta, delta2) covering treatment of the
reference total energy, the correlation energy, a delta correction to the
correlation energy, and a second delta correction. Each is activated by its
stage\_wfn keyword and is only allowed if all preceding stages are active.
\begin{gather}
\begin{split}E_{total}^{\text{CBS}} = \mathcal{F}_{\textbf{scf\_scheme}} \left(E_{total,\; \text{SCF}}^{\textbf{scf\_basis}}\right) \; + \mathcal{F}_{\textbf{corl\_scheme}} \left(E_{corl,\; \textbf{corl\_wfn}}^{\textbf{corl\_basis}}\right) \; + \delta_{\textbf{delta\_wfn\_lesser}}^{\textbf{delta\_wfn}} \; + \delta_{\textbf{delta2\_wfn\_lesser}}^{\textbf{delta2\_wfn}}\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
Here, $\mathcal{F}$ is an energy or energy extrapolation scheme, and the following also hold.
\begin{gather}
\begin{split}\delta_{\textbf{delta\_wfn\_lesser}}^{\textbf{delta\_wfn}} \; = \mathcal{F}_{\textbf{delta\_scheme}} \left(E_{corl,\; \textbf{delta\_wfn}}^{\textbf{delta\_basis}}\right) - \mathcal{F}_{\textbf{delta\_scheme}} \left(E_{corl,\; \textbf{delta\_wfn\_lesser}}^{\textbf{delta\_basis}}\right)\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}\begin{gather}
\begin{split}\delta_{\textbf{delta2\_wfn\_lesser}}^{\textbf{delta2\_wfn}} \; = \mathcal{F}_{\textbf{delta2\_scheme}} \left(E_{corl,\; \textbf{delta2\_wfn}}^{\textbf{delta2\_basis}}\right) - \mathcal{F}_{\textbf{delta2\_scheme}} \left(E_{corl,\; \textbf{delta2\_wfn\_lesser}}^{\textbf{delta2\_basis}}\right)\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
A translation of this ungainly equation to example {[}5{]} below is as
follows. In words, this is a double- and triple-zeta 2-point
Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction
appended to a triple- and quadruple-zeta 2-point
Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ
reference energy.
\begin{gather}
\begin{split}E_{total}^{\text{CBS}} = \mathcal{F}_{\text{highest\_1}} \left(E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}}\right) \; + \mathcal{F}_{\text{corl\_xtpl\_helgaker\_2}} \left(E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}}\right) \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}\begin{gather}
\begin{split}\delta_{\text{MP2}}^{\text{CCSD(T)}} \; = \mathcal{F}_{\text{corl\_xtpl\_helgaker\_2}} \left(E_{corl,\; \text{CCSD(T)}}^{\text{aug-cc-pV[DT]Z}}\right) - \mathcal{F}_{\text{corl\_xtpl\_helgaker\_2}} \left(E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[DT]Z}}\right)\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}\begin{itemize}
\item {} \begin{description}
\item[{Energy Methods}] \leavevmode
The presence of a stage\_wfn keyword is the indicator to incorporate
(and check for stage\_basis and stage\_scheme keywords) and compute
that stage in defining the CBS energy.

\end{description}

\end{itemize}
\begin{description}
\item[{The cbs() function requires, at a minimum, \code{name='scf'} and \code{scf\_basis}}] \leavevmode
keywords to be specified for reference-step only jobs and \code{name} and
\code{corl\_basis} keywords for correlated jobs.

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{name} (\emph{string}) -- 
\code{'scf'} \textbar{}\textbar{} \code{'ccsd'} \textbar{}\textbar{} etc.

First argument, usually unlabeled. Indicates the computational method
for the correlation energy, unless only reference step to be performed,
in which case should be \code{'scf'}. Overruled if stage\_wfn keywords supplied.


\item {} 
\textbf{corl\_wfn} (\emph{string}) -- 
\code{'mp2'} \textbar{}\textbar{} \code{'ccsd(t)'} \textbar{}\textbar{} etc.

Indicates the energy method for which the correlation energy is to be
obtained. Can also be specified with \code{name} or as the unlabeled
first argument to the function.


\item {} 
\textbf{delta\_wfn} (\emph{string}) -- 
\code{'ccsd'} \textbar{}\textbar{} \code{'ccsd(t)'} \textbar{}\textbar{} etc.

Indicates the (superior) energy method for which a delta correction
to the correlation energy is to be obtained.


\item {} 
\textbf{delta\_wfn\_lesser} (\emph{string}) -- 
{\color{red}\bfseries{}\textbar{}dl\textbar{}} \code{'mp2'} {\color{red}\bfseries{}\textbar{}dr\textbar{}} \textbar{}\textbar{} \code{'ccsd'} \textbar{}\textbar{} etc.

Indicates the inferior energy method for which a delta correction
to the correlation energy is to be obtained.


\item {} 
\textbf{delta2\_wfn} (\emph{string}) -- 
\code{'ccsd'} \textbar{}\textbar{} \code{'ccsd(t)'} \textbar{}\textbar{} etc.

Indicates the (superior) energy method for which a second delta correction
to the correlation energy is to be obtained.


\item {} 
\textbf{delta2\_wfn\_lesser} (\emph{string}) -- 
{\color{red}\bfseries{}\textbar{}dl\textbar{}} \code{'mp2'} {\color{red}\bfseries{}\textbar{}dr\textbar{}} \textbar{}\textbar{} \code{'ccsd(t)'} \textbar{}\textbar{} etc.

Indicates the inferior energy method for which a second delta correction
to the correlation energy is to be obtained.


\end{itemize}

\end{description}\end{quote}
\begin{itemize}
\item {} \begin{description}
\item[{Basis Sets}] \leavevmode
Currently, the basis set set through \code{set} commands have no influence
on a cbs calculation.

\end{description}

\end{itemize}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{scf\_basis} (\emph{string}) -- 
{\color{red}\bfseries{}\textbar{}dl\textbar{}} \code{corl\_basis} {\color{red}\bfseries{}\textbar{}dr\textbar{}} \textbar{}\textbar{} \code{'cc-pV{[}TQ{]}Z'} \textbar{}\textbar{} \code{'jun-cc-pv{[}tq5{]}z'} \textbar{}\textbar{} \code{'6-31G*'} \textbar{}\textbar{} etc.

Indicates the sequence of basis sets employed for the reference energy.
If any correlation method is specified, \code{scf\_basis} can default
to \code{corl\_basis}.


\item {} 
\textbf{corl\_basis} (\emph{string}) -- 
\code{'cc-pV{[}TQ{]}Z'} \textbar{}\textbar{} \code{'jun-cc-pv{[}tq5{]}z'} \textbar{}\textbar{} \code{'6-31G*'} \textbar{}\textbar{} etc.

Indicates the sequence of basis sets employed for the correlation energy.


\item {} 
\textbf{delta\_basis} (\emph{string}) -- 
\code{'cc-pV{[}TQ{]}Z'} \textbar{}\textbar{} \code{'jun-cc-pv{[}tq5{]}z'} \textbar{}\textbar{} \code{'6-31G*'} \textbar{}\textbar{} etc.

Indicates the sequence of basis sets employed for the delta correction
to the correlation energy.


\item {} 
\textbf{delta2\_basis} (\emph{string}) -- 
\code{'cc-pV{[}TQ{]}Z'} \textbar{}\textbar{} \code{'jun-cc-pv{[}tq5{]}z'} \textbar{}\textbar{} \code{'6-31G*'} \textbar{}\textbar{} etc.

Indicates the sequence of basis sets employed for the second delta correction
to the correlation energy.


\end{itemize}

\end{description}\end{quote}
\begin{itemize}
\item {} \begin{description}
\item[{Schemes}] \leavevmode
Transformations of the energy through basis set extrapolation for each
stage of the CBS definition. A complaint is generated if number of basis
sets in stage\_basis does not exactly satisfy requirements of stage\_scheme.
An exception is the default, \code{'highest\_1'}, which uses the best basis
set available. See {\hyperref[cbs:extrapolation-schemes]{Extrapolation Schemes}} for all available schemes.

\end{description}

\end{itemize}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{scf\_scheme} (\emph{function}) -- 
{\color{red}\bfseries{}\textbar{}dl\textbar{}} \code{highest\_1} {\color{red}\bfseries{}\textbar{}dr\textbar{}} \textbar{}\textbar{} \code{scf\_xtpl\_helgaker\_3} \textbar{}\textbar{} etc.

Indicates the basis set extrapolation scheme to be applied to the reference energy.


\item {} 
\textbf{corl\_scheme} (\emph{function}) -- 
{\color{red}\bfseries{}\textbar{}dl\textbar{}} \code{highest\_1} {\color{red}\bfseries{}\textbar{}dr\textbar{}} \textbar{}\textbar{} \code{corl\_xtpl\_helgaker\_2} \textbar{}\textbar{} etc.

Indicates the basis set extrapolation scheme to be applied to the correlation energy.


\item {} 
\textbf{delta\_scheme} (\emph{function}) -- 
{\color{red}\bfseries{}\textbar{}dl\textbar{}} \code{highest\_1} {\color{red}\bfseries{}\textbar{}dr\textbar{}} \textbar{}\textbar{} \code{corl\_xtpl\_helgaker\_2} \textbar{}\textbar{} etc.

Indicates the basis set extrapolation scheme to be applied to the delta correction
to the correlation energy.


\item {} 
\textbf{delta2\_scheme} (\emph{function}) -- 
{\color{red}\bfseries{}\textbar{}dl\textbar{}} \code{highest\_1} {\color{red}\bfseries{}\textbar{}dr\textbar{}} \textbar{}\textbar{} \code{corl\_xtpl\_helgaker\_2} \textbar{}\textbar{} etc.

Indicates the basis set extrapolation scheme to be applied to the second delta correction
to the correlation energy.


\end{itemize}

\item[{Examples }] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf')}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{cbs}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{scf}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{scf\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{cc-pVDZ}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2')}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{cbs}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp2}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{corl\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{jun-cc-pVDZ}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [3] DTQ-zeta extrapolated scf reference energy}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{cbs}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{scf}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{scf\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{cc-pV[DTQ]Z}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{scf\PYGZus{}scheme}\PYG{o}{=}\PYG{n}{scf\PYGZus{}xtpl\PYGZus{}helgaker\PYGZus{}3}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{cbs}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp2}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{corl\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{cc-pv[dt]z}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{corl\PYGZus{}scheme}\PYG{o}{=}\PYG{n}{corl\PYGZus{}xtpl\PYGZus{}helgaker\PYGZus{}2}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{cbs}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp2}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{corl\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{aug-cc-pv[tq]z}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{corl\PYGZus{}scheme}\PYG{o}{=}\PYG{n}{corl\PYGZus{}xtpl\PYGZus{}helgaker\PYGZus{}2}\PYG{p}{,} \PYG{n}{delta\PYGZus{}wfn}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{ccsd(t)}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{delta\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{aug-cc-pv[dt]z}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{delta\PYGZus{}scheme}\PYG{o}{=}\PYG{n}{corl\PYGZus{}xtpl\PYGZus{}helgaker\PYGZus{}2}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{cbs}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp2}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{corl\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{aug-cc-pv[tq]z}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{corl\PYGZus{}scheme}\PYG{o}{=}\PYG{n}{corl\PYGZus{}xtpl\PYGZus{}helgaker\PYGZus{}2}\PYG{p}{,} \PYG{n}{delta\PYGZus{}wfn}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{ccsd}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{delta\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{aug-cc-pv[dt]z}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{delta\PYGZus{}scheme}\PYG{o}{=}\PYG{n}{corl\PYGZus{}xtpl\PYGZus{}helgaker\PYGZus{}2}\PYG{p}{,} \PYG{n}{delta2\PYGZus{}wfn}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{ccsd(t)}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{delta2\PYGZus{}wfn\PYGZus{}lesser}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{ccsd}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{delta2\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{aug-cc-pvdz}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [7] cbs() coupled with database()}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{database}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp2}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{BASIC}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{subset}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{h2o}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{nh3}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{,} \PYG{n}{symm}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{on}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{func}\PYG{o}{=}\PYG{n}{cbs}\PYG{p}{,} \PYG{n}{corl\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{cc-pV[tq]z}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{corl\PYGZus{}scheme}\PYG{o}{=}\PYG{n}{corl\PYGZus{}xtpl\PYGZus{}helgaker\PYGZus{}2}\PYG{p}{,} \PYG{n}{delta\PYGZus{}wfn}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{ccsd(t)}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{delta\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{sto-3g}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}



\chapter{Output}
\label{cbs:output}\label{cbs::doc}
At the beginning of a cbs() job is printed a listing of the individual
energy calculations which will be performed. The output snippet below is
from the example job {[}2{]} above. It shows first each model chemistry needed
to compute the aggregate model chemistry requested through cbs(). Then,
since, for example, an \code{energy('ccsd(t)')} yields CCSD(T), CCSD, MP2,
and SCF energy values, the wrapper condenses this task list into the second
list of minimum number of calculations which will actually be run.

\begin{Verbatim}[commandchars=\\\{\}]
Naive listing of computations required.
        scf / aug-cc-pvqz              for  SCF TOTAL ENERGY
        mp2 / aug-cc-pvtz              for  MP2 CORRELATION ENERGY
        mp2 / aug-cc-pvqz              for  MP2 CORRELATION ENERGY
    ccsd(t) / aug-cc-pvdz              for  CCSD(T) CORRELATION ENERGY
    ccsd(t) / aug-cc-pvtz              for  CCSD(T) CORRELATION ENERGY
        mp2 / aug-cc-pvdz              for  MP2 CORRELATION ENERGY
        mp2 / aug-cc-pvtz              for  MP2 CORRELATION ENERGY

Enlightened listing of computations required.
        mp2 / aug-cc-pvqz              for  MP2 CORRELATION ENERGY
    ccsd(t) / aug-cc-pvdz              for  CCSD(T) CORRELATION ENERGY
    ccsd(t) / aug-cc-pvtz              for  CCSD(T) CORRELATION ENERGY
\end{Verbatim}

At the end of a cbs() job is printed a summary section like the one below. First,
in the components section, are listed the results for each model chemistry available, whether
required for the cbs job (*) or not. Next, in the stages section, are listed the results for
each extrapolation. The energies of this section must be dotted with the weightings in column Wt
to get the total cbs energy. Finally, in the CBS section, are listed the results for each stage
of the cbs procedure. The stage energies of this section sum outright to the total cbs energy.

\begin{Verbatim}[commandchars=\\\{\}]
==\textgreater{} Components \textless{}==

----------------------------------------------------------------------------------
               Method / Basis            Rqd   Energy [H]   Variable
----------------------------------------------------------------------------------
                  scf / aug-cc-pvqz        *  -1.11916375   SCF TOTAL ENERGY
                  mp2 / aug-cc-pvqz        *  -0.03407997   MP2 CORRELATION ENERGY
                  scf / aug-cc-pvdz           -1.11662884   SCF TOTAL ENERGY
                  mp2 / aug-cc-pvdz        *  -0.02881480   MP2 CORRELATION ENERGY
              ccsd(t) / aug-cc-pvdz        *  -0.03893812   CCSD(T) CORRELATION ENERGY
                 ccsd / aug-cc-pvdz           -0.03893812   CCSD CORRELATION ENERGY
                  scf / aug-cc-pvtz           -1.11881134   SCF TOTAL ENERGY
                  mp2 / aug-cc-pvtz        *  -0.03288936   MP2 CORRELATION ENERGY
              ccsd(t) / aug-cc-pvtz        *  -0.04201004   CCSD(T) CORRELATION ENERGY
                 ccsd / aug-cc-pvtz           -0.04201004   CCSD CORRELATION ENERGY
----------------------------------------------------------------------------------

==\textgreater{} Stages \textless{}==

----------------------------------------------------------------------------------
 Stage         Method / Basis             Wt   Energy [H]   Scheme
----------------------------------------------------------------------------------
   scf            scf / aug-cc-pvqz        1  -1.11916375   highest\_1
  corl            mp2 / aug-cc-pv[tq]z     1  -0.03494879   corl\_xtpl\_helgaker\_2
 delta        ccsd(t) / aug-cc-pv[dt]z     1  -0.04330347   corl\_xtpl\_helgaker\_2
 delta            mp2 / aug-cc-pv[dt]z    -1  -0.03460497   corl\_xtpl\_helgaker\_2
----------------------------------------------------------------------------------

==\textgreater{} CBS \textless{}==

----------------------------------------------------------------------------------
 Stage         Method / Basis                  Energy [H]   Scheme
----------------------------------------------------------------------------------
   scf            scf / aug-cc-pvqz           -1.11916375   highest\_1
  corl            mp2 / aug-cc-pv[tq]z        -0.03494879   corl\_xtpl\_helgaker\_2
 delta  ccsd(t) - mp2 / aug-cc-pv[dt]z        -0.00869851   corl\_xtpl\_helgaker\_2
 total            CBS                         -1.16281105
----------------------------------------------------------------------------------
\end{Verbatim}


\chapter{Extrapolation Schemes}
\label{cbs:extrapolation-schemes}\index{highest\_1() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{cbs:wrappers.highest_1}\pysiglinewithargsret{\code{wrappers.}\bfcode{highest\_1}}{\emph{**largs}}{}
Scheme for total or correlation energies with a single basis or the highest
zeta-level among an array of bases. Used by {\hyperref[cbs:wrappers.complete_basis_set]{\code{wrappers.complete\_basis\_set()}}}.
\begin{gather}
\begin{split}E_{total}^X = E_{total}^X\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
\end{fulllineitems}

\index{scf\_xtpl\_helgaker\_2() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{cbs:wrappers.scf_xtpl_helgaker_2}\pysiglinewithargsret{\code{wrappers.}\bfcode{scf\_xtpl\_helgaker\_2}}{\emph{**largs}}{}
Extrapolation scheme for reference energies with two adjacent zeta-level bases.
Used by {\hyperref[cbs:wrappers.complete_basis_set]{\code{wrappers.complete\_basis\_set()}}}.
\begin{gather}
\begin{split}E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
\end{fulllineitems}

\index{scf\_xtpl\_helgaker\_3() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{cbs:wrappers.scf_xtpl_helgaker_3}\pysiglinewithargsret{\code{wrappers.}\bfcode{scf\_xtpl\_helgaker\_3}}{\emph{**largs}}{}
Extrapolation scheme for reference energies with three adjacent zeta-level bases.
Used by {\hyperref[cbs:wrappers.complete_basis_set]{\code{wrappers.complete\_basis\_set()}}}.
\begin{gather}
\begin{split}E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
\end{fulllineitems}

\index{corl\_xtpl\_helgaker\_2() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{cbs:wrappers.corl_xtpl_helgaker_2}\pysiglinewithargsret{\code{wrappers.}\bfcode{corl\_xtpl\_helgaker\_2}}{\emph{**largs}}{}
Extrapolation scheme for correlation energies with two adjacent zeta-level bases.
Used by {\hyperref[cbs:wrappers.complete_basis_set]{\code{wrappers.complete\_basis\_set()}}}.
\begin{gather}
\begin{split}E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
\end{fulllineitems}

\begin{gather}
\begin{split}E_{total}^{\text{CBS}} = \mathcal{F}_{\textbf{scf\_scheme}} \left(E_{total,\; \text{SCF}}^{\textbf{scf\_basis}}\right) \; + \mathcal{F}_{\textbf{corl\_scheme}} \left(E_{corl,\; \textbf{corl\_wfn}}^{\textbf{corl\_basis}}\right) \; + \delta_{\textbf{delta\_wfn\_lesser}}^{\textbf{delta\_wfn}} \; + \delta_{\textbf{delta2\_wfn\_lesser}}^{\textbf{delta2\_wfn}}\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
Here, $\mathcal{F}$ is an energy or energy extrapolation scheme, and the following also hold.
\begin{gather}
\begin{split}\delta_{\textbf{delta\_wfn\_lesser}}^{\textbf{delta\_wfn}} \; = \mathcal{F}_{\textbf{delta\_scheme}} \left(E_{corl,\; \textbf{delta\_wfn}}^{\textbf{delta\_basis}}\right) - \mathcal{F}_{\textbf{delta\_scheme}} \left(E_{corl,\; \textbf{delta\_wfn\_lesser}}^{\textbf{delta\_basis}}\right)\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}\begin{gather}
\begin{split}\delta_{\textbf{delta2\_wfn\_lesser}}^{\textbf{delta2\_wfn}} \; = \mathcal{F}_{\textbf{delta2\_scheme}} \left(E_{corl,\; \textbf{delta2\_wfn}}^{\textbf{delta2\_basis}}\right) - \mathcal{F}_{\textbf{delta2\_scheme}} \left(E_{corl,\; \textbf{delta2\_wfn\_lesser}}^{\textbf{delta2\_basis}}\right)\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
A translation of this ungainly equation to example {[}5{]} below is as
follows. In words, this is a double- and triple-zeta 2-point
Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction
appended to a triple- and quadruple-zeta 2-point
Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ
reference energy.
\begin{gather}
\begin{split}E_{total}^{\text{CBS}} = \mathcal{F}_{\text{highest\_1}} \left(E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}}\right) \; + \mathcal{F}_{\text{corl\_xtpl\_helgaker\_2}} \left(E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}}\right) \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}\begin{gather}
\begin{split}\delta_{\text{MP2}}^{\text{CCSD(T)}} \; = \mathcal{F}_{\text{corl\_xtpl\_helgaker\_2}} \left(E_{corl,\; \text{CCSD(T)}}^{\text{aug-cc-pV[DT]Z}}\right) - \mathcal{F}_{\text{corl\_xtpl\_helgaker\_2}} \left(E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[DT]Z}}\right)\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}\index{cp() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{cp:wrappers.cp}\pysiglinewithargsret{\code{wrappers.}\bfcode{cp}}{\emph{name}\optional{, \emph{func}, \emph{check\_bsse}}}{}
The cp function computes counterpoise-corrected two-body interaction energies
for complexes composed of arbitrary numbers of monomers.
\begin{quote}\begin{description}
\item[{Aliases }] \leavevmode
counterpoise\_correct(), counterpoise\_correction()

\item[{Returns}] \leavevmode
(\emph{float}) Counterpoise-corrected interaction energy in kcal/mol

\item[{Psi variables}] \leavevmode
\end{description}\end{quote}
\index{environment variable!CP-CORRECTED2-BODYINTERACTIONENERGY}\index{environment variable!UNCP-CORRECTED2-BODYINTERACTIONENERGY}

\begin{fulllineitems}
\phantomsection\label{cp:envvar-CP-CORRECTED2-BODYINTERACTIONENERGY}\pysigline{\bfcode{CP-CORRECTED~2-BODY~INTERACTION~ENERGY}}\phantomsection\label{cp:envvar-UNCP-CORRECTED2-BODYINTERACTIONENERGY}\pysigline{\bfcode{UNCP-CORRECTED~2-BODY~INTERACTION~ENERGY}}
\end{fulllineitems}


\begin{notice}{caution}{Caution:}
Some features are not yet implemented. Buy a developer a coffee.
\begin{itemize}
\item {} 
No values of func besides energy have been tested.

\item {} 
Table print-out needs improving. Add some PSI variables.

\end{itemize}
\end{notice}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{name} (\emph{string}) -- 
\code{'scf'} \textbar{}\textbar{} \code{'ccsd(t)'} \textbar{}\textbar{} etc.

First argument, usually unlabeled. Indicates the computational method
to be applied to the molecule. May be any valid argument to
{\hyperref[cp:driver.energy]{\code{driver.energy()}}}; however, SAPT is not appropriate.


\item {} 
\textbf{func} (\emph{function}) -- 
{\color{red}\bfseries{}\textbar{}dl\textbar{}} \code{energy} {\color{red}\bfseries{}\textbar{}dr\textbar{}} \textbar{}\textbar{} \code{optimize} \textbar{}\textbar{} \code{cbs}

Indicates the type of calculation to be performed on the molecule
and each of its monomers. The default performs a single-point
\code{energy('name')}, while \code{optimize} perfoms a geometry optimization
on each system, and \code{cbs} performs a compound single-point energy.
If a nested series of python functions is intended
(see {\color{red}\bfseries{}{}`Function Intercalls{}`\_}), use keyword \code{cp\_func} instead of \code{func}.


\item {} 
\textbf{check\_bsse} (\emph{bool}) -- 
\code{'on'} \textbar{}\textbar{} {\color{red}\bfseries{}\textbar{}dl\textbar{}} \code{'off'} {\color{red}\bfseries{}\textbar{}dr\textbar{}}

Indicates whether to additionally compute un-counterpoise corrected
monomers and thus obtain an estimate for the basis set superposition error.


\end{itemize}

\item[{Examples }] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [1] counterpoise-corrected mp2 interaction energy}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{cp}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{dfmp2}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{database() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{db:wrappers.database}\pysiglinewithargsret{\code{wrappers.}\bfcode{database}}{\emph{name}, \emph{db\_name}\optional{, \emph{func}, \emph{mode}, \emph{cp}, \emph{rlxd}, \emph{symm}, \emph{zpe}, \emph{benchmark}, \emph{tabulate}, \emph{subset}}}{}
Function to access the molecule objects and reference energies of
popular chemical databases.
\begin{quote}\begin{description}
\item[{Aliases }] \leavevmode
db()

\item[{Returns}] \leavevmode
(\emph{float}) Mean absolute deviation of the database in kcal/mol

\item[{Psi variables}] \leavevmode
\end{description}\end{quote}
\index{environment variable!db\_nameDATABASEMEANSIGNEDDEVIATION}\index{environment variable!db\_nameDATABASEMEANABSOLUTEDEVIATION}\index{environment variable!db\_nameDATABASEROOT-MEAN-SQUAREDEVIATION}

\begin{fulllineitems}
\phantomsection\label{db:envvar-db_nameDATABASEMEANSIGNEDDEVIATION}\pysigline{\bfcode{db\_name~DATABASE~MEAN~SIGNED~DEVIATION}}\phantomsection\label{db:envvar-db_nameDATABASEMEANABSOLUTEDEVIATION}\pysigline{\bfcode{db\_name~DATABASE~MEAN~ABSOLUTE~DEVIATION}}\phantomsection\label{db:envvar-db_nameDATABASEROOT-MEAN-SQUAREDEVIATION}\pysigline{\bfcode{db\_name~DATABASE~ROOT-MEAN-SQUARE~DEVIATION}}
\end{fulllineitems}


\begin{notice}{note}{Note:}
It is very easy to make a database from a collection of xyz files
using the script \code{\$PSIDATADIR/databases/ixyz2database.pl}.
See {\color{red}\bfseries{}{}`Creating a New Database{}`\_} for details.
\end{notice}

\begin{notice}{caution}{Caution:}
Some features are not yet implemented. Buy a developer some coffee.
\begin{itemize}
\item {} 
In sow/reap mode, use only global options (e.g., the local option set by \code{set scf scf\_type df} will not be respected).

\end{itemize}
\end{notice}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{name} (\emph{string}) -- 
\code{'scf'} \textbar{}\textbar{} \code{'sapt0'} \textbar{}\textbar{} \code{'ccsd(t)'} \textbar{}\textbar{} etc.

First argument, usually unlabeled. Indicates the computational method
to be applied to the database. May be any valid argument to
{\hyperref[db:driver.energy]{\code{driver.energy()}}}.


\item {} 
\textbf{db\_name} (\emph{string}) -- 
\code{'BASIC'} \textbar{}\textbar{} \code{'S22'} \textbar{}\textbar{} \code{'HTBH'} \textbar{}\textbar{} etc.

Second argument, usually unlabeled. Indicates the requested database
name, matching the name of a python file in \code{psi4/lib/databases}.
Consult that directory for available databases and literature citations.


\item {} 
\textbf{func} (\emph{function}) -- 
{\color{red}\bfseries{}\textbar{}dl\textbar{}} \code{energy} {\color{red}\bfseries{}\textbar{}dr\textbar{}} \textbar{}\textbar{} \code{optimize} \textbar{}\textbar{} \code{cbs}

Indicates the type of calculation to be performed on each database
member. The default performs a single-point \code{energy('name')}, while
\code{optimize} perfoms a geometry optimization on each reagent, and
\code{cbs} performs a compound single-point energy. If a nested series
of python functions is intended (see {\color{red}\bfseries{}{}`Function Intercalls{}`\_}), use
keyword \code{db\_func} instead of \code{func}.


\item {} 
\textbf{mode} (\emph{string}) -- 
{\color{red}\bfseries{}\textbar{}dl\textbar{}} \code{'continuous'} {\color{red}\bfseries{}\textbar{}dr\textbar{}} \textbar{}\textbar{} \code{'sow'} \textbar{}\textbar{} \code{'reap'}

Indicates whether the calculations required to complete the
database are to be run in one file (\code{'continuous'}) or are to be
farmed out in an embarrassingly parallel fashion
(\code{'sow'}/\code{'reap'}).  For the latter, run an initial job with
\code{'sow'} and follow instructions in its output file.


\item {} 
\textbf{cp} (\emph{bool}) -- 
\code{'on'} \textbar{}\textbar{} {\color{red}\bfseries{}\textbar{}dl\textbar{}} \code{'off'} {\color{red}\bfseries{}\textbar{}dr\textbar{}}

Indicates whether counterpoise correction is employed in computing
interaction energies. Use this option and NOT the {\hyperref[db:wrappers.cp]{\code{wrappers.cp()}}}
function for BSSE correction in database().  Option available
(See {\hyperref[db:available-databases]{Available Databases}}) only for databases of bimolecular complexes.


\item {} 
\textbf{rlxd} (\emph{bool}) -- 
\code{'on'} \textbar{}\textbar{} {\color{red}\bfseries{}\textbar{}dl\textbar{}} \code{'off'} {\color{red}\bfseries{}\textbar{}dr\textbar{}}

Indicates whether correction for deformation energy is
employed in computing interaction energies.  Option available
(See {\hyperref[db:available-databases]{Available Databases}}) only for databases of bimolecular complexes 
with non-frozen monomers, e.g., HBC6.


\item {} 
\textbf{symm} (\emph{bool}) -- 
{\color{red}\bfseries{}\textbar{}dl\textbar{}} \code{'on'} {\color{red}\bfseries{}\textbar{}dr\textbar{}} \textbar{}\textbar{} \code{'off'}

Indicates whether the native symmetry of the database reagents is
employed (\code{'on'}) or whether it is forced to $C_1$ symmetry
(\code{'off'}). Some computational methods (e.g., SAPT) require no
symmetry, and this will be set by database().


\item {} 
\textbf{zpe} (\emph{bool}) -- 
\code{'on'} \textbar{}\textbar{} {\color{red}\bfseries{}\textbar{}dl\textbar{}} \code{'off'} {\color{red}\bfseries{}\textbar{}dr\textbar{}}

Indicates whether zero-point-energy corrections are appended to
single-point energy values. Option valid only for certain
thermochemical databases. Disabled until Hessians ready.


\item {} 
\textbf{benchmark} (\emph{string}) -- 
{\color{red}\bfseries{}\textbar{}dl\textbar{}} \code{'default'} {\color{red}\bfseries{}\textbar{}dr\textbar{}} \textbar{}\textbar{} \code{'S22A'} \textbar{}\textbar{} etc.

Indicates whether a non-default set of reference energies, if
available (See {\hyperref[db:available-databases]{Available Databases}}), are employed for the
calculation of error statistics.


\item {} 
\textbf{tabulate} (\emph{array of strings}) -- 
{\color{red}\bfseries{}\textbar{}dl\textbar{}} \code{{[}{]}} {\color{red}\bfseries{}\textbar{}dr\textbar{}} \textbar{}\textbar{} \code{{[}'scf total energy', 'natom'{]}} \textbar{}\textbar{} etc.

Indicates whether to form tables of variables other than the
primary requested energy.  Available for any PSI variable.


\item {} 
\textbf{subset} (\emph{string or array of strings}) -- 
Indicates a subset of the full database to run. This is a very
flexible option and can be used in three distinct ways, outlined
below. Note that two take a string and the last takes an array.
See {\hyperref[db:available-databases]{Available Databases}} for available values.
\begin{itemize}
\item {} \begin{description}
\item[{\code{'small'} \textbar{}\textbar{} \code{'large'} \textbar{}\textbar{} \code{'equilibrium'}}] \leavevmode
Calls predefined subsets of the requested database, either
\code{'small'}, a few of the smallest database members,
\code{'large'}, the largest of the database members, or
\code{'equilibrium'}, the equilibrium geometries for a database
composed of dissociation curves.

\end{description}

\item {} \begin{description}
\item[{\code{'BzBz\_S'} \textbar{}\textbar{} \code{'FaOOFaON'} \textbar{}\textbar{} \code{'ArNe'} \textbar{}\textbar{} etc.}] \leavevmode
For databases composed of dissociation curves, individual
curves can be called by name. Consult the database python
files for available molecular systems.  The choices for this
keyword are case sensitive and must match the database python file

\end{description}

\item {} \begin{description}
\item[{\code{{[}1,2,5{]}} \textbar{}\textbar{} \code{{[}'1','2','5'{]}} \textbar{}\textbar{} \code{{[}'BzMe-3.5', 'MeMe-5.0'{]}} \textbar{}\textbar{} etc.}] \leavevmode
Specify a list of database members to run. Consult the
database python files for available molecular systems.  The
choices for this keyword are case sensitive and must match the
database python file

\end{description}

\end{itemize}


\end{itemize}

\item[{Examples }] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{db}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{scf}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{RGC10}\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{cast\PYGZus{}up}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{sto-3g}\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{subset}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{HeHe-0.85}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{HeHe-1.0}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{HeHe-1.5}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{,} \PYG{n}{tabulate}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{scf total energy}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{natom}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [2] Counterpoise-corrected interaction energies for three complexes in S22}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{}     Error statistics computed wrt an old benchmark, S22A}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{database}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{dfmp2}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{S22}\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{cp}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{subset}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{l+m+mi}{17}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{,}\PYG{n}{benchmark}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{S22A}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [3] SAPT0 on the neon dimer dissociation curve}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{db}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{sapt0}\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{subset}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{NeNe}\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{cp}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{symm}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{db\PYGZus{}name}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{RGC10}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{db}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp2}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{S22}\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{db\PYGZus{}func}\PYG{o}{=}\PYG{n}{optimize}\PYG{p}{,}\PYG{n}{subset}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{tabulate}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{mp2 total energy}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{current energy}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{database}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{ccsd}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{HTBH}\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{subset}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{small}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{tabulate}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{ccsd total energy}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{mp2 total energy}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}



\chapter{Output}
\label{db:output}\label{db::doc}
At the beginning of a database job is printed a listing of the individual system
calculations which will be performed. The output snippet below is from the example job {[}1{]}
above. It shows each reagent required for the subset of database reactions requested.
Note that this is an un-counterpoise-corrected example, and the wrapper is smart enough
to compute only once the monomer whose energy will be subtracted from each of the three dimers.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{RGC1}\PYG{o}{-}\PYG{n}{HeHe}\PYG{o}{-}\PYG{l+m+mf}{0.85}\PYG{o}{-}\PYG{n}{dimer}
\PYG{n}{RGC1}\PYG{o}{-}\PYG{n}{He}\PYG{o}{-}\PYG{n}{mono}\PYG{o}{-}\PYG{n}{unCP}
\PYG{n}{RGC1}\PYG{o}{-}\PYG{n}{HeHe}\PYG{o}{-}\PYG{l+m+mf}{1.0}\PYG{o}{-}\PYG{n}{dimer}
\PYG{n}{RGC1}\PYG{o}{-}\PYG{n}{HeHe}\PYG{o}{-}\PYG{l+m+mf}{1.5}\PYG{o}{-}\PYG{n}{dimer}
\end{Verbatim}

At the end of the job, the Requested Energy table is printed that gives the total
energies for the requested model chemistry for each reagent and each reaction, as
well as the stoichoimetric weights by which the reagent energies are transfromed
into the reaction energy. In this case, the dimer is +1 and the monomer is -2,
indicating the the interaction energy is computed from dimer less first monomer
less second (identical) monomer. Error statistics are computed with respect to the reference
energies stored in the database. One of these, the mean absolute deviation, is
returned by the wrapper as an ordinary Python variable. (For databases
without a stored reference energy, e.g., BASIC, large and meaningless numbers are
printed for error.) The other two tables tabulate the PSI variables requested
through keyword \code{tabulate}, in this case the total SCF energy and the number
of atoms in each reagent.

\begin{Verbatim}[commandchars=\\\{\}]
==\textgreater{} Scf Total Energy \textless{}==

-----------------------------------------------------------------------------------
         Reaction          Reaction Value              Reagent 1       Reagent 2
                                                        Value Wt        Value Wt
-----------------------------------------------------------------------------------
   RGC1-HeHe-0.85              0.00011520         -5.71020576  1  -2.85516048 -2
    RGC1-HeHe-1.0              0.00000153         -5.71031943  1  -2.85516048 -2
    RGC1-HeHe-1.5             -0.00000000         -5.71032096  1  -2.85516048 -2
-----------------------------------------------------------------------------------

==\textgreater{} Natom \textless{}==

-----------------------------------------------------------------------------------
         Reaction          Reaction Value              Reagent 1       Reagent 2
                                                        Value Wt        Value Wt
-----------------------------------------------------------------------------------
   RGC1-HeHe-0.85              0.00000000          2.00000000  1   1.00000000 -2
    RGC1-HeHe-1.0              0.00000000          2.00000000  1   1.00000000 -2
    RGC1-HeHe-1.5              0.00000000          2.00000000  1   1.00000000 -2
-----------------------------------------------------------------------------------

==\textgreater{} Requested Energy \textless{}==

-----------------------------------------------------------------------------------
         Reaction     Reaction Energy      Error       Reagent 1       Reagent 2
                         Ref     Calc [kcal/mol]          [H] Wt          [H] Wt
-----------------------------------------------------------------------------------
   RGC1-HeHe-0.85     0.0376   0.0723     0.0347  -5.71020576  1  -2.85516048 -2
    RGC1-HeHe-1.0    -0.0219   0.0010     0.0228  -5.71031943  1  -2.85516048 -2
    RGC1-HeHe-1.5    -0.0029  -0.0000     0.0029  -5.71032096  1  -2.85516048 -2
-----------------------------------------------------------------------------------
      Minimal Dev                         0.0029
      Maximal Dev                         0.0347
  Mean Signed Dev                         0.0201
Mean Absolute Dev                         0.0201
          RMS Dev                         0.0240
-----------------------------------------------------------------------------------
\end{Verbatim}


\chapter{Available Databases}
\label{db:available-databases}
Below are documented for particular databases the availibility of the generic
database function options \textbf{cp}, \textbf{rlxd}, \textbf{benchmark}, and the string
options for \textbf{subset}. The full reagent member list, which can also be used
in conjunction with \textbf{subset}, is not included here for consideration of space
and may be found in the database file. The database Python files are very
readable and should be consulted for more particular questions.


\bigskip\hrule{}\bigskip

\phantomsection\label{db:module-ACENES}\index{ACENES (module)}
\textbf{ACENES}

\begin{DUlineblock}{0em}
\item[] Database of Ed and Rob's favorite linear acene dimers.
\item[] Geometries from nowhere special, and reference energies undefined.
\end{DUlineblock}
\begin{itemize}
\item {} 
\textbf{cp}  \code{'off'} \textbar{}\textbar{} \code{'on'}

\item {} 
\textbf{rlxd} \code{'off'}

\item {} 
\textbf{subset}
\begin{itemize}
\item {} 
\code{'small'}

\item {} 
\code{'large'}

\item {} 
\code{'FIRST3'} benzene, napthalene, and anthracene dimers

\item {} 
\code{'FIRST5'} benzene - pentacene dimers

\item {} 
\code{'FIRST10'} benzene - decacene dimers

\end{itemize}

\end{itemize}


\bigskip\hrule{}\bigskip

\phantomsection\label{db:module-BAKERJCC93}\index{BAKERJCC93 (module)}
\textbf{BAKERJCC93}

\begin{DUlineblock}{0em}
\item[] Database of molecules that are challenging to optimize.
\item[] Geometries from Baker J. Comput. Chem. 14 1085 (1993), as reported
in Bakken and Helgaker, J. Chem. Phys. 117, 9160 (2002), with a few
further corrections.
\item[] No reference energies defined.
\end{DUlineblock}
\begin{itemize}
\item {} 
\textbf{cp}  \code{'off'}

\item {} 
\textbf{rlxd} \code{'off'}

\item {} 
\textbf{subset}
\begin{itemize}
\item {} 
\code{'small'}

\item {} 
\code{'large'}

\end{itemize}

\end{itemize}


\bigskip\hrule{}\bigskip

\phantomsection\label{db:module-BASIC}\index{BASIC (module)}
\textbf{BASIC}

\begin{DUlineblock}{0em}
\item[] Database of simple molecules, mostly for testing.
\item[] Geometries from nowhere special, and no reference energies defined.
\end{DUlineblock}
\begin{itemize}
\item {} 
\textbf{cp}  \code{'off'}

\item {} 
\textbf{rlxd} \code{'off'}

\item {} 
\textbf{subset} {[}\code{'h2o'}, \code{'nh3'}, \code{'ch4'}{]}

\end{itemize}


\bigskip\hrule{}\bigskip

\phantomsection\label{db:module-BBI}\index{BBI (module)}
\textbf{BBI}

\begin{DUlineblock}{0em}
\item[] Database (Merz) of protein backbone-backbone interactions.
\item[] Geometries from Kenneth Merz Group, Univ. of Florida.
\item[] Reference interaction energies from Sherrill group, Georgia Tech.
\end{DUlineblock}
\begin{itemize}
\item {} 
\textbf{cp}  \code{'off'} \textbar{}\textbar{} \code{'on'}

\item {} 
\textbf{rlxd} \code{'off'}

\end{itemize}


\bigskip\hrule{}\bigskip

\phantomsection\label{db:module-CFLOW}\index{CFLOW (module)}
\textbf{CFLOW}

\begin{DUlineblock}{0em}
\item[] Database of extended conjugated bimolecular systems.
\item[] Geometries and Reference interaction energies from the following articles:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Polyene geometries from Marshall et al. JCTC 6 3681 (2010).
\item[] Polyene reference interaction energies from Sherrill group by ccsd(t**)-f12b/heavy-aug-cc-pvdz.
\item[] Acene geometries (except benzene) from Sherrill group by df-mp2/cc-pvtz c.2011.
\item[] Benzene geometry from NBC10 database and citations therein.
\item[] Acene reference interaction energies (incl. benzene dimer) from Sherrill group by ccsd(t**)-f12b/aug-cc-pvdz.
\item[] Buckybowl (Pulay-labeled) geometries from Sherrill group by PBE1PBE/6-31G*, following Pulay's instructions in Janowski et al. CPL 512 155 (2011).
\item[] Buckybowl (Pulay-labeled) reference interaction energies from Janowski et al. CPL 512 155 (2011).
\item[] Buckyware (Grimme-labeled) geometries from Grimme PCCP 12 7091 (2010).
\item[] Buckyware (Grimme-labeled) reference interaction energies from Grimme PCCP 12 7091 (2010) by B97-D2/TZVP.
\item[] Collection into CFLOW by Parrish et al. XXX XXX XXXXXX (2012).
\end{DUlineblock}
\end{DUlineblock}
\begin{itemize}
\item {} 
\textbf{cp}  \code{'off'} \textbar{}\textbar{} \code{'on'}

\item {} 
\textbf{rlxd} \code{'off'}

\item {} 
\textbf{subset}
\begin{itemize}
\item {} 
\code{'small'}

\item {} 
\code{'large'}

\item {} 
\code{'equilibrium'}

\item {} 
\code{'Polyenes'} equilibrium for linear polyene dimers for 2 through 16 monomer carbons

\item {} 
\code{'cBzBz'} 5-point dissociation curve for benzene dimer

\item {} 
\code{'c2BzBz'} 5-point dissociation curve for napthalene-benzene complex

\item {} 
\code{'c2Bz2Bz'} 5-point dissociation curve for napthalene dimer

\item {} 
\code{'c3Bz2Bz'} 5-point dissociation curve for anthracene-napthalene complex

\item {} 
\code{'c3Bz3Bz'} 5-point dissociation curve for anthracene dimer

\item {} 
\code{'c4Bz3Bz'} 5-point dissociation curve for tetracene-anthracene complex

\item {} 
\code{'Arenes'} equilibrium for benzene dimer through tetracene-anthracene complex linear arenes

\item {} 
\code{'cArenes'} 5-point curves around benzene dimer through tetracene-anthracene complex linear arenes

\item {} 
\code{'cPulay'} 4-point dissociation curve for bowl-in-bowl corannulene dimer

\item {} 
\code{'Pulay'} Pulay bowl-in-bowl corannulene dimer dissociation curve and extra point

\item {} 
\code{'Grimme60'} Grimme corannulene dimer, C60 @ buckybowl, and C60 @ buckycatcher

\item {} 
\code{'Grimme70'} Grimme C70 @ buckycatcher at three orientations

\item {} 
\code{'Paper'} linear polyene dimers, equilibrium arene complexes, Pulay corannulene dimer curve, and Grimme corannulene dimer and C60 complexes

\item {} 
\code{'cPaper'} linear polyene dimers, arene complex curves, Pulay corannulene dimer curve, and Grimme corannulene dimer and C60 complexes

\end{itemize}

\end{itemize}


\bigskip\hrule{}\bigskip

\phantomsection\label{db:module-CORE}\index{CORE (module)}
\textbf{CORE}

Database of Pulay corannulene structures. Subsumed into CFLOW.
\begin{itemize}
\item {} 
\textbf{cp}  \code{'off'} \textbar{}\textbar{} \code{'on'}

\item {} 
\textbf{rlxd} \code{'off'}

\end{itemize}


\bigskip\hrule{}\bigskip

\phantomsection\label{db:module-G2}\index{G2 (module)}
\textbf{G2}

\begin{DUlineblock}{0em}
\item[] Database of thermodynamic reactions.
\item[] WIP
\end{DUlineblock}
\begin{itemize}
\item {} 
\textbf{cp}  \code{'off'}

\item {} 
\textbf{rlxd} \code{'off'}

\end{itemize}


\bigskip\hrule{}\bigskip

\phantomsection\label{db:module-HBC6}\index{HBC6 (module)}
\textbf{HBC6}

\begin{DUlineblock}{0em}
\item[] Database (Sherrill) of interaction energies for dissociation curves of doubly hydrogen-bonded bimolecular complexes.
\item[] Geometries from Thanthiriwatte et al. JCTC 7 88 (2011).
\item[] Reference interaction energies from Marshall et al. JCP 135 194102 (2011).
\end{DUlineblock}
\begin{itemize}
\item {} 
\textbf{cp}  \code{'off'} \textbar{}\textbar{} \code{'on'}

\item {} 
\textbf{rlxd} \code{'off'} \textbar{}\textbar{} \code{'on'}

\item {} 
\textbf{benchmark}
\begin{itemize}
\item {} 
\code{'HBC60'} Thanthiriwatte et al. JCTC 7 88 (2011).

\item {} 
{\color{red}\bfseries{}\textbar{}dl\textbar{}} \code{'HBC6A'} {\color{red}\bfseries{}\textbar{}dr\textbar{}} Marshall et al. JCP 135 194102 (2011).

\item {} 
\code{'HBC6ARLX'} Sherrill group, unpublished.

\end{itemize}

\item {} 
\textbf{subset}
\begin{itemize}
\item {} 
\code{'small'}

\item {} 
\code{'large'}

\item {} 
\code{'equilibrium'}

\end{itemize}

\end{itemize}


\bigskip\hrule{}\bigskip

\phantomsection\label{db:module-HSG}\index{HSG (module)}
\textbf{HSG}

\begin{DUlineblock}{0em}
\item[] Database (Merz) of interaction energies for bimolecular complexes from protein-indinavir reaction site.
\item[] Geometries from Faver et al. JCTC 7 790 (2011).
\item[] Reference interaction energies from Marshall et al. JCP 135 194102 (2011).
\end{DUlineblock}
\begin{itemize}
\item {} 
\textbf{cp}  \code{'off'} \textbar{}\textbar{} \code{'on'}

\item {} 
\textbf{rlxd} \code{'off'}

\item {} 
\textbf{benchmark}
\begin{itemize}
\item {} 
\code{'HSG0'} Faver et al. JCTC 7 790 (2011).

\item {} 
{\color{red}\bfseries{}\textbar{}dl\textbar{}} \code{'HSGA'} {\color{red}\bfseries{}\textbar{}dr\textbar{}} Marshall et al. JCP 135 194102 (2011).

\end{itemize}

\item {} 
\textbf{subset}
\begin{itemize}
\item {} 
\code{'small'}

\item {} 
\code{'large'}

\end{itemize}

\end{itemize}


\bigskip\hrule{}\bigskip

\phantomsection\label{db:module-HTBH}\index{HTBH (module)}
\textbf{HTBH}

\begin{DUlineblock}{0em}
\item[] Database (Truhlar) of hydrogen-transfer barrier height reactions.
\item[] Geometries from Truhlar and coworkers at site \href{http://t1.chem.umn.edu/misc/database\_group/database\_therm\_bh/raw\_geom.cgi}{http://t1.chem.umn.edu/misc/database\_group/database\_therm\_bh/raw\_geom.cgi} .
\item[] Reference energies from Zhao et al. JPCA, 109 2012-2018 (2005) doi: 10.1021/jp045141s {[}in supporting information{]}.
\end{DUlineblock}
\begin{itemize}
\item {} 
\textbf{cp}  \code{'off'}

\item {} 
\textbf{rlxd} \code{'off'}

\item {} 
\textbf{subset}
\begin{itemize}
\item {} 
\code{'small'}

\item {} 
\code{'large'}

\end{itemize}

\end{itemize}


\bigskip\hrule{}\bigskip

\phantomsection\label{db:module-JSCH}\index{JSCH (module)}
\textbf{JSCH}

\begin{DUlineblock}{0em}
\item[] Database (Hobza) of interaction energies for nucelobase pairs.
\item[] Geometries and reference interaction energies from Jurecka et al. PCCP 8 1985 (2006).
\item[] Corrections implemented from footnote 92 of Burns et al., JCP 134 084107 (2011).
\end{DUlineblock}
\begin{itemize}
\item {} 
\textbf{cp}  \code{'off'} \textbar{}\textbar{} \code{'on'}

\item {} 
\textbf{rlxd} \code{'off'}

\item {} 
\textbf{subset}
\begin{itemize}
\item {} 
\code{'small'}

\item {} 
\code{'large'}

\end{itemize}

\end{itemize}


\bigskip\hrule{}\bigskip

\phantomsection\label{db:module-NBC10}\index{NBC10 (module)}
\textbf{NBC10}

\begin{DUlineblock}{0em}
\item[] Database (Sherrill) of interaction energies for dissociation curves of dispersion-bound bimolecular complexes.
\item[] Geometries and Reference interaction energies from the following articles:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Benzene Dimers from Sherrill et al. JPCA 113 10146 (2009).
\item[] Benzene-Hydrogen Sulfide from Sherrill et al. JPCA 113 10146 (2009).
\item[] Benzene-Methane from Sherrill et al. JPCA 113 10146 (2009).
\item[] Methane Dimer from Takatani et al. PCCP 9 6106 (2007).
\item[] Pyridine Dimers from Hohenstein et al. JPCA 113 878 (2009).
\item[] Collection into NBC10 from Burns et al. JCP 134 084107 (2011).
\item[] Reference from Marshall et al. JCP 135 194102 (2011).
\end{DUlineblock}
\end{DUlineblock}
\begin{itemize}
\item {} 
\textbf{cp}  \code{'off'} \textbar{}\textbar{} \code{'on'}

\item {} 
\textbf{rlxd} \code{'off'}

\item {} 
\textbf{benchmark}
\begin{itemize}
\item {} 
\code{'NBC100'} Burns et al. JCP 134 084107 (2011).

\item {} 
{\color{red}\bfseries{}\textbar{}dl\textbar{}} \code{'NBC10A'} {\color{red}\bfseries{}\textbar{}dr\textbar{}} Marshall et al. JCP 135 194102 (2011).

\end{itemize}

\item {} 
\textbf{subset}
\begin{itemize}
\item {} 
\code{'small'}

\item {} 
\code{'large'}

\item {} 
\code{'equilibrium'}

\item {} 
\code{'BzBz\_S'} dissociation curve for benzene dimer, sandwich

\item {} 
\code{'BzBz\_T'} dissociation curve for benzene dimer, t-shaped

\item {} 
\code{'BzBz\_PD34'} dissociation curve for benzene dimer, parallel displaced by 3.4A

\item {} 
\code{'BzH2S'} dissociation curve for benzene-H2S

\item {} 
\code{'BzMe'} dissociation curve for benzene-methane

\item {} 
\code{'MeMe'} dissociation curve for methane dimer

\item {} 
\code{'PyPy\_S2'} dissociation curve for pyridine dimer, sandwich

\item {} 
\code{'PyPy\_T3'} dissociation curve for pyridine dimer, t-shaped

\item {} 
\code{'BzBz\_PD32'} dissociation curve for benzene dimer, parallel displaced by 3.2A

\item {} 
\code{'BzBz\_PD36'} dissociation curve for benzene dimer, parallel displaced by 3.6A

\end{itemize}

\end{itemize}


\bigskip\hrule{}\bigskip

\phantomsection\label{db:module-NHTBH}\index{NHTBH (module)}
\textbf{NHTBH}

\begin{DUlineblock}{0em}
\item[] Database (Truhlar) of non-hydrogen-transfer barrier height reactions.
\item[] Geometries and Reaction energies from Truhlar and coworkers at site \href{http://t1.chem.umn.edu/misc/database\_group/database\_therm\_bh/non\_H.htm}{http://t1.chem.umn.edu/misc/database\_group/database\_therm\_bh/non\_H.htm}.
\end{DUlineblock}
\begin{itemize}
\item {} 
\textbf{cp}  \code{'off'}

\item {} 
\textbf{rlxd} \code{'off'}

\item {} 
\textbf{subset}
\begin{itemize}
\item {} 
\code{'small'}

\item {} 
\code{'large'}

\end{itemize}

\end{itemize}


\bigskip\hrule{}\bigskip

\phantomsection\label{db:module-RGC10}\index{RGC10 (module)}
\textbf{RGC10}

\begin{DUlineblock}{0em}
\item[] Database (Sherrill) of interaction energies for dissociation curves of rare-gas biatomic complexes.
\item[] Geometries and reference interaction energies from Tang et al. JCP 118 4976 (2003).
\end{DUlineblock}
\begin{itemize}
\item {} 
\textbf{cp}  \code{'off'} \textbar{}\textbar{} \code{'on'}

\item {} 
\textbf{rlxd} \code{'off'}

\item {} 
\textbf{subset}
\begin{itemize}
\item {} 
\code{'small'}

\item {} 
\code{'large'}

\item {} 
\code{'equilibrium'}

\item {} 
\code{'HeHe'} 18-point dissociation curve for helium dimer

\item {} 
\code{'HeNe'} 18-point dissociation curve for helium-neon complex

\item {} 
\code{'HeAr'} 18-point dissociation curve for helium-argon complex

\item {} 
\code{'HeKr'} 18-point dissociation curve for helium-krypton complex

\item {} 
\code{'NeNe'} 18-point dissociation curve for neon dimer

\item {} 
\code{'NeAr'} 18-point dissociation curve for neon-argon complex

\item {} 
\code{'NeKr'} 18-point dissociation curve for neon-krypton complex

\item {} 
\code{'ArAr'} 18-point dissociation curve for argon dimer

\item {} 
\code{'ArKr'} 18-point dissociation curve for argon-krypton complex

\item {} 
\code{'KrKr'} 18-point dissociation curve for krypton dimer

\end{itemize}

\end{itemize}


\bigskip\hrule{}\bigskip

\phantomsection\label{db:module-S22}\index{S22 (module)}
\textbf{S22}

\begin{DUlineblock}{0em}
\item[] Database (Hobza) of interaction energies for bimolecular complexes.
\item[] Geometries from Jurecka et al. PCCP 8 1985 (2006).
\item[] Reference interaction energies from Marshall et al. JCP 135 194102 (2011).
\end{DUlineblock}
\begin{itemize}
\item {} 
\textbf{cp}  \code{'off'} \textbar{}\textbar{} \code{'on'}

\item {} 
\textbf{rlxd} \code{'off'}

\item {} 
\textbf{benchmark}
\begin{itemize}
\item {} 
\code{'S220'} Jurecka et al. PCCP 8 1985 (2006).

\item {} 
\code{'S22A'} Takatani et al. JCP 132 144104 (2010).

\item {} 
{\color{red}\bfseries{}\textbar{}dl\textbar{}} \code{'S22B'} {\color{red}\bfseries{}\textbar{}dr\textbar{}} Marshall et al. JCP 135 194102 (2011).

\end{itemize}

\item {} 
\textbf{subset}
\begin{itemize}
\item {} 
\code{'small'} water dimer, methane dimer, ethene-ethine

\item {} 
\code{'large'} adenine-thymine

\item {} 
\code{'HB'} hydrogen-bonded systems

\item {} 
\code{'MX'} mixed-influence systems

\item {} 
\code{'DD'} dispersion-dominated systems

\end{itemize}

\end{itemize}


\bigskip\hrule{}\bigskip

\phantomsection\label{db:module-S22by5}\index{S22by5 (module)}
\textbf{S22by5}

\begin{DUlineblock}{0em}
\item[] Database (Hobza) of interaction energies for dissociation curves of bimolecular complexes.
\item[] Geometries and reference interaction energies from Grafova et al. JCTC 6 2365 (2010).
\item[] Note that the S22by5-N-1.0 members are essentially the same geometries as S22-N (there's trivial round-off error) but the reference interaction energies for S22by5 are of lower quality than those of S22.
\end{DUlineblock}
\begin{itemize}
\item {} 
\textbf{cp}  \code{'off'} \textbar{}\textbar{} \code{'on'}

\item {} 
\textbf{rlxd} \code{'off'}

\item {} 
\textbf{subset}
\begin{itemize}
\item {} 
\code{'small'}

\item {} 
\code{'large'}

\item {} 
\code{'equilibrium'}

\item {} 
\code{'mol1'} five-point (0.9, 1.0, 1.2, 1.5, 2.0) $\times R_{eq}$ dissociation curve for molecule 1

\item {} 
...

\item {} 
\code{'mol22'} five-point (0.9, 1.0, 1.2, 1.5, 2.0) $\times R_{eq}$ dissociation curve for molecule 22

\end{itemize}

\end{itemize}


\bigskip\hrule{}\bigskip

\phantomsection\label{db:module-S66}\index{S66 (module)}
\textbf{S66}

\begin{DUlineblock}{0em}
\item[] Database (Hobza) of interaction energies for bimolecular complexes.
\item[] Geometries and reference energies from Rezac et al. JCTC 7 2427 (2011).
\end{DUlineblock}
\begin{itemize}
\item {} 
\textbf{cp}  \code{'off'} \textbar{}\textbar{} \code{'on'}

\item {} 
\textbf{rlxd} \code{'off'}

\item {} 
\textbf{subset}
\begin{itemize}
\item {} 
\code{'small'}

\item {} 
\code{'large'}

\item {} 
\code{'HB'} hydrogen-bonded systems

\item {} 
\code{'MX'} mixed-influence systems

\item {} 
\code{'DD'} dispersion-dominated systems

\end{itemize}

\end{itemize}


\bigskip\hrule{}\bigskip

\phantomsection\label{db:module-SSI}\index{SSI (module)}
\textbf{SSI}

\begin{DUlineblock}{0em}
\item[] Database (Merz) of interaction energies for protein sidechain-sidechain interactions.
\item[] Geometries from Kenneth Merz Group, Univ. of Florida.
\item[] Reference interaction energies from \textless{}Reference\textgreater{}.
\end{DUlineblock}
\begin{itemize}
\item {} 
\textbf{cp}  \code{'off'} \textbar{}\textbar{} \code{'on'}

\item {} 
\textbf{rlxd} \code{'off'}

\end{itemize}


\bigskip\hrule{}\bigskip


For many of the PSI4 Python functions described above, it makes scientific
sense that they could be called in combination. For instance, one could
optimize all the reagents in a database or compute a
counterpoise-corrected interaction energy with an extrapolated method. The
table below outlines permitted intercalls between functions, showing that
db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This
table is not yet validated for calls with cp().
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|L|L|L|L|}
\hline
\textbf{
Caller
} &  \multicolumn{5}{l|}{\textbf{
Callee
}}\\\hline
\textbf{} & \textbf{
cp
} & \textbf{
db
} & \textbf{
opt
} & \textbf{
cbs
} & \textbf{
energy
}\\\hline

cp
 &  & 
---
 & 
Y
 & 
Y
 & 
Y
\\\hline

db
 & 
---
 &  & 
Y
 & 
Y
 & 
Y
\\\hline

opt
 & 
---
 & 
---
 &  & 
Y
 & 
Y
\\\hline

cbs
 & 
---
 & 
---
 & 
---
 &  & 
Y
\\\hline

energy
 & 
---
 & 
---
 & 
---
 & 
---
 & \\\hline
\end{tabulary}

\end{quote}
\begin{itemize}
\item {} 
The command db(opt(cbs(energy()))) is actually expressed as \code{db(...,
db\_func=opt, opt\_func=cbs)}. The perhaps expected final argument of
\code{cbs\_func=energy} is not necessary since energy() is always the function
called by default. Also, the outermost internal function call (\code{db\_func}
above can be called as just \code{func}. Several examples of intercalls
between Python functions can be found in sample input \emph{pywrap\_all}.

\item {} 
All keyword arguments are passed along to each function traversed in the

\end{itemize}

Python driver, so there should be no concern for separating them, grouping
them, or designating them for a particular function when undertaking a
nested calculation. Where the same keyword is used by multiple functions,
prefixes are added, e.g., \textbf{db\_mode} and \textbf{opt\_mode}.
\begin{itemize}
\item {} 
Function intercalls should not be used in sow/reap mode.

\end{itemize}
\begin{description}
\item[{NAME}] \leavevmode
PsiMod

\item[{FILE}] \leavevmode
(built-in)

\item[{CLASSES}] \leavevmode\begin{description}
\item[{Boost.Python.enum(\_\_builtin\_\_.int)}] \leavevmode
DiagonalizeOrder
PsiReturnType

\item[{Boost.Python.instance(\_\_builtin\_\_.object)}] \leavevmode
Arguments
BasisSet
BasisSetParser
\begin{quote}

Gaussian94BasisSetParser
\end{quote}

CdSalcList
Checkpoint
DFChargeFitter
Environment
ExternalPotential
FittingMetric
Functional
GridProp
IO
IOManager
IntVector
Matrix
MatrixFactory
MintsHelper
MoldenWriter
Molecule
MultipoleSymmetry
NBOWriter
OEProp
PetiteList
PointGroup
Process
PseudoTrial
SOBasisSet
SuperFunctional
SymmetryOperation
Vector
Vector3
Wavefunction
\begin{quote}
\begin{description}
\item[{HF}] \leavevmode
RHF(HF, Wavefunction)

\end{description}
\end{quote}

matrix\_vector

\item[{class Arguments(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Arguments
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_getitem\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_getitem\_\_( (Arguments)arg1, (int)arg2) -\textgreater{} str :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] \_\_init\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_init\_\_( (object)arg1) -\textgreater{} None
\item[] 
\end{DUlineblock}
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_instance\_size\_\_ = 40
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class BasisSet(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] BasisSet
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] max\_am(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] max\_am( (BasisSet)arg1) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] nao(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] nao( (BasisSet)arg1) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] nbf(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] nbf( (BasisSet)arg1) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] nprimitive(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] nprimitive( (BasisSet)arg1) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] nshell(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] nshell( (BasisSet)arg1) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] print\_detail\_out(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] print\_detail\_out( (BasisSet)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] print\_out(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] print\_out( (BasisSet)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Static methods defined here:
\item[] 
\item[] construct(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] construct( (BasisSetParser)arg1, (Molecule)arg2, (str)arg3) -\textgreater{} BasisSet :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] make\_filename(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] make\_filename( (str)arg1) -\textgreater{} str :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_init\_\_ = \textless{}built-in function \_\_init\_\_\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Raises an exception
\item[] This class cannot be instantiated from Python
\item[] 
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class BasisSetParser(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] BasisSetParser
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_init\_\_ = \textless{}built-in function \_\_init\_\_\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Raises an exception
\item[] This class cannot be instantiated from Python
\item[] 
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class CdSalcList(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] CdSalcList
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] matrix(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] matrix( (CdSalcList)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] print\_out(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] print\_out( (CdSalcList)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_init\_\_ = \textless{}built-in function \_\_init\_\_\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Raises an exception
\item[] This class cannot be instantiated from Python
\item[] 
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class Checkpoint(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Checkpoint
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_init\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_init\_\_( (object)arg1, (IO)arg2, (int)arg3) -\textgreater{} None
\item[] 
\end{DUlineblock}
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Static methods defined here:
\item[] 
\item[] shared\_object(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] shared\_object() -\textgreater{} Checkpoint :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data descriptors defined here:
\item[] 
\item[] disp
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\item[] e\_t
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\item[] eccsd
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\item[] ecorr
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\item[] efzc
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\item[] emp2
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\item[] enuc
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\item[] eref
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\item[] escf
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\item[] etot
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\item[] label
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_instance\_size\_\_ = 32
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class DFChargeFitter(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] DFChargeFitter
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_init\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_init\_\_( (object)arg1) -\textgreater{} None
\item[] 
\end{DUlineblock}
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] d(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] d( (DFChargeFitter)arg1) -\textgreater{} Vector :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] fit(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] fit( (DFChargeFitter)arg1) -\textgreater{} Vector :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] setAuxiliary(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] setAuxiliary( (DFChargeFitter)arg1, (BasisSet)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] setD(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] setD( (DFChargeFitter)arg1, (Matrix)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] setPrimary(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] setPrimary( (DFChargeFitter)arg1, (BasisSet)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_instance\_size\_\_ = 32
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class DiagonalizeOrder(Boost.Python.enum)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] DiagonalizeOrder
\item[] Boost.Python.enum
\item[] \_\_builtin\_\_.int
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Data and other attributes defined here:
\item[] 
\item[] Ascending = PsiMod.DiagonalizeOrder.Ascending
\item[] 
\item[] Descending = PsiMod.DiagonalizeOrder.Descending
\item[] 
\item[] names = \{`Ascending': PsiMod.DiagonalizeOrder.Ascending, `Descending':...
\item[] 
\item[] values = \{1: PsiMod.DiagonalizeOrder.Ascending, 3: PsiMod.DiagonalizeO...
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Methods inherited from Boost.Python.enum:
\item[] 
\item[] \_\_repr\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_repr\_\_() \textless{}==\textgreater{} repr(x)
\item[] 
\end{DUlineblock}
\item[] \_\_str\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_str\_\_() \textless{}==\textgreater{} str(x)
\item[] 
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.enum:
\item[] 
\item[] name
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Methods inherited from \_\_builtin\_\_.int:
\item[] 
\item[] \_\_abs\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_abs\_\_() \textless{}==\textgreater{} abs(x)
\item[] 
\end{DUlineblock}
\item[] \_\_add\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_add\_\_(y) \textless{}==\textgreater{} x+y
\item[] 
\end{DUlineblock}
\item[] \_\_and\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_and\_\_(y) \textless{}==\textgreater{} x\&y
\item[] 
\end{DUlineblock}
\item[] \_\_cmp\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_cmp\_\_(y) \textless{}==\textgreater{} cmp(x,y)
\item[] 
\end{DUlineblock}
\item[] \_\_coerce\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_coerce\_\_(y) \textless{}==\textgreater{} coerce(x, y)
\item[] 
\end{DUlineblock}
\item[] \_\_div\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_div\_\_(y) \textless{}==\textgreater{} x/y
\item[] 
\end{DUlineblock}
\item[] \_\_divmod\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_divmod\_\_(y) \textless{}==\textgreater{} divmod(x, y)
\item[] 
\end{DUlineblock}
\item[] \_\_float\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_float\_\_() \textless{}==\textgreater{} float(x)
\item[] 
\end{DUlineblock}
\item[] \_\_floordiv\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_floordiv\_\_(y) \textless{}==\textgreater{} x//y
\item[] 
\end{DUlineblock}
\item[] \_\_format\_\_(...)
\item[] 
\item[] \_\_getattribute\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_getattribute\_\_(`name') \textless{}==\textgreater{} x.name
\item[] 
\end{DUlineblock}
\item[] \_\_getnewargs\_\_(...)
\item[] 
\item[] \_\_hash\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_hash\_\_() \textless{}==\textgreater{} hash(x)
\item[] 
\end{DUlineblock}
\item[] \_\_hex\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_hex\_\_() \textless{}==\textgreater{} hex(x)
\item[] 
\end{DUlineblock}
\item[] \_\_index\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x{[}y:z{]} \textless{}==\textgreater{} x{[}y.\_\_index\_\_():z.\_\_index\_\_(){]}
\item[] 
\end{DUlineblock}
\item[] \_\_int\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_int\_\_() \textless{}==\textgreater{} int(x)
\item[] 
\end{DUlineblock}
\item[] \_\_invert\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_invert\_\_() \textless{}==\textgreater{} \textasciitilde{}x
\item[] 
\end{DUlineblock}
\item[] \_\_long\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_long\_\_() \textless{}==\textgreater{} long(x)
\item[] 
\end{DUlineblock}
\item[] \_\_lshift\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_lshift\_\_(y) \textless{}==\textgreater{} x\textless{}\textless{}y
\item[] 
\end{DUlineblock}
\item[] \_\_mod\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_mod\_\_(y) \textless{}==\textgreater{} x\%y
\item[] 
\end{DUlineblock}
\item[] \_\_mul\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_mul\_\_(y) \textless{}==\textgreater{} x*y
\item[] 
\end{DUlineblock}
\item[] \_\_neg\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_neg\_\_() \textless{}==\textgreater{} -x
\item[] 
\end{DUlineblock}
\item[] \_\_nonzero\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_nonzero\_\_() \textless{}==\textgreater{} x != 0
\item[] 
\end{DUlineblock}
\item[] \_\_oct\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_oct\_\_() \textless{}==\textgreater{} oct(x)
\item[] 
\end{DUlineblock}
\item[] \_\_or\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_or\_\_(y) \textless{}==\textgreater{} x\textbar{}y
\item[] 
\end{DUlineblock}
\item[] \_\_pos\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_pos\_\_() \textless{}==\textgreater{} +x
\item[] 
\end{DUlineblock}
\item[] \_\_pow\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_pow\_\_(y{[}, z{]}) \textless{}==\textgreater{} pow(x, y{[}, z{]})
\item[] 
\end{DUlineblock}
\item[] \_\_radd\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_radd\_\_(y) \textless{}==\textgreater{} y+x
\item[] 
\end{DUlineblock}
\item[] \_\_rand\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_rand\_\_(y) \textless{}==\textgreater{} y\&x
\item[] 
\end{DUlineblock}
\item[] \_\_rdiv\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_rdiv\_\_(y) \textless{}==\textgreater{} y/x
\item[] 
\end{DUlineblock}
\item[] \_\_rdivmod\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_rdivmod\_\_(y) \textless{}==\textgreater{} divmod(y, x)
\item[] 
\end{DUlineblock}
\item[] \_\_rfloordiv\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_rfloordiv\_\_(y) \textless{}==\textgreater{} y//x
\item[] 
\end{DUlineblock}
\item[] \_\_rlshift\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_rlshift\_\_(y) \textless{}==\textgreater{} y\textless{}\textless{}x
\item[] 
\end{DUlineblock}
\item[] \_\_rmod\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_rmod\_\_(y) \textless{}==\textgreater{} y\%x
\item[] 
\end{DUlineblock}
\item[] \_\_rmul\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_rmul\_\_(y) \textless{}==\textgreater{} y*x
\item[] 
\end{DUlineblock}
\item[] \_\_ror\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_ror\_\_(y) \textless{}==\textgreater{} y\textbar{}x
\item[] 
\end{DUlineblock}
\item[] \_\_rpow\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] y.\_\_rpow\_\_(x{[}, z{]}) \textless{}==\textgreater{} pow(x, y{[}, z{]})
\item[] 
\end{DUlineblock}
\item[] \_\_rrshift\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_rrshift\_\_(y) \textless{}==\textgreater{} y\textgreater{}\textgreater{}x
\item[] 
\end{DUlineblock}
\item[] \_\_rshift\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_rshift\_\_(y) \textless{}==\textgreater{} x\textgreater{}\textgreater{}y
\item[] 
\end{DUlineblock}
\item[] \_\_rsub\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_rsub\_\_(y) \textless{}==\textgreater{} y-x
\item[] 
\end{DUlineblock}
\item[] \_\_rtruediv\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_rtruediv\_\_(y) \textless{}==\textgreater{} y/x
\item[] 
\end{DUlineblock}
\item[] \_\_rxor\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_rxor\_\_(y) \textless{}==\textgreater{} y\textasciicircum{}x
\item[] 
\end{DUlineblock}
\item[] \_\_sub\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_sub\_\_(y) \textless{}==\textgreater{} x-y
\item[] 
\end{DUlineblock}
\item[] \_\_truediv\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_truediv\_\_(y) \textless{}==\textgreater{} x/y
\item[] 
\end{DUlineblock}
\item[] \_\_trunc\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Truncating an Integral returns itself.
\item[] 
\end{DUlineblock}
\item[] \_\_xor\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_xor\_\_(y) \textless{}==\textgreater{} x\textasciicircum{}y
\item[] 
\end{DUlineblock}
\item[] bit\_length(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] int.bit\_length() -\textgreater{} int
\item[] 
\item[] Number of bits necessary to represent self in binary.
\item[] \textgreater{}\textgreater{}\textgreater{} bin(37)
\item[] `0b100101'
\item[] \textgreater{}\textgreater{}\textgreater{} (37).bit\_length()
\item[] 6
\item[] 
\end{DUlineblock}
\item[] conjugate(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Returns self, the complex conjugate of any int.
\item[] 
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from \_\_builtin\_\_.int:
\item[] 
\item[] denominator
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] the denominator of a rational number in lowest terms
\item[] 
\end{DUlineblock}
\item[] imag
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] the imaginary part of a complex number
\item[] 
\end{DUlineblock}
\item[] numerator
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] the numerator of a rational number in lowest terms
\item[] 
\end{DUlineblock}
\item[] real
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] the real part of a complex number
\item[] 
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from \_\_builtin\_\_.int:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of type object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class Environment(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Environment
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_getitem\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_getitem\_\_( (Environment)arg1, (str)arg2) -\textgreater{} str :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] \_\_init\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_init\_\_( (object)arg1) -\textgreater{} None
\item[] 
\end{DUlineblock}
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_instance\_size\_\_ = 352
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class ExternalPotential(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] ExternalPotential
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_init\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_init\_\_( (object)arg1) -\textgreater{} None
\item[] 
\end{DUlineblock}
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] addBasis(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] addCharge(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] clear(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] clear( (ExternalPotential)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] computePotentialMatrix(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] print\_out(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] print\_out( (ExternalPotential)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] setName(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] setName( (ExternalPotential)arg1, (str)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_instance\_size\_\_ = 32
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class FittingMetric(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] FittingMetric
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_init\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_init\_\_( (object)arg1) -\textgreater{} None
\item[] 
\end{DUlineblock}
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] form\_QR\_inverse(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] form\_QR\_inverse( (FittingMetric)arg1, (float)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] form\_cholesky\_inverse(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] form\_cholesky\_inverse( (FittingMetric)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] form\_eig\_inverse(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] form\_eig\_inverse( (FittingMetric)arg1, (float)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] form\_fitting\_metric(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] form\_fitting\_metric( (FittingMetric)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] form\_full\_inverse(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] form\_full\_inverse( (FittingMetric)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get\_algorithm(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get\_algorithm( (FittingMetric)arg1) -\textgreater{} str :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get\_metric(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get\_metric( (FittingMetric)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get\_pivots(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get\_pivots( (FittingMetric)arg1) -\textgreater{} IntVector :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get\_reverse\_pivots(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get\_reverse\_pivots( (FittingMetric)arg1) -\textgreater{} IntVector :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] is\_inverted(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] is\_inverted( (FittingMetric)arg1) -\textgreater{} bool :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] is\_poisson(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] is\_poisson( (FittingMetric)arg1) -\textgreater{} bool :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_instance\_size\_\_ = 32
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class Functional(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Functional
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] computeRKSFunctional(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] computeRKSFunctional( (Functional)arg1, (object)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] computeUKSFunctional(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] computeUKSFunctional( (Functional)arg1, (object)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get\_citation(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get\_citation( (Functional)arg1) -\textgreater{} str :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get\_density\_cutoff(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get\_density\_cutoff( (Functional)arg1) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get\_deriv(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get\_deriv( (Functional)arg1) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get\_description(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get\_description( (Functional)arg1) -\textgreater{} str :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get\_name(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get\_name( (Functional)arg1) -\textgreater{} str :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get\_npoints(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get\_npoints( (Functional)arg1) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get\_parameters(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get\_parameters( (Functional)arg1) -\textgreater{} object :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get\_parameters\_string(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get\_parameters\_string( (Functional)arg1) -\textgreater{} str :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] is\_gga(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] is\_gga( (Functional)arg1) -\textgreater{} bool :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] is\_meta(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] is\_meta( (Functional)arg1) -\textgreater{} bool :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_citation(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_citation( (Functional)arg1, (str)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_density\_cutoff(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_density\_cutoff( (Functional)arg1, (float)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_deriv(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_deriv( (Functional)arg1, (int)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_description(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_description( (Functional)arg1, (str)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_name(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_name( (Functional)arg1, (str)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_npoints(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_npoints( (Functional)arg1, (int)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_parameter(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_parameter( (Functional)arg1, (str)arg2, (float)arg3) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_parameters(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_parameters( (Functional)arg1, (object)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Static methods defined here:
\item[] 
\item[] available\_functionals(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] available\_functionals() -\textgreater{} str :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] available\_names(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] available\_names() -\textgreater{} object :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] create\_functional(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] create\_functional( (str)arg1, (int)arg2, (int)arg3) -\textgreater{} Functional :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_init\_\_ = \textless{}built-in function \_\_init\_\_\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Raises an exception
\item[] This class cannot be instantiated from Python
\item[] 
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class Gaussian94BasisSetParser(BasisSetParser)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Gaussian94BasisSetParser
\item[] BasisSetParser
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_init\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_init\_\_( (object)arg1) -\textgreater{} None
\item[] 
\end{DUlineblock}
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_instance\_size\_\_ = 32
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class GridProp(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] GridProp
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_init\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_init\_\_( (object)arg1) -\textgreater{} None
\item[] 
\end{DUlineblock}
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] add(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] add( (GridProp)arg1, (str)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] add\_alpha\_mo(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] add\_alpha\_mo( (GridProp)arg1, (int)arg2, (int)arg3) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] add\_basis\_fun(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] add\_basis\_fun( (GridProp)arg1, (int)arg2, (int)arg3) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] add\_beta\_mo(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] add\_beta\_mo( (GridProp)arg1, (int)arg2, (int)arg3) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] build\_grid\_overages(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] build\_grid\_overages( (GridProp)arg1, (float)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] compute(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] compute( (GridProp)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get\_l(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get\_l( (GridProp)arg1, (int)arg2) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get\_n(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get\_n( (GridProp)arg1, (int)arg2) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get\_o(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get\_o( (GridProp)arg1, (int)arg2) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_caxis(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_caxis( (GridProp)arg1, (float)arg2, (float)arg3) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_filename(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_filename( (GridProp)arg1, (str)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_format(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_format( (GridProp)arg1, (str)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_l(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_l( (GridProp)arg1, (float)arg2, (float)arg3, (float)arg4) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_n(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_n( (GridProp)arg1, (int)arg2, (int)arg3, (int)arg4) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_o(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_o( (GridProp)arg1, (float)arg2, (float)arg3, (float)arg4) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_instance\_size\_\_ = 32
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class HF(Wavefunction)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] HF
\item[] Wavefunction
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_init\_\_ = \textless{}built-in function \_\_init\_\_\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Raises an exception
\item[] This class cannot be instantiated from Python
\item[] 
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Methods inherited from Wavefunction:
\item[] 
\item[] Ca(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Ca( (Wavefunction)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] Cb(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Cb( (Wavefunction)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] Da(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Da( (Wavefunction)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] Db(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Db( (Wavefunction)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] Fa(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Fa( (Wavefunction)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] Fb(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Fb( (Wavefunction)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] add\_postiteration\_callback(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] add\_postiteration\_callback( (Wavefunction)arg1, (object)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] add\_preiteration\_callback(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] add\_preiteration\_callback( (Wavefunction)arg1, (object)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] basisset(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] basisset( (Wavefunction)arg1) -\textgreater{} BasisSet :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] energy(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] energy( (Wavefunction)arg1) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] epsilon\_a(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] epsilon\_a( (Wavefunction)arg1) -\textgreater{} Vector :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] epsilon\_b(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] epsilon\_b( (Wavefunction)arg1) -\textgreater{} Vector :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] frequencies(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] frequencies( (Wavefunction)arg1) -\textgreater{} Vector :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] gradient(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] gradient( (Wavefunction)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] nirrep(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] nirrep( (Wavefunction)arg1) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] nmo(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] nmo( (Wavefunction)arg1) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] nso(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] nso( (Wavefunction)arg1) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] sobasisset(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] sobasisset( (Wavefunction)arg1) -\textgreater{} SOBasisSet :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class IO(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] IO
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_init\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_init\_\_( (object)arg1) -\textgreater{} None
\item[] 
\end{DUlineblock}
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] close(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] close( (IO)arg1, (int)arg2, (int)arg3) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] open(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] open( (IO)arg1, (int)arg2, (int)arg3) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] open\_check(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] open\_check( (IO)arg1, (int)arg2) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] rehash(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] rehash( (IO)arg1, (int)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] state(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] state( (IO)arg1) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] tocclean(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] tocclean( (IO)arg1, (int)arg2, (str)arg3) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] tocprint(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] tocprint( (IO)arg1, (int)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] tocwrite(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] tocwrite( (IO)arg1, (int)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Static methods defined here:
\item[] 
\item[] change\_file\_namespace(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] change\_file\_namespace( (int)arg1, (str)arg2, (str)arg3) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get\_default\_namespace(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get\_default\_namespace() -\textgreater{} str :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_default\_namespace(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_default\_namespace( (str)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] shared\_object(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] shared\_object() -\textgreater{} IO
\item[] 
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_instance\_size\_\_ = 32
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class IOManager(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] IOManager
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_init\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_init\_\_( (object)arg1) -\textgreater{} None
\item[] 
\end{DUlineblock}
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] crashclean(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] crashclean( (IOManager)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get\_default\_path(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get\_default\_path( (IOManager)arg1) -\textgreater{} str :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get\_file\_path(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get\_file\_path( (IOManager)arg1, (int)arg2) -\textgreater{} str :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] mark\_file\_for\_retention(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] mark\_file\_for\_retention( (IOManager)arg1, (str)arg2, (bool)arg3) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] print\_out(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] print\_out( (IOManager)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] psiclean(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] psiclean( (IOManager)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_default\_path(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_default\_path( (IOManager)arg1, (str)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_specific\_path(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_specific\_path( (IOManager)arg1, (int)arg2, (str)arg3) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_specific\_retention(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_specific\_retention( (IOManager)arg1, (int)arg2, (bool)arg3) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] write\_scratch\_file(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] write\_scratch\_file( (IOManager)arg1, (str)arg2, (str)arg3) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Static methods defined here:
\item[] 
\item[] shared\_object(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] shared\_object() -\textgreater{} IOManager :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_instance\_size\_\_ = 32
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class IntVector(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] IntVector
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_init\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_init\_\_( (object)arg1) -\textgreater{} None
\item[] 
\item[] \_\_init\_\_( (object)arg1, (int)arg2) -\textgreater{} None
\item[] 
\end{DUlineblock}
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] dim(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] dim( (IntVector)arg1, (int)arg2) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get( (IntVector)arg1, (int)arg2, (int)arg3) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] nirrep(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] nirrep( (IntVector)arg1) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] print\_out(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] print\_out( (IntVector)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set( (IntVector)arg1, (int)arg2, (int)arg3, (int)arg4) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_instance\_size\_\_ = 32
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class Matrix(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Matrix
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_getitem\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_getitem\_\_( (Matrix)arg1, (tuple)arg2) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] \_\_init\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_init\_\_( (object)arg1) -\textgreater{} None
\item[] 
\item[] \_\_init\_\_( (object)arg1, (int)arg2, (int)arg3) -\textgreater{} None
\item[] 
\end{DUlineblock}
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] \_\_setitem\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_setitem\_\_( (Matrix)arg1, (tuple)arg2, (float)arg3) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] accumulate\_product(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] accumulate\_product( (Matrix)arg1, (Matrix)arg2, (Matrix)arg3) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] add(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] add( (Matrix)arg1, (Matrix)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] back\_transform(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] back\_transform( (Matrix)arg1, (Matrix)arg2, (Matrix)arg3) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] cholesky\_factorize(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] cholesky\_factorize( (Matrix)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] cols(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] cols( (Matrix)arg1, (int)arg2) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] copy\_lower\_to\_upper(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] copy\_lower\_to\_upper( (Matrix)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] copy\_upper\_to\_lower(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] copy\_upper\_to\_lower( (Matrix)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] diagonalize(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] diagonalize( (Matrix)arg1, (Matrix)arg2, (Vector)arg3, (DiagonalizeOrder)arg4) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] exp(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] exp( (Matrix)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] gemm(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] gemm( (Matrix)arg1, (bool)arg2, (bool)arg3, (float)arg4, (Matrix)arg5, (Matrix)arg6, (float)arg7) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get( (Matrix)arg1, (int)arg2, (int)arg3 {[}, (int)arg4{]}) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] identity(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] identity( (Matrix)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] invert(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] invert( (Matrix)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] load(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] load( (Matrix)arg1, (str)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] name(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] name( (Matrix)arg1) -\textgreater{} str :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] nirrep(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] nirrep( (Matrix)arg1) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] partial\_cholesky\_factorize(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] partial\_cholesky\_factorize( (Matrix)arg1, (float)arg2, (bool)arg3) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] power(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] power( (Matrix)arg1, (float)arg2, (float)arg3) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] print\_out(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] print\_out( (Matrix)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] project\_out(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] project\_out( (Matrix)arg1, (Matrix)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] remove\_symmetry(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] remove\_symmetry( (Matrix)arg1, (Matrix)arg2, (Matrix)arg3) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] rms(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] rms( (Matrix)arg1) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] rows(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] rows( (Matrix)arg1, (int)arg2) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] save(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] save( (Matrix)arg1, (str)arg2, (bool)arg3, (bool)arg4, (bool)arg5) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] scale(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] scale( (Matrix)arg1, (float)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] scale\_column(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] scale\_column( (Matrix)arg1, (int)arg2, (int)arg3, (float)arg4) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] scale\_row(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] scale\_row( (Matrix)arg1, (int)arg2, (int)arg3, (float)arg4) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set( (Matrix)arg1, (int)arg2, (int)arg3, (float)arg4) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\item[] set( (Matrix)arg1, (int)arg2, (int)arg3, (int)arg4, (float)arg5) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\item[] set( (Matrix)arg1, (list)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_name(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_name( (Matrix)arg1, (str)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] subtract(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] subtract( (Matrix)arg1, (Matrix)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] sum\_of\_squares(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] sum\_of\_squares( (Matrix)arg1) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] symmetry(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] symmetry( (Matrix)arg1) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] trace(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] trace( (Matrix)arg1) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] transform(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] transform( (Matrix)arg1, (Matrix)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\item[] transform( (Matrix)arg1, (Matrix)arg2 {[}, (Matrix)arg3{]}) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] vector\_dot(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] vector\_dot( (Matrix)arg1, (Matrix)arg2) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] zero(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] zero( (Matrix)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] zero\_diagonal(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] zero\_diagonal( (Matrix)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] zero\_lower(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] zero\_lower( (Matrix)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] zero\_upper(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] zero\_upper( (Matrix)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_instance\_size\_\_ = 32
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class MatrixFactory(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] MatrixFactory
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_init\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_init\_\_( (object)arg1) -\textgreater{} None
\item[] 
\end{DUlineblock}
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] create\_matrix(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] create\_matrix( (MatrixFactory)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\item[] create\_matrix( (MatrixFactory)arg1, (str)arg2) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Static methods defined here:
\item[] 
\item[] shared\_object(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] shared\_object() -\textgreater{} MatrixFactory :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_instance\_size\_\_ = 32
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class MintsHelper(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] MintsHelper
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_init\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_init\_\_( (object)arg1) -\textgreater{} None
\item[] 
\end{DUlineblock}
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] ao\_angular\_momentum(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] ao\_angular\_momentum( (MintsHelper)arg1) -\textgreater{} matrix\_vector :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ao\_erf\_eri(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] ao\_erf\_eri( (MintsHelper)arg1, (float)arg2) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ao\_eri(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] ao\_eri( (MintsHelper)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ao\_kinetic(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] ao\_kinetic( (MintsHelper)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ao\_nabla(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] ao\_nabla( (MintsHelper)arg1) -\textgreater{} matrix\_vector :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ao\_overlap(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] ao\_overlap( (MintsHelper)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ao\_potential(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] ao\_potential( (MintsHelper)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] basisset(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] basisset( (MintsHelper)arg1) -\textgreater{} BasisSet :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] cdsalcs(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] cdsalcs( (MintsHelper)arg1, (int)arg2, (bool)arg3, (bool)arg4) -\textgreater{} CdSalcList :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] factory(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] factory( (MintsHelper)arg1) -\textgreater{} MatrixFactory :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] integrals(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] integrals( (MintsHelper)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] one\_electron\_integrals(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] one\_electron\_integrals( (MintsHelper)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\item[] one\_electron\_integrals( (MintsHelper)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] petite\_list(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] petite\_list( (MintsHelper)arg1) -\textgreater{} PetiteList :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] play(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] play( (MintsHelper)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] so\_angular\_momentum(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] so\_angular\_momentum( (MintsHelper)arg1) -\textgreater{} matrix\_vector :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] so\_dipole(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] so\_dipole( (MintsHelper)arg1) -\textgreater{} matrix\_vector :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] so\_kinetic(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] so\_kinetic( (MintsHelper)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] so\_nabla(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] so\_nabla( (MintsHelper)arg1) -\textgreater{} matrix\_vector :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] so\_overlap(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] so\_overlap( (MintsHelper)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] so\_potential(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] so\_potential( (MintsHelper)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] so\_quadrupole(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] so\_quadrupole( (MintsHelper)arg1) -\textgreater{} matrix\_vector :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] so\_traceless\_quadrupole(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] so\_traceless\_quadrupole( (MintsHelper)arg1) -\textgreater{} matrix\_vector :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] sobasisset(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] sobasisset( (MintsHelper)arg1) -\textgreater{} SOBasisSet :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_instance\_size\_\_ = 32
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class MoldenWriter(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] MoldenWriter
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_init\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_init\_\_( (object)arg1, (Wavefunction)arg2) -\textgreater{} None
\item[] 
\end{DUlineblock}
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] write(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] write( (MoldenWriter)arg1, (str)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class Molecule(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Molecule
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] Z(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Z( (Molecule)arg1, (int)arg2) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] \_\_init\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_init\_\_( (object)arg1) -\textgreater{} None
\item[] 
\end{DUlineblock}
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] activate\_all\_fragments(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] activate\_all\_fragments( (Molecule)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] add\_atom(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] add\_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] atom\_at\_position(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] atom\_at\_position( (Molecule)arg1, (float)arg2, (float)arg3) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] center\_of\_mass(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] center\_of\_mass( (Molecule)arg1) -\textgreater{} Vector3 :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] charge(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] charge( (Molecule)arg1, (int)arg2) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] deactivate\_all\_fragments(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] deactivate\_all\_fragments( (Molecule)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] extract\_subsets(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] extract\_subsets( (Molecule)arg1, (list)arg2, (list)arg3) -\textgreater{} Molecule :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\item[] extract\_subsets( (Molecule)arg1, (list)arg2, (int)arg3) -\textgreater{} Molecule :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\item[] extract\_subsets( (Molecule)arg1, (int)arg2, (list)arg3) -\textgreater{} Molecule :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\item[] extract\_subsets( (Molecule)arg1, (int)arg2, (int)arg3) -\textgreater{} Molecule :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\item[] extract\_subsets( (Molecule)arg1, (list)arg2) -\textgreater{} Molecule :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\item[] extract\_subsets( (Molecule)arg1, (int)arg2) -\textgreater{} Molecule :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] find\_point\_group(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] find\_point\_group( (Molecule)arg1, (float)arg2) -\textgreater{} PointGroup :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] fix\_orientation(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] fix\_orientation( (Molecule)arg1, (bool)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] form\_symmetry\_information(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] form\_symmetry\_information( (Molecule)arg1, (float)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get\_variable(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get\_variable( (Molecule)arg1, (str)arg2) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] init\_with\_checkpoint(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] init\_with\_checkpoint( (Molecule)arg1, (Checkpoint)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] init\_with\_io(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] init\_with\_io( (Molecule)arg1, (IO)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] is\_variable(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] is\_variable( (Molecule)arg1, (str)arg2) -\textgreater{} bool :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] label(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] label( (Molecule)arg1, (int)arg2) -\textgreater{} str :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] mass(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] mass( (Molecule)arg1, (int)arg2) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] molecular\_charge(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] molecular\_charge( (Molecule)arg1) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] move\_to\_com(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] move\_to\_com( (Molecule)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] multiplicity(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] multiplicity( (Molecule)arg1) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] name(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] name( (Molecule)arg1) -\textgreater{} str :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] natom(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] natom( (Molecule)arg1) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] nfragments(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] nfragments( (Molecule)arg1) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] nuclear\_repulsion\_energy(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] nuclear\_repulsion\_energy( (Molecule)arg1) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] point\_group(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] point\_group( (Molecule)arg1) -\textgreater{} PointGroup :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] print\_in\_input\_format(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] print\_in\_input\_format( (Molecule)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] print\_out(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] print\_out( (Molecule)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\item[] print\_out( (Molecule)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] print\_out\_in\_bohr(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] print\_out\_in\_bohr( (Molecule)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] reinterpret\_coordentry(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] reinterpret\_coordentry( (Molecule)arg1, (bool)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] reset\_point\_group(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] reset\_point\_group( (Molecule)arg1, (str)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] save\_string\_xyz(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] save\_string\_xyz( (Molecule)arg1) -\textgreater{} str :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] save\_to\_checkpoint(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] save\_to\_checkpoint( (Molecule)arg1, (Checkpoint)arg2, (str)arg3) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] save\_xyz(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] save\_xyz( (Molecule)arg1, (str)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] schoenflies\_symbol(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] schoenflies\_symbol( (Molecule)arg1) -\textgreater{} str :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_active\_fragment(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_active\_fragment( (Molecule)arg1, (int)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_active\_fragments(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_active\_fragments( (Molecule)arg1, (list)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_basis\_all\_atoms(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_basis\_all\_atoms( (Molecule)arg1, (str)arg2, (str)arg3) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_basis\_by\_label(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_basis\_by\_label( (Molecule)arg1, (str)arg2, (str)arg3, (str)arg4) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_basis\_by\_number(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_basis\_by\_number( (Molecule)arg1, (int)arg2, (str)arg3, (str)arg4) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_basis\_by\_symbol(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_basis\_by\_symbol( (Molecule)arg1, (str)arg2, (str)arg3, (str)arg4) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_geometry(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_geometry( (Molecule)arg1, (Matrix)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_ghost\_fragment(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_ghost\_fragment( (Molecule)arg1, (int)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_ghost\_fragments(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_ghost\_fragments( (Molecule)arg1, (list)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_molecular\_charge(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_molecular\_charge( (Molecule)arg1, (int)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_multiplicity(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_multiplicity( (Molecule)arg1, (int)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_name(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_name( (Molecule)arg1, (str)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_point\_group(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_point\_group( (Molecule)arg1, (PointGroup)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_variable(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_variable( (Molecule)arg1, (str)arg2, (float)arg3) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] symbol(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] symbol( (Molecule)arg1, (int)arg2) -\textgreater{} str :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] translate(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] translate( (Molecule)arg1, (Vector3)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] update\_geometry(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] update\_geometry( (Molecule)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\item[] update\_geometry( (Molecule)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] x(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x( (Molecule)arg1, (int)arg2) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] y(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] y( (Molecule)arg1, (int)arg2) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] z(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] z( (Molecule)arg1, (int)arg2) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Static methods defined here:
\item[] 
\item[] create\_molecule\_from\_string(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] create\_molecule\_from\_string( (str)arg1) -\textgreater{} Molecule :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_instance\_size\_\_ = 32
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class MultipoleSymmetry(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] MultipoleSymmetry
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_init\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_init\_\_( (object)arg1, (int)arg2, (Molecule)arg3, (object)arg4, (MatrixFactory)arg5) -\textgreater{} None
\item[] 
\end{DUlineblock}
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] create\_matrices(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] create\_matrices( (MultipoleSymmetry)arg1, (str)arg2) -\textgreater{} matrix\_vector :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class NBOWriter(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] NBOWriter
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_init\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_init\_\_( (object)arg1, (Wavefunction)arg2) -\textgreater{} None
\item[] 
\end{DUlineblock}
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] write(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] write( (NBOWriter)arg1, (str)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class OEProp(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] OEProp
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_init\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_init\_\_( (object)arg1) -\textgreater{} None
\item[] 
\end{DUlineblock}
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] add(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] add( (OEProp)arg1, (str)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] compute(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] compute( (OEProp)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_title(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_title( (OEProp)arg1, (str)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_instance\_size\_\_ = 32
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class PetiteList(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] PetiteList
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] aotoso(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] aotoso( (PetiteList)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] print(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] print( (PetiteList)arg1, (object)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] sotoao(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] sotoao( (PetiteList)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_init\_\_ = \textless{}built-in function \_\_init\_\_\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Raises an exception
\item[] This class cannot be instantiated from Python
\item[] 
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class PointGroup(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] PointGroup
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_init\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_init\_\_( (object)arg1) -\textgreater{} None
\item[] 
\item[] \_\_init\_\_( (object)arg1, (str)arg2) -\textgreater{} None
\item[] 
\end{DUlineblock}
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] symbol(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] symbol( (PointGroup)arg1) -\textgreater{} str :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_instance\_size\_\_ = 32
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class Process(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Process
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_init\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_init\_\_( (object)arg1) -\textgreater{} None
\item[] 
\end{DUlineblock}
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data descriptors defined here:
\item[] 
\item[] environment
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_instance\_size\_\_ = 24
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class PseudoTrial(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] PseudoTrial
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_init\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_init\_\_( (object)arg1) -\textgreater{} None
\item[] 
\end{DUlineblock}
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] getA(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] getA( (PseudoTrial)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] getI(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] getI( (PseudoTrial)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] getIPS(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] getIPS( (PseudoTrial)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] getQ(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] getQ( (PseudoTrial)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] getR(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] getR( (PseudoTrial)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_instance\_size\_\_ = 32
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class PsiReturnType(Boost.Python.enum)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] PsiReturnType
\item[] Boost.Python.enum
\item[] \_\_builtin\_\_.int
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Data and other attributes defined here:
\item[] 
\item[] Balk = PsiMod.PsiReturnType.Balk
\item[] 
\item[] EndLoop = PsiMod.PsiReturnType.EndLoop
\item[] 
\item[] Failure = PsiMod.PsiReturnType.Failure
\item[] 
\item[] Success = PsiMod.PsiReturnType.Success
\item[] 
\item[] names = \{`Balk': PsiMod.PsiReturnType.Balk, `EndLoop': PsiMod.PsiRetur...
\item[] 
\item[] values = \{0: PsiMod.PsiReturnType.Success, 1: PsiMod.PsiReturnType.Fai...
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Methods inherited from Boost.Python.enum:
\item[] 
\item[] \_\_repr\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_repr\_\_() \textless{}==\textgreater{} repr(x)
\item[] 
\end{DUlineblock}
\item[] \_\_str\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_str\_\_() \textless{}==\textgreater{} str(x)
\item[] 
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.enum:
\item[] 
\item[] name
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Methods inherited from \_\_builtin\_\_.int:
\item[] 
\item[] \_\_abs\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_abs\_\_() \textless{}==\textgreater{} abs(x)
\item[] 
\end{DUlineblock}
\item[] \_\_add\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_add\_\_(y) \textless{}==\textgreater{} x+y
\item[] 
\end{DUlineblock}
\item[] \_\_and\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_and\_\_(y) \textless{}==\textgreater{} x\&y
\item[] 
\end{DUlineblock}
\item[] \_\_cmp\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_cmp\_\_(y) \textless{}==\textgreater{} cmp(x,y)
\item[] 
\end{DUlineblock}
\item[] \_\_coerce\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_coerce\_\_(y) \textless{}==\textgreater{} coerce(x, y)
\item[] 
\end{DUlineblock}
\item[] \_\_div\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_div\_\_(y) \textless{}==\textgreater{} x/y
\item[] 
\end{DUlineblock}
\item[] \_\_divmod\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_divmod\_\_(y) \textless{}==\textgreater{} divmod(x, y)
\item[] 
\end{DUlineblock}
\item[] \_\_float\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_float\_\_() \textless{}==\textgreater{} float(x)
\item[] 
\end{DUlineblock}
\item[] \_\_floordiv\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_floordiv\_\_(y) \textless{}==\textgreater{} x//y
\item[] 
\end{DUlineblock}
\item[] \_\_format\_\_(...)
\item[] 
\item[] \_\_getattribute\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_getattribute\_\_(`name') \textless{}==\textgreater{} x.name
\item[] 
\end{DUlineblock}
\item[] \_\_getnewargs\_\_(...)
\item[] 
\item[] \_\_hash\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_hash\_\_() \textless{}==\textgreater{} hash(x)
\item[] 
\end{DUlineblock}
\item[] \_\_hex\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_hex\_\_() \textless{}==\textgreater{} hex(x)
\item[] 
\end{DUlineblock}
\item[] \_\_index\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x{[}y:z{]} \textless{}==\textgreater{} x{[}y.\_\_index\_\_():z.\_\_index\_\_(){]}
\item[] 
\end{DUlineblock}
\item[] \_\_int\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_int\_\_() \textless{}==\textgreater{} int(x)
\item[] 
\end{DUlineblock}
\item[] \_\_invert\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_invert\_\_() \textless{}==\textgreater{} \textasciitilde{}x
\item[] 
\end{DUlineblock}
\item[] \_\_long\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_long\_\_() \textless{}==\textgreater{} long(x)
\item[] 
\end{DUlineblock}
\item[] \_\_lshift\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_lshift\_\_(y) \textless{}==\textgreater{} x\textless{}\textless{}y
\item[] 
\end{DUlineblock}
\item[] \_\_mod\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_mod\_\_(y) \textless{}==\textgreater{} x\%y
\item[] 
\end{DUlineblock}
\item[] \_\_mul\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_mul\_\_(y) \textless{}==\textgreater{} x*y
\item[] 
\end{DUlineblock}
\item[] \_\_neg\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_neg\_\_() \textless{}==\textgreater{} -x
\item[] 
\end{DUlineblock}
\item[] \_\_nonzero\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_nonzero\_\_() \textless{}==\textgreater{} x != 0
\item[] 
\end{DUlineblock}
\item[] \_\_oct\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_oct\_\_() \textless{}==\textgreater{} oct(x)
\item[] 
\end{DUlineblock}
\item[] \_\_or\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_or\_\_(y) \textless{}==\textgreater{} x\textbar{}y
\item[] 
\end{DUlineblock}
\item[] \_\_pos\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_pos\_\_() \textless{}==\textgreater{} +x
\item[] 
\end{DUlineblock}
\item[] \_\_pow\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_pow\_\_(y{[}, z{]}) \textless{}==\textgreater{} pow(x, y{[}, z{]})
\item[] 
\end{DUlineblock}
\item[] \_\_radd\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_radd\_\_(y) \textless{}==\textgreater{} y+x
\item[] 
\end{DUlineblock}
\item[] \_\_rand\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_rand\_\_(y) \textless{}==\textgreater{} y\&x
\item[] 
\end{DUlineblock}
\item[] \_\_rdiv\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_rdiv\_\_(y) \textless{}==\textgreater{} y/x
\item[] 
\end{DUlineblock}
\item[] \_\_rdivmod\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_rdivmod\_\_(y) \textless{}==\textgreater{} divmod(y, x)
\item[] 
\end{DUlineblock}
\item[] \_\_rfloordiv\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_rfloordiv\_\_(y) \textless{}==\textgreater{} y//x
\item[] 
\end{DUlineblock}
\item[] \_\_rlshift\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_rlshift\_\_(y) \textless{}==\textgreater{} y\textless{}\textless{}x
\item[] 
\end{DUlineblock}
\item[] \_\_rmod\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_rmod\_\_(y) \textless{}==\textgreater{} y\%x
\item[] 
\end{DUlineblock}
\item[] \_\_rmul\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_rmul\_\_(y) \textless{}==\textgreater{} y*x
\item[] 
\end{DUlineblock}
\item[] \_\_ror\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_ror\_\_(y) \textless{}==\textgreater{} y\textbar{}x
\item[] 
\end{DUlineblock}
\item[] \_\_rpow\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] y.\_\_rpow\_\_(x{[}, z{]}) \textless{}==\textgreater{} pow(x, y{[}, z{]})
\item[] 
\end{DUlineblock}
\item[] \_\_rrshift\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_rrshift\_\_(y) \textless{}==\textgreater{} y\textgreater{}\textgreater{}x
\item[] 
\end{DUlineblock}
\item[] \_\_rshift\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_rshift\_\_(y) \textless{}==\textgreater{} x\textgreater{}\textgreater{}y
\item[] 
\end{DUlineblock}
\item[] \_\_rsub\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_rsub\_\_(y) \textless{}==\textgreater{} y-x
\item[] 
\end{DUlineblock}
\item[] \_\_rtruediv\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_rtruediv\_\_(y) \textless{}==\textgreater{} y/x
\item[] 
\end{DUlineblock}
\item[] \_\_rxor\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_rxor\_\_(y) \textless{}==\textgreater{} y\textasciicircum{}x
\item[] 
\end{DUlineblock}
\item[] \_\_sub\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_sub\_\_(y) \textless{}==\textgreater{} x-y
\item[] 
\end{DUlineblock}
\item[] \_\_truediv\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_truediv\_\_(y) \textless{}==\textgreater{} x/y
\item[] 
\end{DUlineblock}
\item[] \_\_trunc\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Truncating an Integral returns itself.
\item[] 
\end{DUlineblock}
\item[] \_\_xor\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x.\_\_xor\_\_(y) \textless{}==\textgreater{} x\textasciicircum{}y
\item[] 
\end{DUlineblock}
\item[] bit\_length(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] int.bit\_length() -\textgreater{} int
\item[] 
\item[] Number of bits necessary to represent self in binary.
\item[] \textgreater{}\textgreater{}\textgreater{} bin(37)
\item[] `0b100101'
\item[] \textgreater{}\textgreater{}\textgreater{} (37).bit\_length()
\item[] 6
\item[] 
\end{DUlineblock}
\item[] conjugate(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Returns self, the complex conjugate of any int.
\item[] 
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from \_\_builtin\_\_.int:
\item[] 
\item[] denominator
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] the denominator of a rational number in lowest terms
\item[] 
\end{DUlineblock}
\item[] imag
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] the imaginary part of a complex number
\item[] 
\end{DUlineblock}
\item[] numerator
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] the numerator of a rational number in lowest terms
\item[] 
\end{DUlineblock}
\item[] real
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] the real part of a complex number
\item[] 
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from \_\_builtin\_\_.int:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of type object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class RHF(HF, Wavefunction)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] RHF
\item[] HF
\item[] Wavefunction
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_init\_\_ = \textless{}built-in function \_\_init\_\_\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Raises an exception
\item[] This class cannot be instantiated from Python
\item[] 
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Methods inherited from Wavefunction:
\item[] 
\item[] Ca(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Ca( (Wavefunction)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] Cb(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Cb( (Wavefunction)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] Da(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Da( (Wavefunction)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] Db(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Db( (Wavefunction)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] Fa(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Fa( (Wavefunction)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] Fb(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Fb( (Wavefunction)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] add\_postiteration\_callback(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] add\_postiteration\_callback( (Wavefunction)arg1, (object)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] add\_preiteration\_callback(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] add\_preiteration\_callback( (Wavefunction)arg1, (object)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] basisset(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] basisset( (Wavefunction)arg1) -\textgreater{} BasisSet :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] energy(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] energy( (Wavefunction)arg1) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] epsilon\_a(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] epsilon\_a( (Wavefunction)arg1) -\textgreater{} Vector :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] epsilon\_b(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] epsilon\_b( (Wavefunction)arg1) -\textgreater{} Vector :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] frequencies(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] frequencies( (Wavefunction)arg1) -\textgreater{} Vector :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] gradient(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] gradient( (Wavefunction)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] nirrep(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] nirrep( (Wavefunction)arg1) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] nmo(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] nmo( (Wavefunction)arg1) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] nso(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] nso( (Wavefunction)arg1) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] sobasisset(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] sobasisset( (Wavefunction)arg1) -\textgreater{} SOBasisSet :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class SOBasisSet(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] SOBasisSet
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] petite\_list(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] petite\_list( (SOBasisSet)arg1) -\textgreater{} PetiteList :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_init\_\_ = \textless{}built-in function \_\_init\_\_\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Raises an exception
\item[] This class cannot be instantiated from Python
\item[] 
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class SuperFunctional(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] SuperFunctional
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_init\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_init\_\_( (object)arg1) -\textgreater{} None
\item[] 
\end{DUlineblock}
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] computeRKSFunctional(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] computeRKSFunctional( (SuperFunctional)arg1, (object)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] computeUKSFunctional(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] computeUKSFunctional( (SuperFunctional)arg1, (object)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get\_citation(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get\_citation( (SuperFunctional)arg1) -\textgreater{} str :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get\_composition(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get\_composition( (SuperFunctional)arg1) -\textgreater{} str :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get\_dash\_d(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get\_dash\_d( (SuperFunctional)arg1) -\textgreater{} object :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get\_deriv(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get\_deriv( (SuperFunctional)arg1) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get\_description(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get\_description( (SuperFunctional)arg1) -\textgreater{} str :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get\_exact\_exchange(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get\_exact\_exchange( (SuperFunctional)arg1) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get\_functional(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get\_functional( (SuperFunctional)arg1, (int)arg2) -\textgreater{} Functional :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get\_name(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get\_name( (SuperFunctional)arg1) -\textgreater{} str :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get\_npoints(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get\_npoints( (SuperFunctional)arg1) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get\_omega(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get\_omega( (SuperFunctional)arg1) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get\_pt2(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get\_pt2( (SuperFunctional)arg1) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get\_size(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get\_size( (SuperFunctional)arg1) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get\_weight(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get\_weight( (SuperFunctional)arg1, (int)arg2) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] is\_dash\_d(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] is\_dash\_d( (SuperFunctional)arg1) -\textgreater{} bool :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] is\_double\_hybrid(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] is\_double\_hybrid( (SuperFunctional)arg1) -\textgreater{} bool :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] is\_gga(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] is\_gga( (SuperFunctional)arg1) -\textgreater{} bool :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] is\_hybrid(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] is\_hybrid( (SuperFunctional)arg1) -\textgreater{} bool :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] is\_meta(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] is\_meta( (SuperFunctional)arg1) -\textgreater{} bool :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] is\_range\_corrected(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] is\_range\_corrected( (SuperFunctional)arg1) -\textgreater{} bool :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_citation(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_citation( (SuperFunctional)arg1, (str)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_dash\_d(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_dash\_d( (SuperFunctional)arg1, (object)arg2, (float)arg3) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_deriv(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_deriv( (SuperFunctional)arg1, (int)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_description(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_description( (SuperFunctional)arg1, (str)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_exact\_exchange(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_exact\_exchange( (SuperFunctional)arg1, (float)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_name(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_name( (SuperFunctional)arg1, (str)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_npoints(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_npoints( (SuperFunctional)arg1, (int)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_omega(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_omega( (SuperFunctional)arg1, (float)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_parameter(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_parameter( (SuperFunctional)arg1, (str)arg2, (str)arg3, (float)arg4) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_pt2(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_pt2( (SuperFunctional)arg1, (float)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set\_size(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set\_size( (SuperFunctional)arg1) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Static methods defined here:
\item[] 
\item[] available\_names(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] available\_names() -\textgreater{} object :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] available\_superfunctionals(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] available\_superfunctionals() -\textgreater{} str :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] build\_superfunctional(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] build\_superfunctional( (str)arg1, (int)arg2, (int)arg3) -\textgreater{} SuperFunctional :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] create\_superfunctional(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] create\_superfunctional( (str)arg1, (int)arg2, (int)arg3) -\textgreater{} SuperFunctional :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_instance\_size\_\_ = 32
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class SymmetryOperation(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] SymmetryOperation
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] E(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] E( (SymmetryOperation)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] \_\_init\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_init\_\_( (object)arg1) -\textgreater{} None
\item[] 
\item[] \_\_init\_\_( (object)arg1, (SymmetryOperation)arg2) -\textgreater{} None
\item[] 
\end{DUlineblock}
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] c2\_x(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] c2\_x( (SymmetryOperation)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] c2\_y(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] c2\_y( (SymmetryOperation)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] i(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] i( (SymmetryOperation)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] operate(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] operate( (SymmetryOperation)arg1, (SymmetryOperation)arg2) -\textgreater{} SymmetryOperation :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] rotate\_n(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] rotate\_n( (SymmetryOperation)arg1, (int)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] rotate\_theta(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] rotate\_theta( (SymmetryOperation)arg1, (float)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] sigma\_xy(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] sigma\_xy( (SymmetryOperation)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] sigma\_xz(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] sigma\_xz( (SymmetryOperation)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] sigma\_yz(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] sigma\_yz( (SymmetryOperation)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] trace(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] trace( (SymmetryOperation)arg1) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] transform(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] transform( (SymmetryOperation)arg1, (SymmetryOperation)arg2) -\textgreater{} SymmetryOperation :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] transpose(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] transpose( (SymmetryOperation)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] unit(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] unit( (SymmetryOperation)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] zero(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] zero( (SymmetryOperation)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_instance\_size\_\_ = 96
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class Vector(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Vector
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_getitem\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_getitem\_\_( (Vector)arg1, (int)arg2) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\item[] \_\_getitem\_\_( (Vector)arg1, (tuple)arg2) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] \_\_init\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_init\_\_( (object)arg1) -\textgreater{} None
\item[] 
\item[] \_\_init\_\_( (object)arg1, (int)arg2) -\textgreater{} None
\item[] 
\end{DUlineblock}
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] \_\_setitem\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_setitem\_\_( (Vector)arg1, (int)arg2, (float)arg3) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\item[] \_\_setitem\_\_( (Vector)arg1, (tuple)arg2, (float)arg3) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] dim(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] dim( (Vector)arg1, (int)arg2) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] get(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] get( (Vector)arg1, (int)arg2) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\item[] get( (Vector)arg1, (int)arg2, (int)arg3) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] nirrep(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] nirrep( (Vector)arg1) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] print\_out(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] print\_out( (Vector)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] scale(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] scale( (Vector)arg1, (float)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] set(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] set( (Vector)arg1, (int)arg2, (float)arg3) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\item[] set( (Vector)arg1, (int)arg2, (int)arg3, (float)arg4) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_instance\_size\_\_ = 32
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class Vector3(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Vector3
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_add\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_add\_\_( (Vector3)arg1, (Vector3)arg2) -\textgreater{} object
\item[] 
\end{DUlineblock}
\item[] \_\_getitem\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_getitem\_\_( (Vector3)arg1, (int)arg2) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] \_\_iadd\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_iadd\_\_( (object)arg1, (Vector3)arg2) -\textgreater{} object
\item[] 
\end{DUlineblock}
\item[] \_\_imul\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_imul\_\_( (object)arg1, (float)arg2) -\textgreater{} object
\item[] 
\end{DUlineblock}
\item[] \_\_init\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_init\_\_( (object)arg1) -\textgreater{} None
\item[] 
\item[] \_\_init\_\_( (object)arg1, (float)arg2) -\textgreater{} None
\item[] 
\item[] \_\_init\_\_( (object)arg1, (float)arg2, (float)arg3, (float)arg4) -\textgreater{} None
\item[] 
\item[] \_\_init\_\_( (object)arg1, (Vector3)arg2) -\textgreater{} None
\item[] 
\end{DUlineblock}
\item[] \_\_isub\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_isub\_\_( (object)arg1, (Vector3)arg2) -\textgreater{} object
\item[] 
\end{DUlineblock}
\item[] \_\_neg\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_neg\_\_( (Vector3)arg1) -\textgreater{} object
\item[] 
\end{DUlineblock}
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] \_\_str\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_str\_\_( (Vector3)arg1) -\textgreater{} str :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] \_\_sub\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_sub\_\_( (Vector3)arg1, (Vector3)arg2) -\textgreater{} object
\item[] 
\end{DUlineblock}
\item[] cross(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] cross( (Vector3)arg1, (Vector3)arg2) -\textgreater{} Vector3 :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] distance(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] distance( (Vector3)arg1, (Vector3)arg2) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] dot(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] dot( (Vector3)arg1, (Vector3)arg2) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] norm(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] norm( (Vector3)arg1) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] normalize(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] normalize( (Vector3)arg1) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_instance\_size\_\_ = 40
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class Wavefunction(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Wavefunction
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] Ca(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Ca( (Wavefunction)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] Cb(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Cb( (Wavefunction)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] Da(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Da( (Wavefunction)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] Db(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Db( (Wavefunction)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] Fa(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Fa( (Wavefunction)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] Fb(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Fb( (Wavefunction)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] add\_postiteration\_callback(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] add\_postiteration\_callback( (Wavefunction)arg1, (object)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] add\_preiteration\_callback(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] add\_preiteration\_callback( (Wavefunction)arg1, (object)arg2) -\textgreater{} None :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] basisset(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] basisset( (Wavefunction)arg1) -\textgreater{} BasisSet :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] energy(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] energy( (Wavefunction)arg1) -\textgreater{} float :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] epsilon\_a(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] epsilon\_a( (Wavefunction)arg1) -\textgreater{} Vector :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] epsilon\_b(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] epsilon\_b( (Wavefunction)arg1) -\textgreater{} Vector :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] frequencies(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] frequencies( (Wavefunction)arg1) -\textgreater{} Vector :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] gradient(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] gradient( (Wavefunction)arg1) -\textgreater{} Matrix :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] nirrep(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] nirrep( (Wavefunction)arg1) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] nmo(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] nmo( (Wavefunction)arg1) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] nso(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] nso( (Wavefunction)arg1) -\textgreater{} int :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] sobasisset(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] sobasisset( (Wavefunction)arg1) -\textgreater{} SOBasisSet :
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] docstring
\item[] 
\end{DUlineblock}
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_init\_\_ = \textless{}built-in function \_\_init\_\_\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Raises an exception
\item[] This class cannot be instantiated from Python
\item[] 
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\item[{class matrix\_vector(Boost.Python.instance)}] \leavevmode
\begin{DUlineblock}{0em}
\item[] docstring
\item[] 
\item[] Method resolution order:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] matrix\_vector
\item[] Boost.Python.instance
\item[] \_\_builtin\_\_.object
\item[] 
\end{DUlineblock}
\item[] Methods defined here:
\item[] 
\item[] \_\_contains\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_contains\_\_( (matrix\_vector)arg1, (object)arg2) -\textgreater{} bool
\item[] 
\end{DUlineblock}
\item[] \_\_delitem\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_delitem\_\_( (matrix\_vector)arg1, (object)arg2) -\textgreater{} None
\item[] 
\end{DUlineblock}
\item[] \_\_getitem\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_getitem\_\_( (object)arg1, (object)arg2) -\textgreater{} object
\item[] 
\end{DUlineblock}
\item[] \_\_init\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_init\_\_( (object)arg1) -\textgreater{} None
\item[] 
\end{DUlineblock}
\item[] \_\_iter\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_iter\_\_( (object)arg1) -\textgreater{} object
\item[] 
\end{DUlineblock}
\item[] \_\_len\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_len\_\_( (matrix\_vector)arg1) -\textgreater{} int
\item[] 
\end{DUlineblock}
\item[] \_\_reduce\_\_ = \textless{}unnamed Boost.Python function\textgreater{}(...)
\item[] 
\item[] \_\_setitem\_\_(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \_\_setitem\_\_( (matrix\_vector)arg1, (object)arg2, (object)arg3) -\textgreater{} None
\item[] 
\end{DUlineblock}
\item[] append(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] append( (matrix\_vector)arg1, (object)arg2) -\textgreater{} None
\item[] 
\end{DUlineblock}
\item[] extend(...)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] extend( (matrix\_vector)arg1, (object)arg2) -\textgreater{} None
\item[] 
\end{DUlineblock}
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes defined here:
\item[] 
\item[] \_\_instance\_size\_\_ = 40
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data descriptors inherited from Boost.Python.instance:
\item[] 
\item[] \_\_dict\_\_
\item[] 
\item[] \_\_weakref\_\_
\item[] 
\item[] ----------------------------------------------------------------------
\item[] Data and other attributes inherited from Boost.Python.instance:
\item[] 
\item[] \_\_new\_\_ = \textless{}built-in method \_\_new\_\_ of Boost.Python.class object\textgreater{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] T.\_\_new\_\_(S, ...) -\textgreater{} a new object with type S, a subtype of T
\end{DUlineblock}
\end{DUlineblock}

\end{description}

\item[{FUNCTIONS}] \leavevmode\begin{description}
\item[{DASUM(...)}] \leavevmode\begin{description}
\item[{DASUM( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -\textgreater{} float :}] \leavevmode
docstring

\end{description}

\item[{DAXPY(...)}] \leavevmode\begin{description}
\item[{DAXPY( (int)arg1, (int)arg2, (float)arg3, (Vector)arg4, (int)arg5, (Vector)arg6, (int)arg7) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{DCOPY(...)}] \leavevmode\begin{description}
\item[{DCOPY( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{DDOT(...)}] \leavevmode\begin{description}
\item[{DDOT( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -\textgreater{} float :}] \leavevmode
docstring

\end{description}

\item[{DGBMV(...)}] \leavevmode\begin{description}
\item[{DGBMV( (int)arg1, (str)arg2, (int)arg3, (int)arg4, (int)arg5, (int)arg6, (float)arg7, (Matrix)arg8, (int)arg9, (Vector)arg10, (int)arg11, (float)arg12, (Vector)arg13, (int)arg14) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{DGEEV(...)}] \leavevmode\begin{description}
\item[{DGEEV( (int)arg1, (str)arg2, (str)arg3, (int)arg4, (Matrix)arg5, (int)arg6, (Vector)arg7, (Vector)arg8, (Matrix)arg9, (int)arg10, (Matrix)arg11, (int)arg12, (Vector)arg13, (int)arg14) -\textgreater{} int :}] \leavevmode
docstring

\end{description}

\item[{DGEMM(...)}] \leavevmode\begin{description}
\item[{DGEMM( (int)arg1, (str)arg2, (str)arg3, (int)arg4, (int)arg5, (int)arg6, (float)arg7, (Matrix)arg8, (int)arg9, (Matrix)arg10, (int)arg11, (float)arg12, (Matrix)arg13, (int)arg14) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{DGEMV(...)}] \leavevmode\begin{description}
\item[{DGEMV( (int)arg1, (str)arg2, (int)arg3, (int)arg4, (float)arg5, (Matrix)arg6, (int)arg7, (Vector)arg8, (int)arg9, (float)arg10, (Vector)arg11, (int)arg12) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{DGER(...)}] \leavevmode\begin{description}
\item[{DGER( (int)arg1, (int)arg2, (int)arg3, (float)arg4, (Vector)arg5, (int)arg6, (Vector)arg7, (int)arg8, (Matrix)arg9, (int)arg10) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{DGETRF(...)}] \leavevmode\begin{description}
\item[{DGETRF( (int)arg1, (int)arg2, (int)arg3, (Matrix)arg4, (int)arg5, (IntVector)arg6) -\textgreater{} int :}] \leavevmode
docstring

\end{description}

\item[{DGETRI(...)}] \leavevmode\begin{description}
\item[{DGETRI( (int)arg1, (int)arg2, (Matrix)arg3, (int)arg4, (IntVector)arg5, (Vector)arg6, (int)arg7) -\textgreater{} int :}] \leavevmode
docstring

\end{description}

\item[{DGETRS(...)}] \leavevmode\begin{description}
\item[{DGETRS( (int)arg1, (str)arg2, (int)arg3, (int)arg4, (Matrix)arg5, (int)arg6, (IntVector)arg7, (Matrix)arg8, (int)arg9) -\textgreater{} int :}] \leavevmode
docstring

\end{description}

\item[{DNRM2(...)}] \leavevmode\begin{description}
\item[{DNRM2( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -\textgreater{} float :}] \leavevmode
docstring

\end{description}

\item[{DPOTRF(...)}] \leavevmode\begin{description}
\item[{DPOTRF( (int)arg1, (str)arg2, (int)arg3, (Matrix)arg4, (int)arg5) -\textgreater{} int :}] \leavevmode
docstring

\end{description}

\item[{DPOTRI(...)}] \leavevmode\begin{description}
\item[{DPOTRI( (int)arg1, (str)arg2, (int)arg3, (Matrix)arg4, (int)arg5) -\textgreater{} int :}] \leavevmode
docstring

\end{description}

\item[{DPOTRS(...)}] \leavevmode\begin{description}
\item[{DPOTRS( (int)arg1, (str)arg2, (int)arg3, (int)arg4, (Matrix)arg5, (int)arg6, (Matrix)arg7, (int)arg8) -\textgreater{} int :}] \leavevmode
docstring

\end{description}

\item[{DROT(...)}] \leavevmode\begin{description}
\item[{DROT( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6, (float)arg7, (float)arg8) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{DSBMV(...)}] \leavevmode\begin{description}
\item[{DSBMV( (int)arg1, (str)arg2, (int)arg3, (int)arg4, (float)arg5, (Matrix)arg6, (int)arg7, (Vector)arg8, (int)arg9, (float)arg10, (Vector)arg11, (int)arg12) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{DSCAL(...)}] \leavevmode\begin{description}
\item[{DSCAL( (int)arg1, (int)arg2, (float)arg3, (Vector)arg4, (int)arg5) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{DSWAP(...)}] \leavevmode\begin{description}
\item[{DSWAP( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{DSYEV(...)}] \leavevmode\begin{description}
\item[{DSYEV( (int)arg1, (str)arg2, (str)arg3, (int)arg4, (Matrix)arg5, (int)arg6, (Vector)arg7, (Vector)arg8, (int)arg9) -\textgreater{} int :}] \leavevmode
docstring

\end{description}

\item[{DSYMM(...)}] \leavevmode\begin{description}
\item[{DSYMM( (int)arg1, (str)arg2, (str)arg3, (int)arg4, (int)arg5, (float)arg6, (Matrix)arg7, (int)arg8, (Matrix)arg9, (int)arg10, (float)arg11, (Matrix)arg12, (int)arg13) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{DSYMV(...)}] \leavevmode\begin{description}
\item[{DSYMV( (int)arg1, (str)arg2, (int)arg3, (float)arg4, (Matrix)arg5, (int)arg6, (Vector)arg7, (int)arg8, (float)arg9, (Vector)arg10, (int)arg11) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{DSYR(...)}] \leavevmode\begin{description}
\item[{DSYR( (int)arg1, (str)arg2, (int)arg3, (float)arg4, (Vector)arg5, (int)arg6, (Matrix)arg7, (int)arg8) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{DSYR2(...)}] \leavevmode\begin{description}
\item[{DSYR2( (int)arg1, (str)arg2, (int)arg3, (float)arg4, (Vector)arg5, (int)arg6, (Vector)arg7, (int)arg8, (Matrix)arg9, (int)arg10) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{DSYR2K(...)}] \leavevmode\begin{description}
\item[{DSYR2K( (int)arg1, (str)arg2, (str)arg3, (int)arg4, (int)arg5, (float)arg6, (Matrix)arg7, (int)arg8, (Matrix)arg9, (int)arg10, (float)arg11, (Matrix)arg12, (int)arg13) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{DSYRK(...)}] \leavevmode\begin{description}
\item[{DSYRK( (int)arg1, (str)arg2, (str)arg3, (int)arg4, (int)arg5, (float)arg6, (Matrix)arg7, (int)arg8, (float)arg9, (Matrix)arg10, (int)arg11) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{DSYSV(...)}] \leavevmode\begin{description}
\item[{DSYSV( (int)arg1, (str)arg2, (int)arg3, (int)arg4, (Matrix)arg5, (int)arg6, (IntVector)arg7, (Matrix)arg8, (int)arg9, (Vector)arg10, (int)arg11) -\textgreater{} int :}] \leavevmode
docstring

\end{description}

\item[{DTBMV(...)}] \leavevmode\begin{description}
\item[{DTBMV( (int)arg1, (str)arg2, (str)arg3, (str)arg4, (int)arg5, (int)arg6, (Matrix)arg7, (int)arg8, (Vector)arg9, (int)arg10) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{DTBSV(...)}] \leavevmode\begin{description}
\item[{DTBSV( (int)arg1, (str)arg2, (str)arg3, (str)arg4, (int)arg5, (int)arg6, (Matrix)arg7, (int)arg8, (Vector)arg9, (int)arg10) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{DTRMM(...)}] \leavevmode\begin{description}
\item[{DTRMM( (int)arg1, (str)arg2, (str)arg3, (str)arg4, (str)arg5, (int)arg6, (int)arg7, (float)arg8, (Matrix)arg9, (int)arg10, (Matrix)arg11, (int)arg12) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{DTRMV(...)}] \leavevmode\begin{description}
\item[{DTRMV( (int)arg1, (str)arg2, (str)arg3, (str)arg4, (int)arg5, (Matrix)arg6, (int)arg7, (Vector)arg8, (int)arg9) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{DTRSM(...)}] \leavevmode\begin{description}
\item[{DTRSM( (int)arg1, (str)arg2, (str)arg3, (str)arg4, (str)arg5, (int)arg6, (int)arg7, (float)arg8, (Matrix)arg9, (int)arg10, (Matrix)arg11, (int)arg12) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{DTRSV(...)}] \leavevmode\begin{description}
\item[{DTRSV( (int)arg1, (str)arg2, (str)arg3, (str)arg4, (int)arg5, (Matrix)arg6, (int)arg7, (Vector)arg8, (int)arg9) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{IDAMAX(...)}] \leavevmode\begin{description}
\item[{IDAMAX( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -\textgreater{} int :}] \leavevmode
docstring

\end{description}

\item[{adc(...)}] \leavevmode\begin{description}
\item[{adc() -\textgreater{} float :}] \leavevmode
docstring

\end{description}

\item[{add\_user\_basis\_file(...)}] \leavevmode\begin{description}
\item[{add\_user\_basis\_file( (str)arg1) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{benchmark\_blas1(...)}] \leavevmode\begin{description}
\item[{benchmark\_blas1( (int)arg1, (float)arg2) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{benchmark\_blas2(...)}] \leavevmode\begin{description}
\item[{benchmark\_blas2( (int)arg1, (float)arg2) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{benchmark\_blas3(...)}] \leavevmode\begin{description}
\item[{benchmark\_blas3( (int)arg1, (float)arg2, (int)arg3) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{benchmark\_disk(...)}] \leavevmode\begin{description}
\item[{benchmark\_disk( (int)arg1, (float)arg2) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{benchmark\_integrals(...)}] \leavevmode\begin{description}
\item[{benchmark\_integrals( (int)arg1, (float)arg2) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{benchmark\_math(...)}] \leavevmode\begin{description}
\item[{benchmark\_math( (float)arg1) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{ccdensity(...)}] \leavevmode\begin{description}
\item[{ccdensity() -\textgreater{} float :}] \leavevmode
docstring

\end{description}

\item[{ccenergy(...)}] \leavevmode\begin{description}
\item[{ccenergy() -\textgreater{} float :}] \leavevmode
docstring

\end{description}

\item[{cceom(...)}] \leavevmode\begin{description}
\item[{cceom() -\textgreater{} float :}] \leavevmode
docstring

\end{description}

\item[{cchbar(...)}] \leavevmode\begin{description}
\item[{cchbar() -\textgreater{} float :}] \leavevmode
docstring

\end{description}

\item[{cclambda(...)}] \leavevmode\begin{description}
\item[{cclambda() -\textgreater{} float :}] \leavevmode
docstring

\end{description}

\item[{ccresponse(...)}] \leavevmode\begin{description}
\item[{ccresponse() -\textgreater{} float :}] \leavevmode
docstring

\end{description}

\item[{ccsort(...)}] \leavevmode\begin{description}
\item[{ccsort() -\textgreater{} float :}] \leavevmode
docstring

\end{description}

\item[{cctriples(...)}] \leavevmode\begin{description}
\item[{cctriples() -\textgreater{} float :}] \leavevmode
docstring

\end{description}

\item[{clean(...)}] \leavevmode\begin{description}
\item[{clean() -\textgreater{} None :}] \leavevmode
Function to remove scratch files. Call between independent jobs.

\end{description}

\item[{close\_outfile(...)}] \leavevmode\begin{description}
\item[{close\_outfile() -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{dcft(...)}] \leavevmode\begin{description}
\item[{dcft() -\textgreater{} float :}] \leavevmode
docstring

\end{description}

\item[{deriv(...)}] \leavevmode\begin{description}
\item[{deriv() -\textgreater{} int :}] \leavevmode
docstring

\end{description}

\item[{detci(...)}] \leavevmode\begin{description}
\item[{detci() -\textgreater{} float :}] \leavevmode
docstring

\end{description}

\item[{dfcc(...)}] \leavevmode\begin{description}
\item[{dfcc() -\textgreater{} float :}] \leavevmode
docstring

\end{description}

\item[{dfmp2(...)}] \leavevmode\begin{description}
\item[{dfmp2() -\textgreater{} float :}] \leavevmode
docstring

\end{description}

\item[{fd\_1\_0(...)}] \leavevmode\begin{description}
\item[{fd\_1\_0( (list)arg1) -\textgreater{} PsiReturnType :}] \leavevmode
docstring

\end{description}

\item[{fd\_freq\_0(...)}] \leavevmode\begin{description}
\item[{fd\_freq\_0( (list)arg1, (int)arg2) -\textgreater{} PsiReturnType :}] \leavevmode
docstring

\end{description}

\item[{fd\_freq\_1(...)}] \leavevmode\begin{description}
\item[{fd\_freq\_1( (list)arg1, (int)arg2) -\textgreater{} PsiReturnType :}] \leavevmode
docstring

\end{description}

\item[{fd\_geoms\_1\_0(...)}] \leavevmode\begin{description}
\item[{fd\_geoms\_1\_0() -\textgreater{} matrix\_vector :}] \leavevmode
docstring

\end{description}

\item[{fd\_geoms\_freq\_0(...)}] \leavevmode\begin{description}
\item[{fd\_geoms\_freq\_0( (int)arg1) -\textgreater{} matrix\_vector :}] \leavevmode
docstring

\end{description}

\item[{fd\_geoms\_freq\_1(...)}] \leavevmode\begin{description}
\item[{fd\_geoms\_freq\_1( (int)arg1) -\textgreater{} matrix\_vector :}] \leavevmode
docstring

\end{description}

\item[{fd\_geoms\_hessian\_0(...)}] \leavevmode\begin{description}
\item[{fd\_geoms\_hessian\_0() -\textgreater{} matrix\_vector :}] \leavevmode
docstring

\end{description}

\item[{fd\_hessian\_0(...)}] \leavevmode\begin{description}
\item[{fd\_hessian\_0( (list)arg1) -\textgreater{} PsiReturnType :}] \leavevmode
docstring

\end{description}

\item[{flush\_outfile(...)}] \leavevmode\begin{description}
\item[{flush\_outfile() -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{get\_active\_molecule(...)}] \leavevmode\begin{description}
\item[{get\_active\_molecule() -\textgreater{} Molecule :}] \leavevmode
docstring

\end{description}

\item[{get\_global\_option(...)}] \leavevmode\begin{description}
\item[{get\_global\_option( (str)arg1) -\textgreater{} object :}] \leavevmode
docstring

\end{description}

\item[{get\_global\_option\_list(...)}] \leavevmode\begin{description}
\item[{get\_global\_option\_list() -\textgreater{} list :}] \leavevmode
docstring

\end{description}

\item[{get\_gradient(...)}] \leavevmode\begin{description}
\item[{get\_gradient() -\textgreater{} Matrix :}] \leavevmode
docstring

\end{description}

\item[{get\_input\_directory(...)}] \leavevmode\begin{description}
\item[{get\_input\_directory() -\textgreater{} str :}] \leavevmode
docstring

\end{description}

\item[{get\_local\_option(...)}] \leavevmode\begin{description}
\item[{get\_local\_option( (str)arg1, (str)arg2) -\textgreater{} object :}] \leavevmode
docstring

\end{description}

\item[{get\_memory(...)}] \leavevmode\begin{description}
\item[{get\_memory() -\textgreater{} int :}] \leavevmode
docstring

\end{description}

\item[{get\_option(...)}] \leavevmode\begin{description}
\item[{get\_option( (str)arg1) -\textgreater{} object :}] \leavevmode
docstring

\end{description}

\item[{get\_variable(...)}] \leavevmode\begin{description}
\item[{get\_variable( (str)arg1) -\textgreater{} float :}] \leavevmode
docstring

\end{description}

\item[{has\_global\_option\_changed(...)}] \leavevmode\begin{description}
\item[{has\_global\_option\_changed( (str)arg1) -\textgreater{} bool :}] \leavevmode
docstring

\end{description}

\item[{has\_local\_option\_changed(...)}] \leavevmode\begin{description}
\item[{has\_local\_option\_changed( (str)arg1, (str)arg2) -\textgreater{} bool :}] \leavevmode
docstring

\end{description}

\item[{has\_option\_changed(...)}] \leavevmode\begin{description}
\item[{has\_option\_changed( (str)arg1) -\textgreater{} bool :}] \leavevmode
docstring

\end{description}

\item[{libfock(...)}] \leavevmode\begin{description}
\item[{libfock() -\textgreater{} int :}] \leavevmode
docstring

\end{description}

\item[{lmp2(...)}] \leavevmode\begin{description}
\item[{lmp2() -\textgreater{} float :}] \leavevmode
docstring

\end{description}

\item[{mcscf(...)}] \leavevmode\begin{description}
\item[{mcscf() -\textgreater{} float :}] \leavevmode
docstring

\end{description}

\item[{me(...)}] \leavevmode\begin{description}
\item[{me() -\textgreater{} int :}] \leavevmode
docstring

\end{description}

\item[{mints(...)}] \leavevmode\begin{description}
\item[{mints() -\textgreater{} int :}] \leavevmode
docstring

\end{description}

\item[{mp2(...)}] \leavevmode\begin{description}
\item[{mp2() -\textgreater{} float :}] \leavevmode
docstring

\end{description}

\item[{mrcc\_generate\_input(...)}] \leavevmode\begin{description}
\item[{mrcc\_generate\_input( (dict)arg1) -\textgreater{} PsiReturnType :}] \leavevmode
docstring

\end{description}

\item[{mrcc\_load\_densities(...)}] \leavevmode\begin{description}
\item[{mrcc\_load\_densities( (dict)arg1) -\textgreater{} PsiReturnType :}] \leavevmode
docstring

\end{description}

\item[{nproc(...)}] \leavevmode\begin{description}
\item[{nproc() -\textgreater{} int :}] \leavevmode
docstring

\end{description}

\item[{nthread(...)}] \leavevmode\begin{description}
\item[{nthread() -\textgreater{} int :}] \leavevmode
docstring

\end{description}

\item[{nuclear\_dipole(...)}] \leavevmode\begin{description}
\item[{nuclear\_dipole( (Molecule)arg1) -\textgreater{} Vector :}] \leavevmode
docstring

\end{description}

\item[{omp2(...)}] \leavevmode\begin{description}
\item[{omp2() -\textgreater{} int :}] \leavevmode
docstring

\end{description}

\item[{opt\_clean(...)}] \leavevmode\begin{description}
\item[{opt\_clean() -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{optking(...)}] \leavevmode\begin{description}
\item[{optking() -\textgreater{} int :}] \leavevmode
docstring

\end{description}

\item[{outfile\_name(...)}] \leavevmode\begin{description}
\item[{outfile\_name() -\textgreater{} str :}] \leavevmode
docstring

\end{description}

\item[{plugin(...)}] \leavevmode\begin{description}
\item[{plugin( (str)arg1) -\textgreater{} int :}] \leavevmode
docstring

\end{description}

\item[{plugin\_close(...)}] \leavevmode\begin{description}
\item[{plugin\_close( (str)arg1) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{plugin\_close\_all(...)}] \leavevmode\begin{description}
\item[{plugin\_close\_all() -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{plugin\_load(...)}] \leavevmode\begin{description}
\item[{plugin\_load( (str)arg1) -\textgreater{} int :}] \leavevmode
docstring

\end{description}

\item[{prepare\_options\_for\_module(...)}] \leavevmode\begin{description}
\item[{prepare\_options\_for\_module( (str)arg1) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{print\_global\_options(...)}] \leavevmode\begin{description}
\item[{print\_global\_options() -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{print\_options(...)}] \leavevmode\begin{description}
\item[{print\_options() -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{print\_out(...)}] \leavevmode\begin{description}
\item[{print\_out( (str)arg1) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{print\_variables(...)}] \leavevmode\begin{description}
\item[{print\_variables() -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{psi\_top\_srcdir(...)}] \leavevmode\begin{description}
\item[{psi\_top\_srcdir() -\textgreater{} str :}] \leavevmode
docstring

\end{description}

\item[{psimrcc(...)}] \leavevmode\begin{description}
\item[{psimrcc() -\textgreater{} float :}] \leavevmode
docstring

\end{description}

\item[{reference\_wavefunction(...)}] \leavevmode\begin{description}
\item[{reference\_wavefunction() -\textgreater{} Wavefunction :}] \leavevmode
docstring

\end{description}

\item[{reopen\_outfile(...)}] \leavevmode\begin{description}
\item[{reopen\_outfile() -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{revoke\_global\_option\_changed(...)}] \leavevmode\begin{description}
\item[{revoke\_global\_option\_changed( (str)arg1) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{revoke\_local\_option\_changed(...)}] \leavevmode\begin{description}
\item[{revoke\_local\_option\_changed( (str)arg1, (str)arg2) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{revoke\_option\_changed(...)}] \leavevmode\begin{description}
\item[{revoke\_option\_changed( (str)arg1) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{sapt(...)}] \leavevmode\begin{description}
\item[{sapt() -\textgreater{} float :}] \leavevmode
docstring

\end{description}

\item[{scf(...)}] \leavevmode\begin{description}
\item[{scf( (object)arg1, (object)arg2) -\textgreater{} float :}] \leavevmode
docstring

\item[{scf() -\textgreater{} float :}] \leavevmode
docstring

\end{description}

\item[{set\_active\_molecule(...)}] \leavevmode\begin{description}
\item[{set\_active\_molecule( (Molecule)arg1) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{set\_global\_option(...)}] \leavevmode\begin{description}
\item[{set\_global\_option( (str)arg1, (str)arg2) -\textgreater{} bool :}] \leavevmode
docstring

\item[{set\_global\_option( (str)arg1, (float)arg2) -\textgreater{} bool :}] \leavevmode
docstring

\item[{set\_global\_option( (str)arg1, (int)arg2) -\textgreater{} bool :}] \leavevmode
docstring

\end{description}

set\_global\_option( (str)arg1, (list)arg2 {[}, (object)arg3{]}) -\textgreater{} bool

\item[{set\_global\_option\_python(...)}] \leavevmode\begin{description}
\item[{set\_global\_option\_python( (str)arg1, (object)arg2) -\textgreater{} bool :}] \leavevmode
docstring

\end{description}

\item[{set\_gradient(...)}] \leavevmode\begin{description}
\item[{set\_gradient( (Matrix)arg1) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{set\_local\_option(...)}] \leavevmode\begin{description}
\item[{set\_local\_option( (str)arg1, (str)arg2, (str)arg3) -\textgreater{} bool :}] \leavevmode
docstring

\item[{set\_local\_option( (str)arg1, (str)arg2, (float)arg3) -\textgreater{} bool :}] \leavevmode
docstring

\item[{set\_local\_option( (str)arg1, (str)arg2, (int)arg3) -\textgreater{} bool :}] \leavevmode
docstring

\end{description}

set\_local\_option( (str)arg1, (str)arg2, (list)arg3 {[}, (object)arg4{]}) -\textgreater{} bool

\item[{set\_local\_option\_python(...)}] \leavevmode\begin{description}
\item[{set\_local\_option\_python( (str)arg1, (object)arg2) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{set\_memory(...)}] \leavevmode\begin{description}
\item[{set\_memory( (int)arg1) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{set\_nthread(...)}] \leavevmode\begin{description}
\item[{set\_nthread( (int)arg1) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{set\_variable(...)}] \leavevmode\begin{description}
\item[{set\_variable( (str)arg1, (float)arg2) -\textgreater{} None :}] \leavevmode
docstring

\end{description}

\item[{transqt(...)}] \leavevmode\begin{description}
\item[{transqt() -\textgreater{} float :}] \leavevmode
docstring

\end{description}

\item[{transqt2(...)}] \leavevmode\begin{description}
\item[{transqt2() -\textgreater{} float :}] \leavevmode
docstring

\end{description}

\item[{version(...)}] \leavevmode\begin{description}
\item[{version() -\textgreater{} str :}] \leavevmode
docstring

\end{description}

\end{description}

\item[{DATA}] \leavevmode
Ascending = PsiMod.DiagonalizeOrder.Ascending
Balk = PsiMod.PsiReturnType.Balk
Descending = PsiMod.DiagonalizeOrder.Descending
EndLoop = PsiMod.PsiReturnType.EndLoop
Failure = PsiMod.PsiReturnType.Failure
Success = PsiMod.PsiReturnType.Success

\end{description}

\begin{notice}{warning}{Warning:}
Python naming practices of file\_that\_includes\_function.function\_name()
are followed below. In psi4 input files, it is only necessary to call the
function name alone. That is, use \code{energy('scf')}, not \code{driver.energy('scf')}.
\end{notice}

\begin{notice}{note}{Note:}
The options documented below are placed as arguments in the command that
calls the Python function, not in the \code{set globals} block or with any
other \code{set} command.
\end{notice}

\begin{notice}{note}{Note:}
Psithon keyword names and values are insensitive to case. The few
exceptions are documented for the \code{database()} function, where case
structure must match the database file.
\end{notice}
\phantomsection\label{notes:bool}\phantomsection\label{notes:boolean}
\begin{notice}{note}{Note:}
Boolean arguments can be specified by \code{yes}, \code{on}, \code{true}, or \code{1}
for affirmative and \code{no}, \code{off}, \code{false}, or \code{0} for negative,
all insensitive to case.
\end{notice}
\phantomsection\label{notes:conv-double}
\begin{notice}{note}{Note:}
Certain convergence and tolerance keywords, of type \emph{double} (real numbers), may be specified using either a real numberor an integer; an integer \emph{X} is then treated as the number of converged decimal digits required. For example, to request an energy converged to $10^{-6} E_h$, the user may set the \code{e\_convergence} keyword to 0.000001, 1.0e-6, or 6.
\end{notice}
\phantomsection\label{notes:dertype-string}
\begin{notice}{note}{Note:}
The derivative level type for {\hyperref[notes:driver.optimize]{\code{driver.optimize()}}} and {\hyperref[notes:driver.frequency]{\code{driver.frequency()}}}
functions can be specified by \code{energy}, \code{none}, or \code{0} for 0th derivative,
\code{gradient}, \code{first}, or \code{1} for 1st derivative, and \code{hessian},
\code{second}, or \code{2} for 2nd derivative.
\end{notice}

\begin{notice}{note}{Note:}
The derivative level type for {\hyperref[opt:driver.optimize]{\code{driver.optimize()}}} and {\hyperref[opt:driver.frequency]{\code{driver.frequency()}}}
functions can be specified by \code{energy}, \code{none}, or \code{0} for 0th derivative,
\code{gradient}, \code{first}, or \code{1} for 1st derivative, and \code{hessian},
\code{second}, or \code{2} for 2nd derivative.
\end{notice}
\index{optimize() (in module driver)}

\begin{fulllineitems}
\phantomsection\label{opt:driver.optimize}\pysiglinewithargsret{\code{driver.}\bfcode{optimize}}{\emph{name}, \emph{**kwargs}}{}
Function to perform a geometry optimization.
\begin{quote}\begin{description}
\item[{Aliases }] \leavevmode
opt()

\item[{Returns}] \leavevmode
(\emph{float}) Total electronic energy of optimized structure in Hartrees.

\item[{Psi variables}] \leavevmode
\end{description}\end{quote}
\index{environment variable!CURRENTENERGY}

\begin{fulllineitems}
\phantomsection\label{opt:envvar-CURRENTENERGY}\pysigline{\bfcode{CURRENT~ENERGY}}
\end{fulllineitems}


\begin{notice}{note}{Note:}
Analytic gradients area available for all methods in the table
below. Optimizations with other methods in the energy table proceed
by finite differences.
\end{notice}

\begin{notice}{caution}{Caution:}
Some features are not yet implemented. Buy a developer a coffee.
\begin{itemize}
\item {} 
Need to check that all methods do return electronic energy. I think gradient got changed at one point.

\end{itemize}
\end{notice}

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{
name
} & \textbf{
calls method
}\\\hline

scf
 & 
Hartree--Fock (HF) or density functional theory (DFT)
\\\hline

mp2
 & 
2nd-order Moller-Plesset perturbation theory (MP2)
\\\hline

ccsd
 & 
coupled cluster singles and doubles (CCSD)
\\\hline

ccsd(t)
 & 
CCSD with perturbative triples
\\\hline

eom-ccsd
 & 
equation of motion (EOM) CCSD
\\\hline
\end{tabulary}

\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{name} (\emph{string}) -- 
\code{'scf'} \textbar{}\textbar{} \code{'df-mp2'} \textbar{}\textbar{} \code{'ci5'} \textbar{}\textbar{} etc.

First argument, usually unlabeled. Indicates the computational method
to be applied to the database. May be any valid argument to
{\hyperref[opt:driver.energy]{\code{driver.energy()}}}.


\item {} 
\textbf{func} (\emph{function}) -- 
{\color{red}\bfseries{}\textbar{}dl\textbar{}} \code{gradient} {\color{red}\bfseries{}\textbar{}dr\textbar{}} \textbar{}\textbar{} \code{energy} \textbar{}\textbar{} \code{cbs}

Indicates the type of calculation to be performed on the molecule.
The default dertype accesses{}`{}`'gradient'{}`{}` or \code{'energy'}, while
\code{'cbs'} performs a multistage finite difference calculation.
If a nested series of python functions is intended (see {\color{red}\bfseries{}{}`Function Intercalls{}`\_}),
use keyword \code{opt\_func} instead of \code{func}.


\item {} 
\textbf{mode} (\emph{string}) -- 
{\color{red}\bfseries{}\textbar{}dl\textbar{}} \code{'continuous'} {\color{red}\bfseries{}\textbar{}dr\textbar{}} \textbar{}\textbar{} \code{'sow'} \textbar{}\textbar{} \code{'reap'}

For a finite difference of energies optimization, indicates whether
the calculations required to complete the
optimization are to be run in one file (\code{'continuous'}) or are to be
farmed out in an embarrassingly parallel fashion
(\code{'sow'}/\code{'reap'}).  For the latter, run an initial job with
\code{'sow'} and follow instructions in its output file.


\item {} 
\textbf{dertype} (\emph{dertype}) -- 
\code{'gradient'} \textbar{}\textbar{} \code{'energy'}

Indicates whether analytic (if available) or finite difference
optimization is to be performed.


\end{itemize}

\item[{Examples }] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [1] Analytic scf optimization}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{optimize}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{scf}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [2] Finite difference mp3 optimization}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{opt}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp3}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [3] Forced finite difference ccsd optimization}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{optimize}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{ccsd}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{dertype}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}


Many of the tasks automated by Python wrappers consist of a number of
independent psi4 calculations and are thus suited to an embarrassingly
parallel mode of operation. In Psithon, these have been dubbed sow/reap
procedures and have the following general structure.
\begin{itemize}
\item {} 
Prepare an input file, simply adding \code{mode='sow'} to the
argument list of an available Python function. Run this quick job to
produce input files for lengthier calculations.

\item {} 
According to the instructions in the output file of the above step,
run the generated input files in any order on any variety of computers
and architectures. This is the time-intensive portion of the
calculation.

\item {} 
The `sow' stage also produces a \emph{master} input file (with a
\code{mode='reap'} directive). When all the jobs in the above step are
completed, place their output files in the same location as the
\emph{master} input, and run this last, quick job to collect the results.

\end{itemize}
\begin{itemize}
\item {} 
Sow/reap procedures are governed by the \textbf{mode} keyword, choices being
\code{'continuous'}, \code{'sow'}, and \code{'reap'}. Only \code{'sow'} is likely to
be used by the user, as \code{'continuous'} is always the default, and
input files with \code{'reap'} are autogenerated.

\item {} 
Available at present for {\color{red}\bfseries{}{}`Database{}`\_} and finite difference operation of {\color{red}\bfseries{}{}`Optimize{}`\_}.

\end{itemize}

\begin{notice}{caution}{Caution:}
Some features are not yet implemented. Buy a developer a coffee.
\begin{itemize}
\item {} 
Local options (e.g., \code{set scf e\_convergence 9}) will not get transmitted to the child jobs.

\item {} 
Array options (e.g., \code{set states\_per\_irrep {[}2, 1{]}}) will not get transmitted to the child jobs.

\item {} 
Function intercalls (e.g., db(opt())) are not tested with sow/reap procedures.

\end{itemize}
\end{notice}

\includegraphics[width=1.000\linewidth]{PSI4_3.png}


\chapter{General}
\label{index::doc}\label{index:general}
To allow arbitrarily complex computations to be performed, PSI4 is built
upon the Python interpreter, with modifications termed Psithon. Chapter 3
of the User's Manual describes the non-standard Python associated with
clean molecule, basis, and option specification in the PSI4 input file.
This documentation addresses the pure Python side- what functions allow
the efficient compiled code to be run, what functions post-process and
interact with that output, and how the ordinary (or ambitious) user can
extent PSI4's functionality.

\begin{notice}{warning}{Warning:}
Python naming practices of file\_that\_includes\_function.function\_name()
are followed below. In psi4 input files, it is only necessary to call the
function name alone. That is, use \code{energy('scf')}, not \code{driver.energy('scf')}.
\end{notice}

\begin{notice}{note}{Note:}
The options documented below are placed as arguments in the command that
calls the Python function, not in the \code{set globals} block or with any
other \code{set} command.
\end{notice}

\begin{notice}{note}{Note:}
Psithon keyword names and values are insensitive to case. The few
exceptions are documented for the \code{database()} function, where case
structure must match the database file.
\end{notice}
\phantomsection\label{index:bool}\phantomsection\label{index:boolean}
\begin{notice}{note}{Note:}
Boolean arguments can be specified by \code{yes}, \code{on}, \code{true}, or \code{1}
for affirmative and \code{no}, \code{off}, \code{false}, or \code{0} for negative,
all insensitive to case.
\end{notice}
\phantomsection\label{index:conv-double}
\begin{notice}{note}{Note:}
Certain convergence and tolerance keywords, of type \emph{double} (real numbers), may be specified using either a real numberor an integer; an integer \emph{X} is then treated as the number of converged decimal digits required. For example, to request an energy converged to $10^{-6} E_h$, the user may set the \code{e\_convergence} keyword to 0.000001, 1.0e-6, or 6.
\end{notice}
\phantomsection\label{index:dertype-string}
\begin{notice}{note}{Note:}
The derivative level type for {\hyperref[index:driver.optimize]{\code{driver.optimize()}}} and {\hyperref[index:driver.frequency]{\code{driver.frequency()}}}
functions can be specified by \code{energy}, \code{none}, or \code{0} for 0th derivative,
\code{gradient}, \code{first}, or \code{1} for 1st derivative, and \code{hessian},
\code{second}, or \code{2} for 2nd derivative.
\end{notice}


\chapter{Symmetry-Adapted Perturbation Theory}
\label{index:symmetry-adapted-perturbation-theory}
Symmetry-adapted perturbation theory (SAPT) provides a means of directly
computing the noncovalent interaction between two molecules, that is, the
interaction energy is determined without computing the total energy of the
monomers or dimer. In addition, SAPT provides a decomposition of the
interaction energy into physically meaningful components: \emph{i.e.,}
electrostatic, exchange, induction, and dispersion terms. In SAPT, the
Hamiltonian of the dimer is partitioned into contributions from each
monomer and the interaction.
\begin{gather}
\begin{split}H=F_A+W_A+F_B+W_B+V\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
Here, the Hamiltonian is written as a sum of the usual monomer Fock
operators, $F$, the fluctuation potential of each monomer, $W$, and the
interaction potential, $V$. The monomer Fock operators, $F_A+F_B$, are
treated as the zeroth-order Hamiltonian and the interaction energy is
evaluated through a perturbative expansion of $V$, $W_A$, and $W_B$.
Through first-order in $V$, electrostatic and exchange interactions are
included; induction and dispersion first appear at second-order in $V$. For
a complete description of SAPT, the reader is referred to the excellent
review by Jeziorski, Moszynski, and Szalewicz {[}Jeziorski:1994:1887{]}.

Several truncations of the SAPT expansion are available in the SAPT
module of PSI4. The simplest truncation of SAPT is denoted SAPT0.
\phantomsection\label{index:eqn-sapt0}\begin{gather}
\begin{split}E_{SAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +
E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + E_{exch-disp}^{(20)}\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
In this notation, $E^{(vw)}$ defines the order in $V$ and in $W_A+W_B$; the
subscript, $resp$, indicates that orbital relaxation effects are included.
\phantomsection\label{index:eqn-sapt2}\begin{gather}
\begin{split}E_{SAPT2} = E_{SAPT0} + E_{elst,resp}^{(12)} + E_{exch}^{(11)} +
E_{exch}^{(12)} +\/ ^{t}\!E_{ind}^{(22)} +\/ ^{t}\!E_{exch-ind}^{(22)}\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}\phantomsection\label{index:id2}\begin{gather}
\begin{split}E_{SAPT2+} = E_{SAPT2} + E_{disp}^{(21)} + E_{disp}^{(22)}\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}\phantomsection\label{index:eqn-sapt2-p3}\begin{gather}
\begin{split}E_{SAPT2+(3)} = E_{SAPT2+} + E_{elst,resp}^{(13)} + E_{disp}^{(30)}\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}\phantomsection\label{index:eqn-sapt2-3}\begin{gather}
\begin{split}E_{SAPT2+3} = E_{SAPT2+(3)}
+ E_{exch-disp}^{(30)} + E_{ind-disp}^{(30)} + E_{exch-ind-disp}^{(30)}\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
A thorough analysis of the performance of these truncations of SAPT can be
found in a review by Hohenstein and Sherrill {[}Hohenstein:2012:WIREs{]}.

The SAPT module relies entirely on the density-fitting approximation
of the two-electron integrals. The factorization of the SAPT energy
expressions, as implemented in PSI4, assumes the use of density-fitted
two-electron integrals, therefore, the SAPT module cannot be run with
exact integrals. In practice, we have found that the density-fitting
approximation introduces negligable errors into the SAPT energy and greatly
improves efficiency.


\section{A First Example}
\label{index:a-first-example}
The following is the simplest possible input that will perform all
available SAPT computations (normally, you would pick one of these methods).

\begin{Verbatim}[commandchars=\\\{\}]
molecule water\_dimer \PYGZob{}
     0 1
     O  -1.551007  -0.114520   0.000000
     H  -1.934259   0.762503   0.000000
     H  -0.599677   0.040712   0.000000
     --
     0 1
     O   1.350625   0.111469   0.000000
     H   1.680398  -0.373741  -0.758561
     H   1.680398  -0.373741   0.758561

     units angstrom
     no\_reorient
     symmetry c1
\PYGZcb{}

set globals \PYGZob{}
    basis         aug-cc-pvdz
\PYGZcb{}

energy('sapt0')
energy('sapt2')
energy('sapt2+')
energy('sapt2+(3)')
energy('sapt2+3')
\end{Verbatim}

The SAPT module uses the standard PSI4 partitioning of the dimer
into monomers. Additionally, the \code{no\_reorient} flag must be included
and the use of spatial symmetry disabled by setting the molecule option
\code{symmetry c1}. A final note is that the SAPT module is only
capable of performing SAPT comuptations for interactions between closed-shell
singlets.

The example input shown above would not be used in practice.
To exploit the efficiency of the density-fitted SAPT implementation in
PSI4, the SCF computations should also be performed with density-fitted
(DF) integrals.

\begin{Verbatim}[commandchars=\\\{\}]
set globals \PYGZob{}
    basis         aug-cc-pvdz
    df\_basis\_scf  aug-cc-pvdz-jkfit
    df\_basis\_sapt aug-cc-pvdz-ri
    guess         sad
    scf\_type      df
\PYGZcb{}

set sapt \PYGZob{}
    print         1
\PYGZcb{}
\end{Verbatim}

These options will perform the SAPT computation with DF-HF and a
superposition-of-atomic-densities guess. This is the preferred method of
running the SAPT module.


\section{SAPT0}
\label{index:sapt0}
Generally speaking, SAPT0 should be applied to large systems or large data
sets. The performance of SAPT0 relies entirely on error cancellation, which
seems to be optimal with a truncated aug-cc-pVDZ basis, namely,
jun-cc-pVDZ (which we have referred to in previous work as
aug-cc-pVDZ').
The SAPT module has been used to perform SAPT0 computations with over
200 atoms and 2800 basis functions; this code should be scalable to 4000
basis functions. Publications resulting from the use of the SAPT0 code
should cite the following publications: {[}Hohenstein:2010:184111{]} and
{[}Hohenstein:2011:174107{]}.


\subsection{Basic SAPT0 Keywords}
\label{index:basic-sapt0-keywords}\begin{description}
\item[{\index{SAPT\_LEVEL|textbf}SAPT\_LEVEL}] \leavevmode\phantomsection\label{index:term-sapt-level}
The level of theory for SAPT.
\begin{itemize}
\item {} 
\textbf{Type}: string

\item {} 
\textbf{Possible Values}: SAPT0, SAPT2, SAPT2+, SAPT2+3

\item {} 
\textbf{Default}: SAPT0

\end{itemize}

\end{description}
\begin{description}
\item[{\index{BASIS|textbf}BASIS}] \leavevmode\phantomsection\label{index:term-basis}
The basis set used to describe the monomer molecular orbitals.
\begin{itemize}
\item {} 
\textbf{Type}: string

\item {} 
\textbf{Possible Values}: \href{http://sirius.chem.vt.edu/trac/wiki/InstalledBasisSets}{Basis Sets}

\item {} 
\textbf{Default}: none

\end{itemize}

\end{description}
\begin{description}
\item[{\index{DF\_BASIS\_SAPT|textbf}DF\_BASIS\_SAPT}] \leavevmode\phantomsection\label{index:term-df-basis-sapt}
The fitting basis to use for all two-electron integrals
in the SAPT computation. PSI4 will attempt to pick
a reasonable fitting basis if one is not provided.
\begin{itemize}
\item {} 
\textbf{Type}: string

\item {} 
\textbf{Default}: none

\end{itemize}

\end{description}
\begin{description}
\item[{\index{DF\_BASIS\_ELST|textbf}DF\_BASIS\_ELST}] \leavevmode\phantomsection\label{index:term-df-basis-elst}
Optionally, a different fitting basis can be used for the
$E_{elst}^{(10)}$ and $E_{exch}^{(10)}$ terms.
This may be important if heavier elements are involved.
\begin{itemize}
\item {} 
\textbf{Type}: string

\item {} 
\textbf{Default}: none

\end{itemize}

\end{description}
\begin{description}
\item[{\index{FREEZE\_CORE|textbf}FREEZE\_CORE}] \leavevmode\phantomsection\label{index:term-freeze-core}
Sets the number of core orbitals to freeze in the evaluation
of the $E_{disp}^{(20)}$ and $E_{exch-disp}^{(20)}$
terms. It is recommended to freeze core in all SAPT computations.
\begin{itemize}
\item {} 
\textbf{Type}: string

\item {} 
\textbf{Possible Values}: TRUE, FALSE, SMALL, LARGE

\item {} 
\textbf{Default}: FALSE

\end{itemize}

\end{description}
\begin{description}
\item[{\index{D\_CONVERGENCE|textbf}D\_CONVERGENCE}] \leavevmode\phantomsection\label{index:term-d-convergence}
Convergence of the residual of the CPHF coefficients needed for
the $E_{ind,resp}^{(20)}$.
\begin{itemize}
\item {} 
\textbf{Type}: {\hyperref[index:conv-double]{conv double}}

\item {} 
\textbf{Default}: $1.0 \times 10^{-8}$

\end{itemize}

\end{description}
\begin{description}
\item[{\index{E\_CONVERGENCE|textbf}E\_CONVERGENCE}] \leavevmode\phantomsection\label{index:term-e-convergence}
Convergence of the energy change in the $E_{ind,resp}^{(20)}$
term during the solution of the CPHF equations (in hartrees).
\begin{itemize}
\item {} 
\textbf{Type}: {\hyperref[index:conv-double]{conv double}}

\item {} 
\textbf{Default}: $1.0 \times 10^{-10}$

\end{itemize}

\end{description}
\begin{description}
\item[{\index{MAXITER|textbf}MAXITER}] \leavevmode\phantomsection\label{index:term-maxiter}
The maximum number of CPHF iterations.
\begin{itemize}
\item {} 
\textbf{Type}: integer

\item {} 
\textbf{Default}: 50

\end{itemize}

\end{description}
\begin{description}
\item[{\index{PRINT|textbf}PRINT}] \leavevmode\phantomsection\label{index:term-print}
The print level for the SAPT module. If set to 0, only the header
and final results are printed. If set to 1, some intermediate
quantities are also printed. For large SAPT computations, it is
advisable to set to 1 so the progress of the computation can be
tracked.
\begin{itemize}
\item {} 
\textbf{Type}: integer

\item {} 
\textbf{Default}: 1

\end{itemize}

\end{description}


\subsection{Advanced SAPT0 Keywords}
\label{index:advanced-sapt0-keywords}\begin{description}
\item[{\index{AIO-CPHF|textbf}AIO-CPHF}] \leavevmode\phantomsection\label{index:term-aio-cphf}
Do disk I/O asynchronously during the solution of the CPHF equations.
This option may speed up the computation slightly, however its use
will cause PSI4 to spawn an additional thread.
\begin{itemize}
\item {} 
\textbf{Type}: {\hyperref[index:boolean]{boolean}}

\item {} 
\textbf{Default}: FALSE

\end{itemize}

\end{description}
\begin{description}
\item[{\index{AIO\_DF\_INTS|textbf}AIO\_DF\_INTS}] \leavevmode\phantomsection\label{index:term-aio-df-ints}
Do disk I/O asynchronously during the formation of the DF integrals.
This option may speed up the computation slightly, however its use
will cause PSI4 to spawn an additional thread.
\begin{itemize}
\item {} 
\textbf{Type}: {\hyperref[index:boolean]{boolean}}

\item {} 
\textbf{Default}: FALSE

\end{itemize}

\end{description}
\begin{description}
\item[{\index{NO\_RESPONSE|textbf}NO\_RESPONSE}] \leavevmode\phantomsection\label{index:term-no-response}
Don't solve the CPHF equations, evaluate $E_{ind}^{(20)}$
and $E_{exch-ind}^{(20)}$ instead of their response-including
counterparts. Only turn on this option if you are not going to
use the induction energy.
\begin{itemize}
\item {} 
\textbf{Type}: {\hyperref[index:boolean]{boolean}}

\item {} 
\textbf{Default}: FALSE

\end{itemize}

\end{description}
\begin{description}
\item[{\index{INTS\_TOLERANCE|textbf}INTS\_TOLERANCE}] \leavevmode\phantomsection\label{index:term-ints-tolerance}
All three-index DF integrals and those contributing to four-index
integrals that fall below this Schwarz bound will be neglected.
The default is very conservative, however, there isn't much to
gain from loosening it.
\begin{itemize}
\item {} 
\textbf{Type}: {\hyperref[index:conv-double]{conv double}}

\item {} 
\textbf{Default}: $1.0 \times 10^{-12}$

\end{itemize}

\end{description}
\begin{description}
\item[{\index{DENOMINATOR\_DELTA|textbf}DENOMINATOR\_DELTA}] \leavevmode\phantomsection\label{index:term-denominator-delta}
The SAPT module uses approximate energy denominators for most of the
$E_{disp}^{(20)}$ and $E_{exch-disp}^{(20)}$ evaluation.
This option controls the maximum allowable error norm in the energy
denominator tensor.
\begin{itemize}
\item {} 
\textbf{Type}: double

\item {} 
\textbf{Default}: $1.0 \times 10^{-6}$

\end{itemize}

\end{description}
\begin{description}
\item[{\index{DENOMINATOR\_ALGORITHM|textbf}DENOMINATOR\_ALGORITHM}] \leavevmode\phantomsection\label{index:term-denominator-algorithm}
Should the energy denominators be approximated with Laplace
transformations or a Cholesky decomposition? We have found
Laplace transformations to be slightly more efficient.
\begin{itemize}
\item {} 
\textbf{Type}: string

\item {} 
\textbf{Possible Values}: LAPLACE, CHOLESKY

\item {} 
\textbf{Default}: LAPLACE

\end{itemize}

\end{description}
\begin{description}
\item[{\index{SAPT\_OS\_SCALE|textbf}SAPT\_OS\_SCALE}] \leavevmode\phantomsection\label{index:term-sapt-os-scale}
The SAPT module will print a decomposition of the $E_{disp}^{(20)}$
and $E_{exch-disp}^{(20)}$ terms into same-spin and opposite-spin
contributions, in analogy to the SCS-MP2 method of Stefan Grimme. This
option controls the scaling of the opposite-spin contributions.
\begin{itemize}
\item {} 
\textbf{Type}: double

\item {} 
\textbf{Default}: 6/5

\end{itemize}

\end{description}
\begin{description}
\item[{\index{SAPT\_SS\_SCALE|textbf}SAPT\_SS\_SCALE}] \leavevmode\phantomsection\label{index:term-sapt-ss-scale}
This option controls the scaling of the same-spin contributions.
\begin{itemize}
\item {} 
\textbf{Type}: double

\item {} 
\textbf{Default}: 1.0/3.0

\end{itemize}

\end{description}
\begin{description}
\item[{\index{DEBUG|textbf}DEBUG}] \leavevmode\phantomsection\label{index:term-debug}
Print lots of intermediate quantities that are not usually interesting.
For SAPT, it will also do additional work (which is not optimized for
large systems) so don't turn it on.
\begin{itemize}
\item {} 
\textbf{Type}: integer

\item {} 
\textbf{Default}: 0

\end{itemize}

\end{description}


\section{Higher-Order SAPT}
\label{index:higher-order-sapt}
For smaller systems (up to the size of a nucleic acid base pair), more
accurate interaction energies can be obtained through higher-order SAPT
computations. The SAPT module can perform density-fitted evaluations
of SAPT2, SAPT2+, SAPT2+(3), and SAPT2+3 energies. Publications resulting
from the use of the higher-order SAPT code should cite the following:
{[}Hohenstein:2010:014101{]}.

A brief note on memory usage: the higher-order SAPT code assumes that
certain quantities can be held in core. This code requires sufficient
memory to hold $3o^2v^2+v^2N_{aux}$ arrays in core. With this requirement
computations on the adenine-thymine complex can be performed with an
aug-cc-pVTZ basis in less than 64GB of memory.

Higher-order SAPT is treated separately from the higly optimized SAPT0
code, therefore, higher-order SAPT uses a separate set of keywords.
The following keywords are relevant for higher-order SAPT.


\subsection{Basic Keywords for Higher-order SAPT}
\label{index:basic-keywords-for-higher-order-sapt}
Skipped for mock-up.


\subsection{Advanced Keywords for Higher-order SAPT}
\label{index:advanced-keywords-for-higher-order-sapt}
Skipped for mock-up.


\section{MP2 Natural Orbitals}
\label{index:mp2-natural-orbitals}
One of the unique features of the SAPT module is its ability to use
MP2 natural orbitals (NOs) to speed up the evaluation of the triples
contribution to disperison. By transforming to the MP2 NO basis, we can
throw away virtual orbitals that are expected to contribute little to the
dispersion energy. Speedups in excess of $50 \times$ are possible. In
practice, this approximation is very good and should always be applied.
Publications resulting from the use of MP2 NO-based approximations should
cite the following: {[}Hohenstein:2010:104107{]}.


\subsection{Basic Keywords Controlling MP2 NO Approximations}
\label{index:basic-keywords-controlling-mp2-no-approximations}
Skipped for mock-up.


\subsection{Advanced Keywords Controlling MP2 NO Approximations}
\label{index:advanced-keywords-controlling-mp2-no-approximations}
Skipped for mock-up.


\section{Charge-Transfer in SAPT}
\label{index:charge-transfer-in-sapt}
It is possible to obtain the stabilization energy of a complex due to
charge-transfer effects from a SAPT computation. The charge-transfer energy
can be computed with the SAPT module as described by Stone
and Misquitta {[}Misquitta:2009:201{]}.

Charge-transfer energies can be obtained from the following calls to the
energy function.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{energy}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{sapt0-ct}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{energy}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{sapt2-ct}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{energy}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{sapt2+-ct}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{energy}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{sapt2+(3)-ct}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{energy}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{sapt2+3-ct}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

A SAPT charge-transfer analysis will perform 5 HF computations: the dimer
in the dimer basis, monomer A in the dimer basis, monomer B in the dimer
basis, monomer A in the monomer A basis, and monomer B in the monomer B
basis. Next, it performs two SAPT computations, one in the dimer basis and
one in the monomer basis. Finally, it will print a summary of the
charge-transfer results:

\begin{Verbatim}[commandchars=\\\{\}]
  SAPT Charge Transfer Analysis
-----------------------------------------------------------------------------
  SAPT Induction (Dimer Basis)         -2.0970 mH       -1.3159 kcal mol\textasciicircum{}-1
  SAPT Induction (Monomer Basis)       -1.1396 mH       -0.7151 kcal mol\textasciicircum{}-1
  SAPT Charge Transfer                 -0.9574 mH       -0.6008 kcal mol\textasciicircum{}-1
\end{Verbatim}

These results are for the water dimer geometry shown above computed with
SAPT0/aug-cc-pVDZ.


\section{Interpreting SAPT Results}
\label{index:interpreting-sapt-results}
We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the
water dimer. This computation can be performed with the following
input:

\begin{Verbatim}[commandchars=\\\{\}]
molecule water\_dimer \PYGZob{}
     0 1
     O  -1.551007  -0.114520   0.000000
     H  -1.934259   0.762503   0.000000
     H  -0.599677   0.040712   0.000000
     --
     0 1
     O   1.350625   0.111469   0.000000
     H   1.680398  -0.373741  -0.758561
     H   1.680398  -0.373741   0.758561
     units angstrom
     no\_reorient
     symmetry c1
\PYGZcb{}

set globals \PYGZob{}
    basis          aug-cc-pvdz
    guess          sad
    scf\_type       df
\PYGZcb{}

set sapt \PYGZob{}
    print          1
    nat\_orbs       true
    freeze\_core    true
\PYGZcb{}

energy('sapt2+3')
\end{Verbatim}

To reiterate some of the options mentioned above: the
\emph{NAT\_ORBS} option will compute MP2 natural orbitals and use
them in the evaluation of the triples correction to dispersion, and the
{\hyperref[index:term-29]{\emph{FREEZE\_CORE}}} option will freeze the core throughout the SAPT
computation. This SAPT2+3/aug-cc-pVDZ computation produces the following
results:

\begin{Verbatim}[commandchars=\\\{\}]
  SAPT Results
--------------------------------------------------------------------------
  Electrostatics            -13.06429805 mH      -8.19797114 kcal mol\textasciicircum{}-1
    Elst10,r                -13.37543274 mH      -8.39321111 kcal mol\textasciicircum{}-1
    Elst12,r                  0.04490253 mH       0.02817676 kcal mol\textasciicircum{}-1
    Elst13,r                  0.26623216 mH       0.16706321 kcal mol\textasciicircum{}-1

  Exchange                   13.41793548 mH       8.41988199 kcal mol\textasciicircum{}-1
    Exch10                   11.21823471 mH       7.03954885 kcal mol\textasciicircum{}-1
    Exch10(S\textasciicircum{}2)              11.13803867 mH       6.98922508 kcal mol\textasciicircum{}-1
    Exch11(S\textasciicircum{}2)               0.04558910 mH       0.02860760 kcal mol\textasciicircum{}-1
    Exch12(S\textasciicircum{}2)               2.15411167 mH       1.35172554 kcal mol\textasciicircum{}-1

  Induction                  -3.91333155 mH      -2.45565272 kcal mol\textasciicircum{}-1
    Ind20,r                  -4.57531220 mH      -2.87105187 kcal mol\textasciicircum{}-1
    Ind30,r                  -4.91715479 mH      -3.08556135 kcal mol\textasciicircum{}-1
    Ind22                    -0.83761074 mH      -0.52560870 kcal mol\textasciicircum{}-1
    Exch-Ind20,r              2.47828867 mH       1.55514969 kcal mol\textasciicircum{}-1
    Exch-Ind30,r              4.33916816 mH       2.72286924 kcal mol\textasciicircum{}-1
    Exch-Ind22                0.45370482 mH       0.28470409 kcal mol\textasciicircum{}-1
    delta HF,r (2)           -1.43240211 mH      -0.89884593 kcal mol\textasciicircum{}-1
    delta HF,r (3)           -0.85441547 mH      -0.53615383 kcal mol\textasciicircum{}-1

  Dispersion                 -3.62061213 mH      -2.27196851 kcal mol\textasciicircum{}-1
    Disp20                   -3.54292109 mH      -2.22321664 kcal mol\textasciicircum{}-1
    Disp30                    0.05959981 mH       0.03739945 kcal mol\textasciicircum{}-1
    Disp21                    0.11216179 mH       0.07038259 kcal mol\textasciicircum{}-1
    Disp22 (SDQ)             -0.17924270 mH      -0.11247650 kcal mol\textasciicircum{}-1
    Disp22 (T)               -0.47692549 mH      -0.29927528 kcal mol\textasciicircum{}-1
    Est. Disp22 (T)          -0.54385253 mH      -0.34127263 kcal mol\textasciicircum{}-1
    Exch-Disp20               0.64545652 mH       0.40503010 kcal mol\textasciicircum{}-1
    Exch-Disp30              -0.01823411 mH      -0.01144207 kcal mol\textasciicircum{}-1
    Ind-Disp30               -0.91816995 mH      -0.57616037 kcal mol\textasciicircum{}-1
    Exch-Ind-Disp30           0.76459013 mH       0.47978757 kcal mol\textasciicircum{}-1

  Total HF                   -5.68662366 mH      -3.56841037 kcal mol\textasciicircum{}-1
  Total SAPT0                -8.58408823 mH      -5.38659691 kcal mol\textasciicircum{}-1
  Total SAPT2                -6.72339084 mH      -4.21899163 kcal mol\textasciicircum{}-1
  Total SAPT2+               -7.26739725 mH      -4.56036082 kcal mol\textasciicircum{}-1
  Total SAPT2+(3)            -6.94156528 mH      -4.35589816 kcal mol\textasciicircum{}-1
  Total SAPT2+3              -7.11337921 mH      -4.46371303 kcal mol\textasciicircum{}-1
\end{Verbatim}

At the bottom of this output are the total SAPT energies (defined above),
they are composed of subsets of the individual terms printed above. The
individual terms are grouped according to the component of the interaction
to which they contribute. The total component energies (\emph{i.e.,}
electrostatics, exchange, induction, and dispersion) represent what we
regard as the best estimate available at a given level of SAPT computed
from a subset of the terms of that grouping. The groupings shown above are
not unique and are certainly not rigorously defined. We regard the groupings
used in PSI4 as a ``chemist's grouping'' as opposed to a more
mathematically based grouping, which would group all exchange terms
(\emph{i.e.} $E_{exch-ind,resp}^{(20)}$, $E_{exch-disp}^{(20)}$, \emph{etc.} in
the exchange component. A final note is that both \code{Disp22(T)}
and \code{Est.Disp22(T)} results appear if MP2 natural orbitals are
used to evaluate the triples correction to dispersion. The \code{Disp22(T)}
result is the triples correction as computed in the truncated NO basis;
\code{Est.Disp22(T)} is a scaled result that attempts to recover
the effect of the truncated virtual space. The \code{Est.Disp22(T)}
value used in the SAPT energy and dispersion component (see{[}Hohenstein:2010:104107{]}\_ for details).


\chapter{Energy}
\label{index:energy}\index{energy() (in module driver)}

\begin{fulllineitems}
\phantomsection\label{index:driver.energy}\pysiglinewithargsret{\code{driver.}\bfcode{energy}}{\emph{name}, \emph{**kwargs}}{}
Function to compute the single-point electronic energy.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
(\emph{float}) Total electronic energy in Hartrees. SAPT returns interaction energy.

\item[{Psi variables}] \leavevmode
\end{description}\end{quote}
\index{environment variable!CURRENTENERGY}\index{environment variable!CURRENTREFERENCEENERGY}\index{environment variable!CURRENTCORRELATIONENERGY}

\begin{fulllineitems}
\phantomsection\label{index:envvar-CURRENTENERGY}\pysigline{\bfcode{CURRENT~ENERGY}}\phantomsection\label{index:envvar-CURRENTREFERENCEENERGY}\pysigline{\bfcode{CURRENT~REFERENCE~ENERGY}}\phantomsection\label{index:envvar-CURRENTCORRELATIONENERGY}\pysigline{\bfcode{CURRENT~CORRELATION~ENERGY}}
\end{fulllineitems}


\begin{longtable}{|l|l|}
\hline
\textbf{
name
} & \textbf{
calls method
}\\\hline
\endfirsthead

\multicolumn{2}{c}%
{{\bfseries \tablename\ \thetable{} -- continued from previous page}} \\
\hline
\textbf{
name
} & \textbf{
calls method
}\\\hline
\endhead

\hline \multicolumn{2}{|r|}{{Continued on next page}} \\ \hline
\endfoot

\hline
\endlastfoot


scf
 & 
Hartree--Fock (HF) or density functional theory (DFT) \code{manual}
\\\hline

mp2
 & 
2nd-order Moller-Plesset perturbation theory (MP2)
\\\hline

df-mp2
 & 
MP2 with density fitting
\\\hline

dcft
 & 
density cumulant functional theory
\\\hline

mcscf
 & 
multiconfigurational self consistent field (SCF)
\\\hline

dfcc
 & 
coupled cluster with density fitting
\\\hline

mp2c
 & 
coupled MP2 (MP2C)
\\\hline

mp2-drpa
 & 
random phase approximation?
\\\hline

sapt0
 & 
0th-order symmetry adapted perturbation theory (SAPT)
\\\hline

sapt2
 & 
2nd-order SAPT, traditional definition
\\\hline

sapt2+
 & 
SAPT including all 2nd-order terms
\\\hline

sapt2+(3)
 & 
SAPT including perturbative triples
\\\hline

sapt2+3
 & \\\hline

sapt0-ct
 & 
0th-order SAPT plus charge transfer (CT) calculation
\\\hline

sapt2-ct
 & 
SAPT2 plus CT
\\\hline

sapt2+-ct
 & 
SAPT2+ plus CT
\\\hline

sapt2+(3)-ct
 & 
SAPT2+(3) plus CT
\\\hline

sapt2+3-ct
 & 
SAPT2+3 plus CT
\\\hline

cc2
 & 
approximate coupled cluster singles and doubles (CC2)
\\\hline

ccsd
 & 
coupled cluster singles and doubles (CCSD)
\\\hline

bccd
 & 
Brueckner coupled cluster doubles (BCCD)
\\\hline

cc3
 & 
approximate coupled cluster singles, doubles, and triples (CC3)
\\\hline

ccsd(t)
 & 
CCSD with perturbative triples
\\\hline

bccd(t)
 & 
BCCD with perturbative triples
\\\hline

ccenergy
 & 
\textbf{expert} full control over ccenergy module
\\\hline

mp \emph{n}
 & 
\emph{n} th-order Moller--Plesset perturbation theory
\\\hline

zapt \emph{n}
 & 
\emph{n} th-order z-averaged perturbation theory (ZAPT)
\\\hline

cisd
 & 
configuration interaction (CI) singles and doubles (CISD)
\\\hline

cisdt
 & 
CI singles, doubles, and triples (CISDT)
\\\hline

cisdtq
 & 
CI singles, doubles, triples, and quadruples (CISDTQ)
\\\hline

ci \emph{n}
 & 
\emph{n} th-order CI
\\\hline

fci
 & 
full configuration interaction (FCI)
\\\hline

detci
 & 
\textbf{expert} full control over detci module
\\\hline

cphf
 & 
coupled-perturbed Hartree-Fock?
\\\hline

cpks
 & 
coupled-perturbed Kohn-Sham?
\\\hline

cis
 & 
CI singles (CIS)
\\\hline

tda
 & 
Tamm-Dankoff approximation (TDA)
\\\hline

tdhf
 & 
time-dependent HF (TDHF)
\\\hline

tddft
 & 
time-dependent DFT (TDDFT)
\\\hline

adc
 & 
2nd-order algebraic diagrammatic construction (ADC)
\\\hline

eom-cc2
 & 
EOM-CC2
\\\hline

eom-ccsd
 & 
equation of motion (EOM) CCSD
\\\hline

eom-cc3
 & 
EOM-CC3
\\\hline
\end{longtable}


\begin{longtable}{|l|l|}
\hline
\textbf{
name
} & \textbf{
calls method in Kallay's MRCC program
}\\\hline
\endfirsthead

\multicolumn{2}{c}%
{{\bfseries \tablename\ \thetable{} -- continued from previous page}} \\
\hline
\textbf{
name
} & \textbf{
calls method in Kallay's MRCC program
}\\\hline
\endhead

\hline \multicolumn{2}{|r|}{{Continued on next page}} \\ \hline
\endfoot

\hline
\endlastfoot


mrccsd
 & 
CC through doubles
\\\hline

mrccsdt
 & 
CC through triples
\\\hline

mrccsdtq
 & 
CC through quadruples
\\\hline

mrccsdtqp
 & 
CC through quintuples
\\\hline

mrccsdtqph
 & 
CC through sextuples
\\\hline

mrccsd(t)
 & 
CC through doubles with perturbative triples
\\\hline

mrccsdt(q)
 & 
CC through triples with perturbative quadruples
\\\hline

mrccsdtq(p)
 & 
CC through quadruples with pertubative quintuples
\\\hline

mrccsdtqp(h)
 & 
CC through quintuples with pertubative sextuples
\\\hline

mrccsd(t)\_l
 & \\\hline

mrccsdt(q)\_l
 & \\\hline

mrccsdtq(p)\_l
 & \\\hline

mrccsdtqp(h)\_l
 & \\\hline

mrccsdt-1a
 & \\\hline

mrccsdtq-1a
 & \\\hline

mrccsdtqp-1a
 & \\\hline

mrccsdtqph-1a
 & \\\hline

mrccsdt-1b
 & \\\hline

mrccsdtq-1b
 & \\\hline

mrccsdtqp-1b
 & \\\hline

mrccsdtqph-1b
 & \\\hline

mrcc2
 & \\\hline

mrcc3
 & \\\hline

mrcc4
 & \\\hline

mrcc5
 & \\\hline

mrcc6
 & \\\hline

mrccsdt-3
 & \\\hline

mrccsdtq-3
 & \\\hline

mrccsdtqp-3
 & \\\hline

mrccsdtqph-3
 & \\\hline
\end{longtable}

\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{name} (\emph{string}) -- 
\code{'scf'} \textbar{}\textbar{} \code{'df-mp2'} \textbar{}\textbar{} \code{'ci5'} \textbar{}\textbar{} etc.

First argument, usually unlabeled. Indicates the computational method
to be applied to the system.


\item {} 
\textbf{bypass\_scf} (\emph{bool}) -- 
\code{'on'} \textbar{}\textbar{} $\Rightarrow$ \code{'off'} $\Leftarrow$

Indicates whether, for \emph{name} values built atop of scf calculations,
the scf step is skipped. Suitable when special steps are taken to get
the scf to converge in an explicit preceeding scf step.


\end{itemize}

\item[{Examples }] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [1] Coupled-cluster singles and doubles calculation with psi code}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{energy}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{ccsd}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [2] Charge-transfer SAPT calculation with scf projection from small into requested basis}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{energy}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{sapt0-ct}\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{cast\PYGZus{}up}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [3] Arbitrary-order MPn calculation}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{energy}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp4}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}



\chapter{Optimize}
\label{index:optimize}
\begin{notice}{note}{Note:}
The derivative level type for {\hyperref[index:driver.optimize]{\code{driver.optimize()}}} and {\hyperref[index:driver.frequency]{\code{driver.frequency()}}}
functions can be specified by \code{energy}, \code{none}, or \code{0} for 0th derivative,
\code{gradient}, \code{first}, or \code{1} for 1st derivative, and \code{hessian},
\code{second}, or \code{2} for 2nd derivative.
\end{notice}
\index{optimize() (in module driver)}

\begin{fulllineitems}
\phantomsection\label{index:driver.optimize}\pysiglinewithargsret{\code{driver.}\bfcode{optimize}}{\emph{name}, \emph{**kwargs}}{}
Function to perform a geometry optimization.
\begin{quote}\begin{description}
\item[{Aliases }] \leavevmode
opt()

\item[{Returns}] \leavevmode
(\emph{float}) Total electronic energy of optimized structure in Hartrees.

\item[{Psi variables}] \leavevmode
\end{description}\end{quote}
\index{environment variable!CURRENTENERGY}

\begin{fulllineitems}
\phantomsection\label{index:envvar-CURRENTENERGY}\pysigline{\bfcode{CURRENT~ENERGY}}
\end{fulllineitems}


\begin{notice}{note}{Note:}
Analytic gradients area available for all methods in the table
below. Optimizations with other methods in the energy table proceed
by finite differences.
\end{notice}

\begin{notice}{caution}{Caution:}
Some features are not yet implemented. Buy a developer a coffee.
\begin{itemize}
\item {} 
Need to check that all methods do return electronic energy. I think gradient got changed at one point.

\end{itemize}
\end{notice}

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{
name
} & \textbf{
calls method
}\\\hline

scf
 & 
Hartree--Fock (HF) or density functional theory (DFT)
\\\hline

mp2
 & 
2nd-order Moller-Plesset perturbation theory (MP2)
\\\hline

ccsd
 & 
coupled cluster singles and doubles (CCSD)
\\\hline

ccsd(t)
 & 
CCSD with perturbative triples
\\\hline

eom-ccsd
 & 
equation of motion (EOM) CCSD
\\\hline
\end{tabulary}

\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{name} (\emph{string}) -- 
\code{'scf'} \textbar{}\textbar{} \code{'df-mp2'} \textbar{}\textbar{} \code{'ci5'} \textbar{}\textbar{} etc.

First argument, usually unlabeled. Indicates the computational method
to be applied to the database. May be any valid argument to
{\hyperref[index:driver.energy]{\code{driver.energy()}}}.


\item {} 
\textbf{func} (\emph{function}) -- 
$\Rightarrow$ \code{gradient} $\Leftarrow$ \textbar{}\textbar{} \code{energy} \textbar{}\textbar{} \code{cbs}

Indicates the type of calculation to be performed on the molecule.
The default dertype accesses{}`{}`'gradient'{}`{}` or \code{'energy'}, while
\code{'cbs'} performs a multistage finite difference calculation.
If a nested series of python functions is intended (see {\hyperref[index:function-intercalls]{Function Intercalls}}),
use keyword \code{opt\_func} instead of \code{func}.


\item {} 
\textbf{mode} (\emph{string}) -- 
$\Rightarrow$ \code{'continuous'} $\Leftarrow$ \textbar{}\textbar{} \code{'sow'} \textbar{}\textbar{} \code{'reap'}

For a finite difference of energies optimization, indicates whether
the calculations required to complete the
optimization are to be run in one file (\code{'continuous'}) or are to be
farmed out in an embarrassingly parallel fashion
(\code{'sow'}/\code{'reap'}).  For the latter, run an initial job with
\code{'sow'} and follow instructions in its output file.


\item {} 
\textbf{dertype} (\emph{dertype}) -- 
\code{'gradient'} \textbar{}\textbar{} \code{'energy'}

Indicates whether analytic (if available) or finite difference
optimization is to be performed.


\end{itemize}

\item[{Examples }] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [1] Analytic scf optimization}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{optimize}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{scf}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [2] Finite difference mp3 optimization}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{opt}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp3}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [3] Forced finite difference ccsd optimization}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{optimize}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{ccsd}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{dertype}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}



\chapter{Response}
\label{index:response}\index{response() (in module driver)}

\begin{fulllineitems}
\phantomsection\label{index:driver.response}\pysiglinewithargsret{\code{driver.}\bfcode{response}}{\emph{name}, \emph{**kwargs}}{}
Function to compute linear response properties.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
(\emph{float}) Total electronic energy in Hartrees.

\end{description}\end{quote}

\begin{notice}{caution}{Caution:}
Some features are not yet implemented. Buy a developer a coffee.
\begin{itemize}
\item {} 
Check that energy is actually being returned.

\item {} 
Check if ther're some PSI variables that ought to be set.

\end{itemize}
\end{notice}

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{
name
} & \textbf{
calls method
}\\\hline

cc2
 & 
2nd-order approximate CCSD
\\\hline

ccsd
 & 
coupled cluster singles and doubles (CCSD)
\\\hline
\end{tabulary}

\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{name} (\emph{string}) -- 
\code{'ccsd'} \textbar{}\textbar{} etc.

First argument, usually unlabeled. Indicates the computational method
to be applied to the system.


\item[{Examples }] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [1] CCSD-LR properties calculation}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{response}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{ccsd}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}



\chapter{Frequency}
\label{index:frequency}\index{frequency() (in module driver)}

\begin{fulllineitems}
\phantomsection\label{index:driver.frequency}\pysiglinewithargsret{\code{driver.}\bfcode{frequency}}{\emph{name}, \emph{**kwargs}}{}
Function to compute harmonic vibrational frequencies.
\begin{quote}\begin{description}
\item[{Aliases }] \leavevmode
frequencies(), freq()

\item[{Returns}] \leavevmode
(\emph{float}) Total electronic energy in Hartrees.

\end{description}\end{quote}

\begin{notice}{caution}{Caution:}
Some features are not yet implemented. Buy a developer a coffee.
\begin{itemize}
\item {} 
RAK, why are you adding OPTKING options as GLOBALS? And shouldn't they be Py-side not C-side options?

\item {} 
Make frequency look analogous to gradient, especially in matching derivative levels. Make dertype actually a dertype type.

\end{itemize}
\end{notice}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{name} (\emph{string}) -- 
\code{'scf'} \textbar{}\textbar{} \code{'df-mp2'} \textbar{}\textbar{} \code{'ci5'} \textbar{}\textbar{} etc.

First argument, usually unlabeled. Indicates the computational method
to be applied to the system.


\item {} 
\textbf{dertype} (\emph{dertype}) -- 
$\Rightarrow$ \code{'hessian'} $\Leftarrow$ \textbar{}\textbar{} \code{'gradient'} \textbar{}\textbar{} \code{'energy'}

Indicates whether analytic (if available- they're not), finite
difference of gradients (if available) or finite difference of
energies is to be performed.


\item {} 
\textbf{irrep} (\emph{int or string}) -- 
$\Rightarrow$ \code{-1} $\Leftarrow$ \textbar{}\textbar{} \code{1} \textbar{}\textbar{} \code{'b2'} \textbar{}\textbar{} \code{'App'} \textbar{}\textbar{} etc.

Indicates which symmetry block (Cotton ordering) of vibrational
frequencies to be computed. \code{1}, \code{'1'}, or \code{'a1'} represents
$a_1$, requesting only the totally symmetric modes.
\code{-1} indicates a full frequency calculation.


\end{itemize}

\item[{Examples }] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [1] \textless{}example description\textgreater{}}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{o}{\textless{}}\PYG{n}{example} \PYG{n}{python} \PYG{n}{command}\PYG{o}{\textgreater{}}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [2] Frequency calculation for b2 modes through finite difference of gradients}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{frequencies}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{scf}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{dertype}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{irrep}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}



\chapter{Counterpoise Correct}
\label{index:counterpoise-correct}\index{cp() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{index:wrappers.cp}\pysiglinewithargsret{\code{wrappers.}\bfcode{cp}}{\emph{name}\optional{, \emph{func}, \emph{check\_bsse}}}{}
The cp function computes counterpoise-corrected two-body interaction energies
for complexes composed of arbitrary numbers of monomers.
\begin{quote}\begin{description}
\item[{Aliases }] \leavevmode
counterpoise\_correct(), counterpoise\_correction()

\item[{Returns}] \leavevmode
(\emph{float}) Counterpoise-corrected interaction energy in kcal/mol

\item[{Psi variables}] \leavevmode
\end{description}\end{quote}
\index{environment variable!CP-CORRECTED2-BODYINTERACTIONENERGY}\index{environment variable!UNCP-CORRECTED2-BODYINTERACTIONENERGY}

\begin{fulllineitems}
\phantomsection\label{index:envvar-CP-CORRECTED2-BODYINTERACTIONENERGY}\pysigline{\bfcode{CP-CORRECTED~2-BODY~INTERACTION~ENERGY}}\phantomsection\label{index:envvar-UNCP-CORRECTED2-BODYINTERACTIONENERGY}\pysigline{\bfcode{UNCP-CORRECTED~2-BODY~INTERACTION~ENERGY}}
\end{fulllineitems}


\begin{notice}{caution}{Caution:}
Some features are not yet implemented. Buy a developer a coffee.
\begin{itemize}
\item {} 
No values of func besides energy have been tested.

\item {} 
Table print-out needs improving. Add some PSI variables.

\end{itemize}
\end{notice}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{name} (\emph{string}) -- 
\code{'scf'} \textbar{}\textbar{} \code{'ccsd(t)'} \textbar{}\textbar{} etc.

First argument, usually unlabeled. Indicates the computational method
to be applied to the molecule. May be any valid argument to
{\hyperref[index:driver.energy]{\code{driver.energy()}}}; however, SAPT is not appropriate.


\item {} 
\textbf{func} (\emph{function}) -- 
$\Rightarrow$ \code{energy} $\Leftarrow$ \textbar{}\textbar{} \code{optimize} \textbar{}\textbar{} \code{cbs}

Indicates the type of calculation to be performed on the molecule
and each of its monomers. The default performs a single-point
\code{energy('name')}, while \code{optimize} perfoms a geometry optimization
on each system, and \code{cbs} performs a compound single-point energy.
If a nested series of python functions is intended
(see {\hyperref[index:function-intercalls]{Function Intercalls}}), use keyword \code{cp\_func} instead of \code{func}.


\item {} 
\textbf{check\_bsse} (\emph{bool}) -- 
\code{'on'} \textbar{}\textbar{} $\Rightarrow$ \code{'off'} $\Leftarrow$

Indicates whether to additionally compute un-counterpoise corrected
monomers and thus obtain an estimate for the basis set superposition error.


\end{itemize}

\item[{Examples }] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [1] counterpoise-corrected mp2 interaction energy}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{cp}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{dfmp2}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}



\chapter{Database}
\label{index:database}

\chapter{Complete Basis Set}
\label{index:complete-basis-set}\index{complete\_basis\_set() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{index:wrappers.complete_basis_set}\pysiglinewithargsret{\code{wrappers.}\bfcode{complete\_basis\_set}}{\emph{name}\optional{, \emph{scf\_basis}, \emph{scf\_scheme}, \emph{corl\_wfn}, \emph{corl\_basis}, \emph{corl\_scheme}, \emph{delta\_wfn}, \emph{delta\_wfn\_lesser}, \emph{delta\_basis}, \emph{delta\_scheme}, \emph{delta2\_wfn}, \emph{delta2\_wfn\_lesser}, \emph{delta2\_basis}, \emph{delta2\_scheme}}}{}
Function to define a multistage energy method from combinations of
basis set extrapolations and delta corrections and condense the
components into a minimum number of calculations.
\begin{quote}\begin{description}
\item[{Aliases }] \leavevmode
cbs()

\item[{Returns}] \leavevmode
(\emph{float}) -- Total electronic energy in Hartrees

\item[{Psi variables}] \leavevmode
\end{description}\end{quote}
\index{environment variable!CBSTOTALENERGY}\index{environment variable!CBSREFERENCEENERGY}\index{environment variable!CBSCORRELATIONENERGY}\index{environment variable!CURRENTENERGY}\index{environment variable!CURRENTREFERENCEENERGY}\index{environment variable!CURRENTCORRELATIONENERGY}

\begin{fulllineitems}
\phantomsection\label{index:envvar-CBSTOTALENERGY}\pysigline{\bfcode{CBS~TOTAL~ENERGY}}\phantomsection\label{index:envvar-CBSREFERENCEENERGY}\pysigline{\bfcode{CBS~REFERENCE~ENERGY}}\phantomsection\label{index:envvar-CBSCORRELATIONENERGY}\pysigline{\bfcode{CBS~CORRELATION~ENERGY}}\phantomsection\label{index:envvar-CURRENTENERGY}\pysigline{\bfcode{CURRENT~ENERGY}}\phantomsection\label{index:envvar-CURRENTREFERENCEENERGY}\pysigline{\bfcode{CURRENT~REFERENCE~ENERGY}}\phantomsection\label{index:envvar-CURRENTCORRELATIONENERGY}\pysigline{\bfcode{CURRENT~CORRELATION~ENERGY}}
\end{fulllineitems}


\begin{notice}{caution}{Caution:}
Some features are not yet implemented. Buy a developer a coffee.
\begin{itemize}
\item {} 
Methods beyond basic scf, mp2, ccsd, ccsd(t) not yet hooked in through PSI variables, df-mp2 in particular.

\item {} 
No scheme defaults for given basis zeta number, so scheme must be specified explicitly.

\item {} 
No way to tell function to boost fitting basis size for all calculations.

\item {} 
No way to extrapolate def2 family basis sets

\item {} 
Need to add more extrapolation schemes

\end{itemize}
\end{notice}

As represented in the equation below, a CBS energy method is defined in four
sequential stages (scf, corl, delta, delta2) covering treatment of the
reference total energy, the correlation energy, a delta correction to the
correlation energy, and a second delta correction. Each is activated by its
stage\_wfn keyword and is only allowed if all preceding stages are active.
\begin{gather}
\begin{split}E_{total}^{\text{CBS}} = \mathcal{F}_{\textbf{scf\_scheme}} \left(E_{total,\; \text{SCF}}^{\textbf{scf\_basis}}\right) \; + \mathcal{F}_{\textbf{corl\_scheme}} \left(E_{corl,\; \textbf{corl\_wfn}}^{\textbf{corl\_basis}}\right) \; + \delta_{\textbf{delta\_wfn\_lesser}}^{\textbf{delta\_wfn}} \; + \delta_{\textbf{delta2\_wfn\_lesser}}^{\textbf{delta2\_wfn}}\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
Here, $\mathcal{F}$ is an energy or energy extrapolation scheme, and the following also hold.
\begin{gather}
\begin{split}\delta_{\textbf{delta\_wfn\_lesser}}^{\textbf{delta\_wfn}} \; = \mathcal{F}_{\textbf{delta\_scheme}} \left(E_{corl,\; \textbf{delta\_wfn}}^{\textbf{delta\_basis}}\right) - \mathcal{F}_{\textbf{delta\_scheme}} \left(E_{corl,\; \textbf{delta\_wfn\_lesser}}^{\textbf{delta\_basis}}\right)\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}\begin{gather}
\begin{split}\delta_{\textbf{delta2\_wfn\_lesser}}^{\textbf{delta2\_wfn}} \; = \mathcal{F}_{\textbf{delta2\_scheme}} \left(E_{corl,\; \textbf{delta2\_wfn}}^{\textbf{delta2\_basis}}\right) - \mathcal{F}_{\textbf{delta2\_scheme}} \left(E_{corl,\; \textbf{delta2\_wfn\_lesser}}^{\textbf{delta2\_basis}}\right)\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
A translation of this ungainly equation to example {[}5{]} below is as
follows. In words, this is a double- and triple-zeta 2-point
Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction
appended to a triple- and quadruple-zeta 2-point
Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ
reference energy.
\begin{gather}
\begin{split}E_{total}^{\text{CBS}} = \mathcal{F}_{\text{highest\_1}} \left(E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}}\right) \; + \mathcal{F}_{\text{corl\_xtpl\_helgaker\_2}} \left(E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}}\right) \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}\begin{gather}
\begin{split}\delta_{\text{MP2}}^{\text{CCSD(T)}} \; = \mathcal{F}_{\text{corl\_xtpl\_helgaker\_2}} \left(E_{corl,\; \text{CCSD(T)}}^{\text{aug-cc-pV[DT]Z}}\right) - \mathcal{F}_{\text{corl\_xtpl\_helgaker\_2}} \left(E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[DT]Z}}\right)\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}\begin{itemize}
\item {} \begin{description}
\item[{Energy Methods}] \leavevmode
The presence of a stage\_wfn keyword is the indicator to incorporate
(and check for stage\_basis and stage\_scheme keywords) and compute
that stage in defining the CBS energy.

\end{description}

\end{itemize}
\begin{description}
\item[{The cbs() function requires, at a minimum, \code{name='scf'} and \code{scf\_basis}}] \leavevmode
keywords to be specified for reference-step only jobs and \code{name} and
\code{corl\_basis} keywords for correlated jobs.

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{name} (\emph{string}) -- 
\code{'scf'} \textbar{}\textbar{} \code{'ccsd'} \textbar{}\textbar{} etc.

First argument, usually unlabeled. Indicates the computational method
for the correlation energy, unless only reference step to be performed,
in which case should be \code{'scf'}. Overruled if stage\_wfn keywords supplied.


\item {} 
\textbf{corl\_wfn} (\emph{string}) -- 
\code{'mp2'} \textbar{}\textbar{} \code{'ccsd(t)'} \textbar{}\textbar{} etc.

Indicates the energy method for which the correlation energy is to be
obtained. Can also be specified with \code{name} or as the unlabeled
first argument to the function.


\item {} 
\textbf{delta\_wfn} (\emph{string}) -- 
\code{'ccsd'} \textbar{}\textbar{} \code{'ccsd(t)'} \textbar{}\textbar{} etc.

Indicates the (superior) energy method for which a delta correction
to the correlation energy is to be obtained.


\item {} 
\textbf{delta\_wfn\_lesser} (\emph{string}) -- 
$\Rightarrow$ \code{'mp2'} $\Leftarrow$ \textbar{}\textbar{} \code{'ccsd'} \textbar{}\textbar{} etc.

Indicates the inferior energy method for which a delta correction
to the correlation energy is to be obtained.


\item {} 
\textbf{delta2\_wfn} (\emph{string}) -- 
\code{'ccsd'} \textbar{}\textbar{} \code{'ccsd(t)'} \textbar{}\textbar{} etc.

Indicates the (superior) energy method for which a second delta correction
to the correlation energy is to be obtained.


\item {} 
\textbf{delta2\_wfn\_lesser} (\emph{string}) -- 
$\Rightarrow$ \code{'mp2'} $\Leftarrow$ \textbar{}\textbar{} \code{'ccsd(t)'} \textbar{}\textbar{} etc.

Indicates the inferior energy method for which a second delta correction
to the correlation energy is to be obtained.


\end{itemize}

\end{description}\end{quote}
\begin{itemize}
\item {} \begin{description}
\item[{Basis Sets}] \leavevmode
Currently, the basis set set through \code{set} commands have no influence
on a cbs calculation.

\end{description}

\end{itemize}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{scf\_basis} (\emph{string}) -- 
$\Rightarrow$ \code{corl\_basis} $\Leftarrow$ \textbar{}\textbar{} \code{'cc-pV{[}TQ{]}Z'} \textbar{}\textbar{} \code{'jun-cc-pv{[}tq5{]}z'} \textbar{}\textbar{} \code{'6-31G*'} \textbar{}\textbar{} etc.

Indicates the sequence of basis sets employed for the reference energy.
If any correlation method is specified, \code{scf\_basis} can default
to \code{corl\_basis}.


\item {} 
\textbf{corl\_basis} (\emph{string}) -- 
\code{'cc-pV{[}TQ{]}Z'} \textbar{}\textbar{} \code{'jun-cc-pv{[}tq5{]}z'} \textbar{}\textbar{} \code{'6-31G*'} \textbar{}\textbar{} etc.

Indicates the sequence of basis sets employed for the correlation energy.


\item {} 
\textbf{delta\_basis} (\emph{string}) -- 
\code{'cc-pV{[}TQ{]}Z'} \textbar{}\textbar{} \code{'jun-cc-pv{[}tq5{]}z'} \textbar{}\textbar{} \code{'6-31G*'} \textbar{}\textbar{} etc.

Indicates the sequence of basis sets employed for the delta correction
to the correlation energy.


\item {} 
\textbf{delta2\_basis} (\emph{string}) -- 
\code{'cc-pV{[}TQ{]}Z'} \textbar{}\textbar{} \code{'jun-cc-pv{[}tq5{]}z'} \textbar{}\textbar{} \code{'6-31G*'} \textbar{}\textbar{} etc.

Indicates the sequence of basis sets employed for the second delta correction
to the correlation energy.


\end{itemize}

\end{description}\end{quote}
\begin{itemize}
\item {} \begin{description}
\item[{Schemes}] \leavevmode
Transformations of the energy through basis set extrapolation for each
stage of the CBS definition. A complaint is generated if number of basis
sets in stage\_basis does not exactly satisfy requirements of stage\_scheme.
An exception is the default, \code{'highest\_1'}, which uses the best basis
set available. See {\hyperref[index:extrapolation-schemes]{Extrapolation Schemes}} for all available schemes.

\end{description}

\end{itemize}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{scf\_scheme} (\emph{function}) -- 
$\Rightarrow$ \code{highest\_1} $\Leftarrow$ \textbar{}\textbar{} \code{scf\_xtpl\_helgaker\_3} \textbar{}\textbar{} etc.

Indicates the basis set extrapolation scheme to be applied to the reference energy.


\item {} 
\textbf{corl\_scheme} (\emph{function}) -- 
$\Rightarrow$ \code{highest\_1} $\Leftarrow$ \textbar{}\textbar{} \code{corl\_xtpl\_helgaker\_2} \textbar{}\textbar{} etc.

Indicates the basis set extrapolation scheme to be applied to the correlation energy.


\item {} 
\textbf{delta\_scheme} (\emph{function}) -- 
$\Rightarrow$ \code{highest\_1} $\Leftarrow$ \textbar{}\textbar{} \code{corl\_xtpl\_helgaker\_2} \textbar{}\textbar{} etc.

Indicates the basis set extrapolation scheme to be applied to the delta correction
to the correlation energy.


\item {} 
\textbf{delta2\_scheme} (\emph{function}) -- 
$\Rightarrow$ \code{highest\_1} $\Leftarrow$ \textbar{}\textbar{} \code{corl\_xtpl\_helgaker\_2} \textbar{}\textbar{} etc.

Indicates the basis set extrapolation scheme to be applied to the second delta correction
to the correlation energy.


\end{itemize}

\item[{Examples }] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf')}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{cbs}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{scf}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{scf\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{cc-pVDZ}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2')}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{cbs}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp2}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{corl\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{jun-cc-pVDZ}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [3] DTQ-zeta extrapolated scf reference energy}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{cbs}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{scf}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{scf\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{cc-pV[DTQ]Z}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{scf\PYGZus{}scheme}\PYG{o}{=}\PYG{n}{scf\PYGZus{}xtpl\PYGZus{}helgaker\PYGZus{}3}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{cbs}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp2}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{corl\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{cc-pv[dt]z}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{corl\PYGZus{}scheme}\PYG{o}{=}\PYG{n}{corl\PYGZus{}xtpl\PYGZus{}helgaker\PYGZus{}2}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{cbs}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp2}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{corl\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{aug-cc-pv[tq]z}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{corl\PYGZus{}scheme}\PYG{o}{=}\PYG{n}{corl\PYGZus{}xtpl\PYGZus{}helgaker\PYGZus{}2}\PYG{p}{,} \PYG{n}{delta\PYGZus{}wfn}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{ccsd(t)}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{delta\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{aug-cc-pv[dt]z}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{delta\PYGZus{}scheme}\PYG{o}{=}\PYG{n}{corl\PYGZus{}xtpl\PYGZus{}helgaker\PYGZus{}2}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{cbs}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp2}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{corl\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{aug-cc-pv[tq]z}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{corl\PYGZus{}scheme}\PYG{o}{=}\PYG{n}{corl\PYGZus{}xtpl\PYGZus{}helgaker\PYGZus{}2}\PYG{p}{,} \PYG{n}{delta\PYGZus{}wfn}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{ccsd}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{delta\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{aug-cc-pv[dt]z}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{delta\PYGZus{}scheme}\PYG{o}{=}\PYG{n}{corl\PYGZus{}xtpl\PYGZus{}helgaker\PYGZus{}2}\PYG{p}{,} \PYG{n}{delta2\PYGZus{}wfn}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{ccsd(t)}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{delta2\PYGZus{}wfn\PYGZus{}lesser}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{ccsd}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{delta2\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{aug-cc-pvdz}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{} [7] cbs() coupled with database()}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{database}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp2}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{BASIC}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{subset}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{h2o}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{nh3}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{,} \PYG{n}{symm}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{on}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{func}\PYG{o}{=}\PYG{n}{cbs}\PYG{p}{,} \PYG{n}{corl\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{cc-pV[tq]z}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{corl\PYGZus{}scheme}\PYG{o}{=}\PYG{n}{corl\PYGZus{}xtpl\PYGZus{}helgaker\PYGZus{}2}\PYG{p}{,} \PYG{n}{delta\PYGZus{}wfn}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{ccsd(t)}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{delta\PYGZus{}basis}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{sto-3g}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}



\section{Output}
\label{index:output}
At the beginning of a cbs() job is printed a listing of the individual
energy calculations which will be performed. The output snippet below is
from the example job {[}2{]} above. It shows first each model chemistry needed
to compute the aggregate model chemistry requested through cbs(). Then,
since, for example, an \code{energy('ccsd(t)')} yields CCSD(T), CCSD, MP2,
and SCF energy values, the wrapper condenses this task list into the second
list of minimum number of calculations which will actually be run.

\begin{Verbatim}[commandchars=\\\{\}]
Naive listing of computations required.
        scf / aug-cc-pvqz              for  SCF TOTAL ENERGY
        mp2 / aug-cc-pvtz              for  MP2 CORRELATION ENERGY
        mp2 / aug-cc-pvqz              for  MP2 CORRELATION ENERGY
    ccsd(t) / aug-cc-pvdz              for  CCSD(T) CORRELATION ENERGY
    ccsd(t) / aug-cc-pvtz              for  CCSD(T) CORRELATION ENERGY
        mp2 / aug-cc-pvdz              for  MP2 CORRELATION ENERGY
        mp2 / aug-cc-pvtz              for  MP2 CORRELATION ENERGY

Enlightened listing of computations required.
        mp2 / aug-cc-pvqz              for  MP2 CORRELATION ENERGY
    ccsd(t) / aug-cc-pvdz              for  CCSD(T) CORRELATION ENERGY
    ccsd(t) / aug-cc-pvtz              for  CCSD(T) CORRELATION ENERGY
\end{Verbatim}

At the end of a cbs() job is printed a summary section like the one below. First,
in the components section, are listed the results for each model chemistry available, whether
required for the cbs job (*) or not. Next, in the stages section, are listed the results for
each extrapolation. The energies of this section must be dotted with the weightings in column Wt
to get the total cbs energy. Finally, in the CBS section, are listed the results for each stage
of the cbs procedure. The stage energies of this section sum outright to the total cbs energy.

\begin{Verbatim}[commandchars=\\\{\}]
==\textgreater{} Components \textless{}==

----------------------------------------------------------------------------------
               Method / Basis            Rqd   Energy [H]   Variable
----------------------------------------------------------------------------------
                  scf / aug-cc-pvqz        *  -1.11916375   SCF TOTAL ENERGY
                  mp2 / aug-cc-pvqz        *  -0.03407997   MP2 CORRELATION ENERGY
                  scf / aug-cc-pvdz           -1.11662884   SCF TOTAL ENERGY
                  mp2 / aug-cc-pvdz        *  -0.02881480   MP2 CORRELATION ENERGY
              ccsd(t) / aug-cc-pvdz        *  -0.03893812   CCSD(T) CORRELATION ENERGY
                 ccsd / aug-cc-pvdz           -0.03893812   CCSD CORRELATION ENERGY
                  scf / aug-cc-pvtz           -1.11881134   SCF TOTAL ENERGY
                  mp2 / aug-cc-pvtz        *  -0.03288936   MP2 CORRELATION ENERGY
              ccsd(t) / aug-cc-pvtz        *  -0.04201004   CCSD(T) CORRELATION ENERGY
                 ccsd / aug-cc-pvtz           -0.04201004   CCSD CORRELATION ENERGY
----------------------------------------------------------------------------------

==\textgreater{} Stages \textless{}==

----------------------------------------------------------------------------------
 Stage         Method / Basis             Wt   Energy [H]   Scheme
----------------------------------------------------------------------------------
   scf            scf / aug-cc-pvqz        1  -1.11916375   highest\_1
  corl            mp2 / aug-cc-pv[tq]z     1  -0.03494879   corl\_xtpl\_helgaker\_2
 delta        ccsd(t) / aug-cc-pv[dt]z     1  -0.04330347   corl\_xtpl\_helgaker\_2
 delta            mp2 / aug-cc-pv[dt]z    -1  -0.03460497   corl\_xtpl\_helgaker\_2
----------------------------------------------------------------------------------

==\textgreater{} CBS \textless{}==

----------------------------------------------------------------------------------
 Stage         Method / Basis                  Energy [H]   Scheme
----------------------------------------------------------------------------------
   scf            scf / aug-cc-pvqz           -1.11916375   highest\_1
  corl            mp2 / aug-cc-pv[tq]z        -0.03494879   corl\_xtpl\_helgaker\_2
 delta  ccsd(t) - mp2 / aug-cc-pv[dt]z        -0.00869851   corl\_xtpl\_helgaker\_2
 total            CBS                         -1.16281105
----------------------------------------------------------------------------------
\end{Verbatim}


\section{Extrapolation Schemes}
\label{index:extrapolation-schemes}\index{highest\_1() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{index:wrappers.highest_1}\pysiglinewithargsret{\code{wrappers.}\bfcode{highest\_1}}{\emph{**largs}}{}
Scheme for total or correlation energies with a single basis or the highest
zeta-level among an array of bases. Used by {\hyperref[index:wrappers.complete_basis_set]{\code{wrappers.complete\_basis\_set()}}}.
\begin{gather}
\begin{split}E_{total}^X = E_{total}^X\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
\end{fulllineitems}

\index{scf\_xtpl\_helgaker\_2() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{index:wrappers.scf_xtpl_helgaker_2}\pysiglinewithargsret{\code{wrappers.}\bfcode{scf\_xtpl\_helgaker\_2}}{\emph{**largs}}{}
Extrapolation scheme for reference energies with two adjacent zeta-level bases.
Used by {\hyperref[index:wrappers.complete_basis_set]{\code{wrappers.complete\_basis\_set()}}}.
\begin{gather}
\begin{split}E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
\end{fulllineitems}

\index{scf\_xtpl\_helgaker\_3() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{index:wrappers.scf_xtpl_helgaker_3}\pysiglinewithargsret{\code{wrappers.}\bfcode{scf\_xtpl\_helgaker\_3}}{\emph{**largs}}{}
Extrapolation scheme for reference energies with three adjacent zeta-level bases.
Used by {\hyperref[index:wrappers.complete_basis_set]{\code{wrappers.complete\_basis\_set()}}}.
\begin{gather}
\begin{split}E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
\end{fulllineitems}

\index{corl\_xtpl\_helgaker\_2() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{index:wrappers.corl_xtpl_helgaker_2}\pysiglinewithargsret{\code{wrappers.}\bfcode{corl\_xtpl\_helgaker\_2}}{\emph{**largs}}{}
Extrapolation scheme for correlation energies with two adjacent zeta-level bases.
Used by {\hyperref[index:wrappers.complete_basis_set]{\code{wrappers.complete\_basis\_set()}}}.
\begin{gather}
\begin{split}E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
\end{fulllineitems}



\chapter{Fractional Occupation}
\label{index:fractional-occupation}\label{index:module-frac}\index{frac (module)}\index{frac\_nuke() (in module frac)}

\begin{fulllineitems}
\phantomsection\label{index:frac.frac_nuke}\pysiglinewithargsret{\code{frac.}\bfcode{frac\_nuke}}{\emph{mol}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{frac\_traverse() (in module frac)}

\begin{fulllineitems}
\phantomsection\label{index:frac.frac_traverse}\pysiglinewithargsret{\code{frac.}\bfcode{frac\_traverse}}{\emph{mol}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{ip\_fitting() (in module frac)}

\begin{fulllineitems}
\phantomsection\label{index:frac.ip_fitting}\pysiglinewithargsret{\code{frac.}\bfcode{ip\_fitting}}{\emph{mol}, \emph{omega\_l}, \emph{omega\_r}, \emph{**kwargs}}{}
\end{fulllineitems}



\chapter{Beginner Psithon Programming}
\label{index:beginner-psithon-programming}
\begin{notice}{note}{Note:}
No recompile of the PSI program is necessary for changes made to
files in \code{\$PSIDATADIR}, including those described below.
\end{notice}


\section{Defining a Method Alias}
\label{index:defining-a-method-alias}
Since quantum chemical methods in PSI4 are accessed through Python functions, and
most important quantities are available as PSI variables, it is straightforward
to create aliases to commonly run calculations or to define hybrid methods. The
\code{\$PSIDATADIR/python/aliases.py} file is intended for editing by the user for
this purpose.

As an example, the MP2.5 method is the average of MP2 and MP3. The latter is
available through the arbitrary order MPn code and returns all lower energies
along with it in PSI variables. The following is basic code that will compute
and return the MP2.5 energy.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{run\PYGZus{}mp2\PYGZus{}5}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}

    \PYG{n}{energy}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp3}\PYG{l+s}{'}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}
    \PYG{n}{e\PYGZus{}scf} \PYG{o}{=} \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{get\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{SCF TOTAL ENERGY}\PYG{l+s}{'}\PYG{p}{)}
    \PYG{n}{ce\PYGZus{}mp2} \PYG{o}{=} \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{get\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{MP2 CORRELATION ENERGY}\PYG{l+s}{'}\PYG{p}{)}
    \PYG{n}{ce\PYGZus{}mp3} \PYG{o}{=} \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{get\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{MP3 CORRELATION ENERGY}\PYG{l+s}{'}\PYG{p}{)}

    \PYG{n}{ce\PYGZus{}mp25} \PYG{o}{=} \PYG{l+m+mf}{0.5} \PYG{o}{*} \PYG{p}{(}\PYG{n}{ce\PYGZus{}mp2} \PYG{o}{+} \PYG{n}{ce\PYGZus{}mp3}\PYG{p}{)}
    \PYG{n}{e\PYGZus{}mp25} \PYG{o}{=} \PYG{n}{e\PYGZus{}scf} \PYG{o}{+} \PYG{n}{ce\PYGZus{}mp25}

    \PYG{k}{print} \PYG{l+s}{"""}\PYG{l+s}{  MP2.5 total energy:                      }\PYG{l+s+si}{\PYGZpc{}16.8f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{e\PYGZus{}mp25}\PYG{p}{)}
    \PYG{k}{print} \PYG{l+s}{"""}\PYG{l+s}{  MP2.5 correlation energy:                }\PYG{l+s+si}{\PYGZpc{}16.8f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{ce\PYGZus{}mp25}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{e\PYGZus{}mp25}
\end{Verbatim}

Compare the above to the method that resides in \code{aliases.py}.
The rationale for the changes is indicated in the comments below.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{run\PYGZus{}mp2\PYGZus{}5}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{lowername} \PYG{o}{=} \PYG{n}{name}\PYG{o}{.}\PYG{n}{lower}\PYG{p}{(}\PYG{p}{)}  \PYG{c}{\PYGZsh{} handy variable with name keyword in lowercase}
    \PYG{n}{kwargs} \PYG{o}{=} \PYG{n}{kwargs\PYGZus{}lower}\PYG{p}{(}\PYG{n}{kwargs}\PYG{p}{)}  \PYG{c}{\PYGZsh{} removes case sensitivity in keyword names}

    \PYG{c}{\PYGZsh{} Run detci calculation and collect conventional quantities}
    \PYG{n}{energy}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp3}\PYG{l+s}{'}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}
    \PYG{n}{e\PYGZus{}scf} \PYG{o}{=} \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{get\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{SCF TOTAL ENERGY}\PYG{l+s}{'}\PYG{p}{)}
    \PYG{n}{ce\PYGZus{}mp2} \PYG{o}{=} \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{get\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{MP2 CORRELATION ENERGY}\PYG{l+s}{'}\PYG{p}{)}
    \PYG{n}{ce\PYGZus{}mp3} \PYG{o}{=} \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{get\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{MP3 CORRELATION ENERGY}\PYG{l+s}{'}\PYG{p}{)}
    \PYG{n}{e\PYGZus{}mp2} \PYG{o}{=} \PYG{n}{e\PYGZus{}scf} \PYG{o}{+} \PYG{n}{ce\PYGZus{}mp2}  \PYG{c}{\PYGZsh{} reform mp2 and mp3 total energies for printing}
    \PYG{n}{e\PYGZus{}mp3} \PYG{o}{=} \PYG{n}{e\PYGZus{}scf} \PYG{o}{+} \PYG{n}{ce\PYGZus{}mp3}

    \PYG{c}{\PYGZsh{} Compute quantities particular to MP2.5}
    \PYG{n}{ce\PYGZus{}mp25} \PYG{o}{=} \PYG{l+m+mf}{0.5} \PYG{o}{*} \PYG{p}{(}\PYG{n}{ce\PYGZus{}mp2} \PYG{o}{+} \PYG{n}{ce\PYGZus{}mp3}\PYG{p}{)}
    \PYG{n}{e\PYGZus{}mp25} \PYG{o}{=} \PYG{n}{e\PYGZus{}scf} \PYG{o}{+} \PYG{n}{ce\PYGZus{}mp25}
    \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{set\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{MP2.5 CORRELATION ENERGY}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{ce\PYGZus{}mp25}\PYG{p}{)}  \PYG{c}{\PYGZsh{} add new method's important results}
    \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{set\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{MP2.5 TOTAL ENERGY}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{e\PYGZus{}mp25}\PYG{p}{)}         \PYG{c}{\PYGZsh{}     to PSI variable repository}
    \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{set\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{CURRENT CORRELATION ENERGY}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{ce\PYGZus{}mp25}\PYG{p}{)}
    \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{set\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{CURRENT ENERGY}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{e\PYGZus{}mp25}\PYG{p}{)}  \PYG{c}{\PYGZsh{} geometry optimizer tracks this variable, permits}
                                                   \PYG{c}{\PYGZsh{}     MP2.5 finite difference optimizations}
    \PYG{c}{\PYGZsh{} build string of title banner and print results}
    \PYG{n}{banners} \PYG{o}{=} \PYG{l+s}{'}\PYG{l+s}{'}
    \PYG{n}{banners} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{"""}\PYG{l+s}{PsiMod.print\PYGZus{}out(}\PYG{l+s}{'}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s}{n}\PYG{l+s}{'}\PYG{l+s}{)}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""}
    \PYG{n}{banners} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{"""}\PYG{l+s}{banner(}\PYG{l+s}{'}\PYG{l+s}{ MP2.5 }\PYG{l+s}{'}\PYG{l+s}{)}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""}
    \PYG{n}{banners} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{"""}\PYG{l+s}{PsiMod.print\PYGZus{}out(}\PYG{l+s}{'}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s}{n}\PYG{l+s}{'}\PYG{l+s}{)}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""}
    \PYG{k}{exec} \PYG{n}{banners}

    \PYG{n}{tables}  \PYG{o}{=} \PYG{l+s}{'}\PYG{l+s}{'}
    \PYG{n}{tables} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{"""}\PYG{l+s}{  SCF total energy:                        }\PYG{l+s+si}{\PYGZpc{}16.8f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{e\PYGZus{}scf}\PYG{p}{)}
    \PYG{n}{tables} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{"""}\PYG{l+s}{  MP2 total energy:                        }\PYG{l+s+si}{\PYGZpc{}16.8f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{e\PYGZus{}mp2}\PYG{p}{)}
    \PYG{n}{tables} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{"""}\PYG{l+s}{  MP2.5 total energy:                      }\PYG{l+s+si}{\PYGZpc{}16.8f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{e\PYGZus{}mp25}\PYG{p}{)}
    \PYG{n}{tables} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{"""}\PYG{l+s}{  MP3 total energy:                        }\PYG{l+s+si}{\PYGZpc{}16.8f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{e\PYGZus{}mp3}\PYG{p}{)}
    \PYG{n}{tables} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{"""}\PYG{l+s}{  MP2 correlation energy:                  }\PYG{l+s+si}{\PYGZpc{}16.8f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{ce\PYGZus{}mp2}\PYG{p}{)}
    \PYG{n}{tables} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{"""}\PYG{l+s}{  MP2.5 correlation energy:                }\PYG{l+s+si}{\PYGZpc{}16.8f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{ce\PYGZus{}mp25}\PYG{p}{)}
    \PYG{n}{tables} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{"""}\PYG{l+s}{  MP3 correlation energy:                  }\PYG{l+s+si}{\PYGZpc{}16.8f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"""} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{ce\PYGZus{}mp3}\PYG{p}{)}
    \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{print\PYGZus{}out}\PYG{p}{(}\PYG{n}{tables}\PYG{p}{)}  \PYG{c}{\PYGZsh{} prints nice header and table of all involved quantities to output file}

    \PYG{k}{return} \PYG{n}{e\PYGZus{}mp25}
\end{Verbatim}

One final step is necessary. At the end of the \code{aliases.py} file, add
the following line.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{procedures}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{energy}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{mp2.5}\PYG{l+s}{'}\PYG{p}{]} \PYG{o}{=} \PYG{n}{run\PYGZus{}mp2\PYGZus{}5}
\end{Verbatim}

This permits the newly defined MP2.5 method to be called in the input file
with the following command.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{energy}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp2.5}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}


\section{Creating a Database}
\label{index:creating-a-database}
A necessary consideration in constructing a database is the distinction
between reagents and reactions. A reagent is a single molecular system
(may be a dimer) whose geometry you are possession of and whose electronic
energy may be of interest. A reaction is a combination of one or more
reagent energies whose value you are interested in and a reference value
for which you may or may not be in possession of. A few examples follow.
In a database of interaction energies, the reagents are dimers and their
component monomers (usually derived from the dimer geometry), and the
reactions are the dimer less monomers energies. In a database of barrier
heights, the reagents are reactants, products, and transition-state
structures, and the reactions are the transition-states less
minimum-energy structures. Possibly you may have a collection of
structures to simply be acted upon in parallel, in which case the
structures are both the reagents and the reactions. The role of the
database.py file is to collect arrays and dictionaries that define the
geometries of reagents (GEOS), their combination into reactions (RXNM \&
ACTV), available reference values for reactions (BIND), and brief comments
for reagents and reactions (TAGL). The journey from reagent geometries to
functional database.py file is largely automated, in a process described
below.
\begin{itemize}
\item {} \begin{description}
\item[{Prepare geometry files}] \leavevmode
Assemble xyz files for all intended reagent systems in a directory.
Follow the rules below for best results. The filename for each xyz
file should be the name of the system. lowercase or MixedCase is
preferable (according to Sherrill lab convention). Avoid dashes and
dots in the name as python won't allow them. If you're determined to
have dashes and dots, they must be replaced by other characters in the
process\_input line, then translated back in the GEOS section; see
NBC10.py for an example.
\begin{itemize}
\item {} 
The first line for each xyz file should be the number of atoms in the system.

\item {} 
The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).

\item {} 
The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what's the use in cartesian form).  For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step.

\end{itemize}

\end{description}

\item {} 
Run script ixyz2database.pl
\begin{quote}

Move into the directory where all your xyz files are located. Run the
script in place, probably as
\code{\$PSIDATADIR/databases/ixyz2database.pl}. It will ask a number of
questions about your intended database and generate a python file
named for your database. Uppercase is preferable for database names
(according to Sherrill lab convention). Note your choice for the route
variable for the next step.
\end{quote}

\item {} 
Edit file database.py
\begin{quote}

According to your responses in to questions in the ixyz2database.pl script,
several bullets will be printed of edits you necessarily or optionally
should make. Copy your new database into \code{\$PSIDATADIR/databases}.
\end{quote}

\end{itemize}


\chapter{Function Intercalls}
\label{index:function-intercalls}
For many of the PSI4 Python functions described above, it makes scientific
sense that they could be called in combination. For instance, one could
optimize all the reagents in a database or compute a
counterpoise-corrected interaction energy with an extrapolated method. The
table below outlines permitted intercalls between functions, showing that
db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This
table is not yet validated for calls with cp().
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|L|L|L|L|}
\hline
\textbf{
Caller
} &  \multicolumn{5}{l|}{\textbf{
Callee
}}\\\hline
\textbf{} & \textbf{
cp
} & \textbf{
db
} & \textbf{
opt
} & \textbf{
cbs
} & \textbf{
energy
}\\\hline

cp
 &  & 
---
 & 
Y
 & 
Y
 & 
Y
\\\hline

db
 & 
---
 &  & 
Y
 & 
Y
 & 
Y
\\\hline

opt
 & 
---
 & 
---
 &  & 
Y
 & 
Y
\\\hline

cbs
 & 
---
 & 
---
 & 
---
 &  & 
Y
\\\hline

energy
 & 
---
 & 
---
 & 
---
 & 
---
 & \\\hline
\end{tabulary}

\end{quote}
\begin{itemize}
\item {} 
The command db(opt(cbs(energy()))) is actually expressed as \code{db(...,
db\_func=opt, opt\_func=cbs)}. The perhaps expected final argument of
\code{cbs\_func=energy} is not necessary since energy() is always the function
called by default. Also, the outermost internal function call (\code{db\_func}
above can be called as just \code{func}. Several examples of intercalls
between Python functions can be found in sample input \emph{pywrap\_all}.

\item {} 
All keyword arguments are passed along to each function traversed in the

\end{itemize}

Python driver, so there should be no concern for separating them, grouping
them, or designating them for a particular function when undertaking a
nested calculation. Where the same keyword is used by multiple functions,
prefixes are added, e.g., \textbf{db\_mode} and \textbf{opt\_mode}.
\begin{itemize}
\item {} 
Function intercalls should not be used in sow/reap mode.

\end{itemize}


\chapter{Embarrassing Parallelism}
\label{index:embarrassing-parallelism}
Many of the tasks automated by Python wrappers consist of a number of
independent psi4 calculations and are thus suited to an embarrassingly
parallel mode of operation. In Psithon, these have been dubbed sow/reap
procedures and have the following general structure.
\begin{itemize}
\item {} 
Prepare an input file, simply adding \code{mode='sow'} to the
argument list of an available Python function. Run this quick job to
produce input files for lengthier calculations.

\item {} 
According to the instructions in the output file of the above step,
run the generated input files in any order on any variety of computers
and architectures. This is the time-intensive portion of the
calculation.

\item {} 
The `sow' stage also produces a \emph{master} input file (with a
\code{mode='reap'} directive). When all the jobs in the above step are
completed, place their output files in the same location as the
\emph{master} input, and run this last, quick job to collect the results.

\end{itemize}
\begin{itemize}
\item {} 
Sow/reap procedures are governed by the \textbf{mode} keyword, choices being
\code{'continuous'}, \code{'sow'}, and \code{'reap'}. Only \code{'sow'} is likely to
be used by the user, as \code{'continuous'} is always the default, and
input files with \code{'reap'} are autogenerated.

\item {} 
Available at present for {\hyperref[index:database]{Database}} and finite difference operation of {\hyperref[index:optimize]{Optimize}}.

\end{itemize}

\begin{notice}{caution}{Caution:}
Some features are not yet implemented. Buy a developer a coffee.
\begin{itemize}
\item {} 
Local options (e.g., \code{set scf e\_convergence 9}) will not get transmitted to the child jobs.

\item {} 
Array options (e.g., \code{set states\_per\_irrep {[}2, 1{]}}) will not get transmitted to the child jobs.

\item {} 
Function intercalls (e.g., db(opt())) are not tested with sow/reap procedures.

\end{itemize}
\end{notice}


\chapter{Psithon Programming Best Practices}
\label{index:psithon-programming-best-practices}\begin{itemize}
\item {} 
Thy python functions shall always have final argument **kwargs, that they may take in and pass on keywords meant for other functions. Yea, even the run\_mcscf(), and run\_ccsd() -type functions that have no use for kwargs. The exceptions are python functions that are only helpers called by a driver function.

\item {} 
Python functions should read the kwargs dictionary and (possibly) add to it. Functions should not pop or remove keywords from kwargs, even those keywords meaningful only to itself. This will ensure that the complete kwargs is available for pickling and sow/reap procedures. The exception is the molecule argument, which is read by the first function that gets ahold of it. This first function activates the molecule and pops it out of kwargs, effectively setting molecule for all subsequent functions. The code below should suffice.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Make sure the molecule the user provided is the active one}
\PYG{k}{if} \PYG{l+s}{'}\PYG{l+s}{molecule}\PYG{l+s}{'} \PYG{o+ow}{in} \PYG{n}{kwargs}\PYG{p}{:}
    \PYG{n}{activate}\PYG{p}{(}\PYG{n}{kwargs}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{molecule}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{del} \PYG{n}{kwargs}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{molecule}\PYG{l+s}{'}\PYG{p}{]}
\PYG{n}{molecule} \PYG{o}{=} \PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{get\PYGZus{}active\PYGZus{}molecule}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{molecule}\PYG{o}{.}\PYG{n}{update\PYGZus{}geometry}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\item {} 
Preferrably, the python function signature (for functions intended to be called in input files) is \code{function(name, **kwargs)}. For functions that have other positional keywords, please bundle them into kwargs at earliest convenience (see {\hyperref[index:database]{Database}} argument db\_name for example).

\item {} 
After the docstring, the first two lines of your function should be the ones below. The first provides a case insensitive handle to the name argument value. The second converts all the kwargs dictionary keys to lowercase versions of themselves, so that input files can be case insensitive.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{lowername} \PYG{o}{=} \PYG{n}{name}\PYG{o}{.}\PYG{n}{lower}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{kwargs} \PYG{o}{=} \PYG{n}{kwargs\PYGZus{}lower}\PYG{p}{(}\PYG{n}{kwargs}\PYG{p}{)}
\end{Verbatim}

\item {} 
Case sensitivity for kwargs dictionary values still needs to be handled. The first line below shows how to convert argument values to lowercase for matching. When not matching a whole value such that regular expressions are needed, the second line below performs a case insensitive match.

\begin{Verbatim}[commandchars=\\\{\}]
if (kwargs['db\_mode'].lower() == 'continuous'):
if re.match(r'\textasciicircum{}sapt', name, flags=re.IGNORECASE):
\end{Verbatim}

\item {} 
Match boolean keywords (db\_cp in the example below) with expressions like the following, which allow case insensitive yes/true/on/1/no/false/off/0 user input. If your argument's value is a derivative level, similarly, use input.der0th, input.der1st, and input.der2nd.

\begin{Verbatim}[commandchars=\\\{\}]
if input.yes.match(str(db\_cp)):
elif input.no.match(str(db\_cp)):
\end{Verbatim}

\item {} 
For keywords that might be used in other functions as well as your own, prepend the argument name with a short representation of your function name. For example, there are keywords cp\_func, db\_func, and opt\_func to request what python function, if not energy(), is called by cp(), database(), and optimize().

\item {} 
Upon checking in a new python file, edit the file \code{psi4/doc/userman/source/index.rst} and follow the instructions therein that your file may be autodocumented here.

\item {} 
Write docstrings! For a major function intended for use in input files, start with the skeleton docstring in \code{psi4/lib/python/example\_docstring} and replace anything that looks like \code{\textless{}this\textgreater{}}. For a behind-the-scenes function or if you don't want the bother of dealing with \href{http://docutils.sourceforge.net/docs/user/rst/quickref.html}{reStructuredText}, just write an ordinary docstring. It will get slurped into the documentation in plain text.

\item {} 
Your python function should follow \href{http://www.python.org/dev/peps/pep-0008/}{PEP8} conventions (without the line-length restriction). I'm aiming for files to pass the line below, unless for good reason. The second line is for database Python files.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{pep8}\PYG{o}{.}\PYG{n}{py} \PYG{o}{-}\PYG{n}{r} \PYG{o}{-}\PYG{o}{-}\PYG{n}{ignore}\PYG{o}{=}\PYG{n}{E501} \PYG{n}{pythonfile}\PYG{o}{.}\PYG{n}{py}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{pep8}\PYG{o}{.}\PYG{n}{py} \PYG{o}{-}\PYG{n}{r} \PYG{o}{-}\PYG{o}{-}\PYG{n}{ignore}\PYG{o}{=}\PYG{n}{E501}\PYG{p}{,}\PYG{n}{E221}\PYG{p}{,}\PYG{n}{E222}\PYG{p}{,}\PYG{n}{E241}\PYG{p}{,}\PYG{n}{E201}\PYG{p}{,}\PYG{n}{E202} \PYG{n}{databasefile}\PYG{o}{.}\PYG{n}{py}
\end{Verbatim}

\item {} 
Your python function should not prevent any test case (\code{make tests}, NOT \code{make longtests}) from passing. A test case(s) should be written and checked in for any major python function, so that others do not break your code. If most of your work was on the python (as opposed to c++) side, the test case prefix pywrap\_ is suggested.

\item {} 
Be sure to set any new PSI variables through lines like those below. Especially if the function returns an energy, set the `current energy' variable. This last is needed to communicate with the optimizer.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{set\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{MP2.5 CORRELATION ENERGY}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{ce\PYGZus{}mp25}\PYG{p}{)}
\PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{set\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{MP2.5 TOTAL ENERGY}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{e\PYGZus{}mp25}\PYG{p}{)}
\PYG{n}{PsiMod}\PYG{o}{.}\PYG{n}{set\PYGZus{}variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{CURRENT ENERGY}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{e\PYGZus{}mp25}\PYG{p}{)}
\end{Verbatim}

\item {} 
Once your python function is fairly stable on its own, it's potential for interoperability with energy()/opt()/cp()/db()/cbs()/etc. should be evaluated. If it makes physical sense that it should work, you should strive to make that interoperability a reality. Some steps:
\begin{itemize}
\item {} 
If any interoperability is possible, define an argument xx\_func, where xx is a short name for your function. Add near the top of your function code like the below (less the final two lines). The net result of this code is that if the user specifies no *\_func arguments, then energy() gets called. If the user defines xx\_func, then its value gets called. If the user defines func, then its value gets reassigned to xx\_func, func itself is deleted, and xx\_func() gets called. Whatever is getting called is stored in func within the function.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Establish function to call}
\PYG{k}{if} \PYG{o+ow}{not}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{xx\PYGZus{}func}\PYG{l+s}{'} \PYG{o+ow}{in} \PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{func}\PYG{l+s}{'} \PYG{o+ow}{in} \PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{kwargs}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{xx\PYGZus{}func}\PYG{l+s}{'}\PYG{p}{]} \PYG{o}{=} \PYG{n}{kwargs}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{func}\PYG{l+s}{'}\PYG{p}{]}
        \PYG{k}{del} \PYG{n}{kwargs}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{func}\PYG{l+s}{'}\PYG{p}{]}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{kwargs}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{xx\PYGZus{}func}\PYG{l+s}{'}\PYG{p}{]} \PYG{o}{=} \PYG{n}{energy}
\PYG{n}{func} \PYG{o}{=} \PYG{n}{kwargs}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{xx\PYGZus{}func}\PYG{l+s}{'}\PYG{p}{]}
\PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{func}\PYG{p}{:}
    \PYG{k}{raise} \PYG{n}{ValidationError}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{Function }\PYG{l+s+se}{\PYGZbs{}'}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+se}{\PYGZbs{}'}\PYG{l+s}{ does not exist to be called by wrapper counterpoise\PYGZus{}correct.}\PYG{l+s}{'} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{func}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{func} \PYG{o+ow}{is} \PYG{n}{db}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{raise} \PYG{n}{ValidationError}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{Wrapper xx is unhappy to be calling function }\PYG{l+s+se}{\PYGZbs{}'}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+se}{\PYGZbs{}'}\PYG{l+s}{.}\PYG{l+s}{'} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{func}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\item {} 
If specific interoperabilities are known, code them in. For example, if xx shouldn't call db, add the last two lines above to the xx function. If db shouldn't call xx, add the following two lines below to the db function.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{p}{(}\PYG{n}{func} \PYG{o+ow}{is} \PYG{n}{xx}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{raise} \PYG{n}{ValidationError}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{Wrapper database is unhappy to be calling function }\PYG{l+s+se}{\PYGZbs{}'}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+se}{\PYGZbs{}'}\PYG{l+s}{.}\PYG{l+s}{'} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{func}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\item {} 
Create a multipart test case that runs some intercalls between your function and others (akin to pywrap\_all). In trials, permute the order of calls a few times to expose any calls that don't clean up after themselves and need further attention.

\item {} 
When all is validated, add your findings to the great interoperability table in the documentation.

\end{itemize}

\end{itemize}


\chapter{Expert: PsiMod Module}
\label{index:expert-psimod-module}

\section{A Secondary Header}
\label{index:a-secondary-header}

\chapter{Expert: Python Modules}
\label{index:expert-python-modules}

\section{aliases}
\label{index:module-aliases}\label{index:aliases}\index{aliases (module)}
Module with functions that call upon those in modules
{\hyperref[index:module-proc]{\code{proc}}}, {\hyperref[index:module-driver]{\code{driver}}}, and {\hyperref[index:module-wrappers]{\code{wrappers}}}.
\begin{description}
\item[{Place in this file quickly defined procedures such as}] \leavevmode\begin{itemize}
\item {} 
aliases for complex methods

\item {} 
simple modifications to existing methods

\end{itemize}

\end{description}
\index{run\_cim() (in module aliases)}

\begin{fulllineitems}
\phantomsection\label{index:aliases.run_cim}\pysiglinewithargsret{\code{aliases.}\bfcode{run\_cim}}{\emph{name}, \emph{**kwargs}}{}
Eugene's CIM driven by Python

\end{fulllineitems}

\index{run\_mp2\_5() (in module aliases)}

\begin{fulllineitems}
\phantomsection\label{index:aliases.run_mp2_5}\pysiglinewithargsret{\code{aliases.}\bfcode{run\_mp2\_5}}{\emph{name}, \emph{**kwargs}}{}
Function that computes MP2.5 energy from results of a DETCI
MP3 calculation.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{energy}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mp2.5}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{run\_plugin\_ccsd\_serial() (in module aliases)}

\begin{fulllineitems}
\phantomsection\label{index:aliases.run_plugin_ccsd_serial}\pysiglinewithargsret{\code{aliases.}\bfcode{run\_plugin\_ccsd\_serial}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module and plugin calls so that
Eugene DePrince's ccsd\_serial plugin can be called via {\hyperref[index:driver.energy]{\code{driver.energy()}}}.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{energy}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{plugin\PYGZus{}ccsd\PYGZus{}serial}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{run\_plugin\_omega() (in module aliases)}

\begin{fulllineitems}
\phantomsection\label{index:aliases.run_plugin_omega}\pysiglinewithargsret{\code{aliases.}\bfcode{run\_plugin\_omega}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module and plugin calls, as well
as typical options, to access Rob Parrish's omega plugin.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{energy}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{plugin\PYGZus{}omega}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{sherrillgroup\_gold\_standard() (in module aliases)}

\begin{fulllineitems}
\phantomsection\label{index:aliases.sherrillgroup_gold_standard}\pysiglinewithargsret{\code{aliases.}\bfcode{sherrillgroup\_gold\_standard}}{\emph{name='mp2'}, \emph{**kwargs}}{}
Function to call the quantum chemical method known as `Gold Standard'
in the Sherrill group. Uses {\hyperref[index:wrappers.complete_basis_set]{\code{wrappers.complete\_basis\_set()}}} to evaluateo
the following expression. Two-point extrapolation of the correlation energy
performed according to {\hyperref[index:wrappers.corl_xtpl_helgaker_2]{\code{wrappers.corl\_xtpl\_helgaker\_2()}}}.
\begin{gather}
\begin{split}E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{energy}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{sherrillgroup\PYGZus{}gold\PYGZus{}standard}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}



\section{driver}
\label{index:module-driver}\label{index:driver}\index{driver (module)}
Module with a \emph{procedures} dictionary specifying available quantum
chemical methods and functions driving the main quantum chemical
functionality, namely single-point energies, geometry optimizations,
response properties, and vibrational frequency calculations.
\index{gradient() (in module driver)}

\begin{fulllineitems}
\phantomsection\label{index:driver.gradient}\pysiglinewithargsret{\code{driver.}\bfcode{gradient}}{\emph{name}, \emph{**kwargs}}{}
Function complementary to optimize(). Carries out one gradient pass,
deciding analytic or finite difference.

\end{fulllineitems}

\index{hessian() (in module driver)}

\begin{fulllineitems}
\phantomsection\label{index:driver.hessian}\pysiglinewithargsret{\code{driver.}\bfcode{hessian}}{\emph{name}, \emph{**kwargs}}{}
Function to compute force constants. Presently identical to frequency().

\end{fulllineitems}

\index{parse\_arbitrary\_order() (in module driver)}

\begin{fulllineitems}
\phantomsection\label{index:driver.parse_arbitrary_order}\pysiglinewithargsret{\code{driver.}\bfcode{parse\_arbitrary\_order}}{\emph{name}}{}
Function to parse name string into a method family like CI or MRCC and specific
level information like 4 for CISDTQ or MRCCSDTQ.

\end{fulllineitems}

\index{parse\_cotton\_irreps() (in module driver)}

\begin{fulllineitems}
\phantomsection\label{index:driver.parse_cotton_irreps}\pysiglinewithargsret{\code{driver.}\bfcode{parse\_cotton\_irreps}}{\emph{irrep}}{}
Function to return validated Cotton ordering index from string or integer
irreducible representation \emph{irrep}.

\end{fulllineitems}



\section{input}
\label{index:input}\label{index:module-input}\index{input (module)}
Module import
\index{process\_input() (in module input)}

\begin{fulllineitems}
\phantomsection\label{index:input.process_input}\pysiglinewithargsret{\code{input.}\bfcode{process\_input}}{\emph{raw\_input}, \emph{print\_level=1}}{}
\end{fulllineitems}



\section{molutil}
\label{index:module-molutil}\label{index:molutil}\index{molutil (module)}
Module with utility functions that act on molecule objects.
\index{activate() (in module molutil)}

\begin{fulllineitems}
\phantomsection\label{index:molutil.activate}\pysiglinewithargsret{\code{molutil.}\bfcode{activate}}{\emph{mol}}{}
Function to set molecule object \emph{mol} as the current active molecule.

\end{fulllineitems}

\index{dynamic\_variable\_bind() (in module molutil)}

\begin{fulllineitems}
\phantomsection\label{index:molutil.dynamic_variable_bind}\pysiglinewithargsret{\code{molutil.}\bfcode{dynamic\_variable\_bind}}{\emph{cls}}{}
Function to bind PsiMod.Molecule class.

\end{fulllineitems}

\index{extract\_cluster\_indexing() (in module molutil)}

\begin{fulllineitems}
\phantomsection\label{index:molutil.extract_cluster_indexing}\pysiglinewithargsret{\code{molutil.}\bfcode{extract\_cluster\_indexing}}{\emph{mol}, \emph{cluster\_size=0}}{}
Function to returns a LIST of all subclusters of the molecule \emph{mol} of
real size \emph{cluster\_size}. If \emph{cluster\_size} = 0, returns all possible
combinations of cluster size.

\end{fulllineitems}

\index{extract\_clusters() (in module molutil)}

\begin{fulllineitems}
\phantomsection\label{index:molutil.extract_clusters}\pysiglinewithargsret{\code{molutil.}\bfcode{extract\_clusters}}{\emph{mol}, \emph{ghost=True}, \emph{cluster\_size=0}}{}
Function to return all subclusters of the molecule \emph{mol} of
real size \emph{cluster\_size} and all other atoms ghosted if \emph{ghost}
equals true, all other atoms discarded if \emph{ghost} is false. If
\emph{cluster\_size} = 0, returns all possible combinations of cluster size.

\end{fulllineitems}

\index{geometry() (in module molutil)}

\begin{fulllineitems}
\phantomsection\label{index:molutil.geometry}\pysiglinewithargsret{\code{molutil.}\bfcode{geometry}}{\emph{geom}, \emph{name='default'}}{}
Function to create a molecule object of name \emph{name}
from the geometry in string \emph{geom}.

\end{fulllineitems}

\index{new\_get\_attr() (in module molutil)}

\begin{fulllineitems}
\phantomsection\label{index:molutil.new_get_attr}\pysiglinewithargsret{\code{molutil.}\bfcode{new\_get\_attr}}{\emph{self}, \emph{name}}{}
Function to redefine get\_attr method of molecule class.

\end{fulllineitems}

\index{new\_set\_attr() (in module molutil)}

\begin{fulllineitems}
\phantomsection\label{index:molutil.new_set_attr}\pysiglinewithargsret{\code{molutil.}\bfcode{new\_set\_attr}}{\emph{self}, \emph{name}, \emph{value}}{}
Function to redefine set\_attr method of molecule class.

\end{fulllineitems}



\section{physconst}
\label{index:physconst}\label{index:module-physconst}\index{physconst (module)}

\section{proc}
\label{index:proc}\label{index:module-proc}\index{proc (module)}
Module with functions that encode the sequence of PSI module
calls for each of the \emph{name} values of the energy(), optimize(),
response(), and frequency() function.
\index{run\_adc() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_adc}\pysiglinewithargsret{\code{proc.}\bfcode{run\_adc}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
an algebraic diagrammatic construction calculation.

\begin{notice}{caution}{Caution:}
Get rid of active molecule lines- should be handled in energy.
\end{notice}

\end{fulllineitems}

\index{run\_bccd() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_bccd}\pysiglinewithargsret{\code{proc.}\bfcode{run\_bccd}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a Brueckner CCD calculation.

\end{fulllineitems}

\index{run\_bccd\_t() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_bccd_t}\pysiglinewithargsret{\code{proc.}\bfcode{run\_bccd\_t}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a Brueckner CCD(T) calculation.

\end{fulllineitems}

\index{run\_cc\_gradient() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_cc_gradient}\pysiglinewithargsret{\code{proc.}\bfcode{run\_cc\_gradient}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a CCSD and CCSD(T) gradient calculation.

\end{fulllineitems}

\index{run\_cc\_response() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_cc_response}\pysiglinewithargsret{\code{proc.}\bfcode{run\_cc\_response}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a CC2 and CCSD calculation.

\end{fulllineitems}

\index{run\_ccenergy() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_ccenergy}\pysiglinewithargsret{\code{proc.}\bfcode{run\_ccenergy}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a CCSD, CC2, and CC3 calculation.

\end{fulllineitems}

\index{run\_dcft() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_dcft}\pysiglinewithargsret{\code{proc.}\bfcode{run\_dcft}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a density cumulant functional theory calculation.

\end{fulllineitems}

\index{run\_detci() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_detci}\pysiglinewithargsret{\code{proc.}\bfcode{run\_detci}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a configuration interaction calculation, namely FCI,
CIn, MPn, and ZAPTn.

\end{fulllineitems}

\index{run\_dfcc() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_dfcc}\pysiglinewithargsret{\code{proc.}\bfcode{run\_dfcc}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a density-fitted coupled-cluster calculation.

\end{fulllineitems}

\index{run\_dfmp2() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_dfmp2}\pysiglinewithargsret{\code{proc.}\bfcode{run\_dfmp2}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a density-fitted MP2 calculation.

\begin{notice}{caution}{Caution:}
Get rid of madness-era restart file
\end{notice}

\end{fulllineitems}

\index{run\_eom\_cc() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_eom_cc}\pysiglinewithargsret{\code{proc.}\bfcode{run\_eom\_cc}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3.

\end{fulllineitems}

\index{run\_eom\_cc\_gradient() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_eom_cc_gradient}\pysiglinewithargsret{\code{proc.}\bfcode{run\_eom\_cc\_gradient}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
an EOM-CCSD gradient calculation.

\end{fulllineitems}

\index{run\_libfock() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_libfock}\pysiglinewithargsret{\code{proc.}\bfcode{run\_libfock}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a calculation through libfock, namely RCPHF,
RCIS, RTDHF, RTDA, and RTDDFT.

\end{fulllineitems}

\index{run\_mcscf() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_mcscf}\pysiglinewithargsret{\code{proc.}\bfcode{run\_mcscf}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a multiconfigurational self-consistent-field calculation.

\end{fulllineitems}

\index{run\_mp2() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_mp2}\pysiglinewithargsret{\code{proc.}\bfcode{run\_mp2}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a MP2 calculation.

\end{fulllineitems}

\index{run\_mp2\_gradient() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_mp2_gradient}\pysiglinewithargsret{\code{proc.}\bfcode{run\_mp2\_gradient}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a MP2 gradient calculation.

\end{fulllineitems}

\index{run\_mp2c() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_mp2c}\pysiglinewithargsret{\code{proc.}\bfcode{run\_mp2c}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a coupled MP2 calculation.

\end{fulllineitems}

\index{run\_mp2drpa() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_mp2drpa}\pysiglinewithargsret{\code{proc.}\bfcode{run\_mp2drpa}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a MP2-DRPA calculation.

\end{fulllineitems}

\index{run\_mrcc() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_mrcc}\pysiglinewithargsret{\code{proc.}\bfcode{run\_mrcc}}{\emph{name}, \emph{**kwargs}}{}
Function that prepares environment and input files
for a calculation calling Kallay's MRCC code.

\end{fulllineitems}

\index{run\_psimrcc() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_psimrcc}\pysiglinewithargsret{\code{proc.}\bfcode{run\_psimrcc}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for a PSIMRCC computation
using a reference from the MCSCF module

\end{fulllineitems}

\index{run\_psimrcc\_scf() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_psimrcc_scf}\pysiglinewithargsret{\code{proc.}\bfcode{run\_psimrcc\_scf}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for a PSIMRCC computation
using a reference from the SCF module

\end{fulllineitems}

\index{run\_sapt() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_sapt}\pysiglinewithargsret{\code{proc.}\bfcode{run\_sapt}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a SAPT calculation of any level.

\end{fulllineitems}

\index{run\_sapt\_ct() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_sapt_ct}\pysiglinewithargsret{\code{proc.}\bfcode{run\_sapt\_ct}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a charge-transfer SAPT calcuation of any level.

\end{fulllineitems}

\index{run\_scf() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_scf}\pysiglinewithargsret{\code{proc.}\bfcode{run\_scf}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a self-consistent-field theory (HF \& DFT) calculation.

\end{fulllineitems}

\index{run\_scf\_gradient() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.run_scf_gradient}\pysiglinewithargsret{\code{proc.}\bfcode{run\_scf\_gradient}}{\emph{name}, \emph{**kwargs}}{}
Function encoding sequence of PSI module calls for
a SCF gradient calculation.

\end{fulllineitems}

\index{scf\_helper() (in module proc)}

\begin{fulllineitems}
\phantomsection\label{index:proc.scf_helper}\pysiglinewithargsret{\code{proc.}\bfcode{scf\_helper}}{\emph{name}, \emph{**kwargs}}{}
Function serving as helper to SCF, choosing whether to cast
up or just run SCF with a standard guess. This preserves
previous SCF options set by other procedures (e.g., SAPT
output file types for SCF).

\end{fulllineitems}



\section{procutil}
\label{index:procutil}\label{index:module-procutil}\index{procutil (module)}
Module with utility functions used by several Python functions.
\index{format\_kwargs\_for\_input() (in module procutil)}

\begin{fulllineitems}
\phantomsection\label{index:procutil.format_kwargs_for_input}\pysiglinewithargsret{\code{procutil.}\bfcode{format\_kwargs\_for\_input}}{\emph{filename}, \emph{lmode=1}, \emph{**kwargs}}{}
Function to pickle to file \emph{filename} the options dictionary
\emph{kwargs}. Mode \emph{lmode} =2 pickles appropriate settings for
reap mode. Used to capture Python options information for
distributed (sow/reap) input files.

\end{fulllineitems}

\index{format\_molecule\_for\_input() (in module procutil)}

\begin{fulllineitems}
\phantomsection\label{index:procutil.format_molecule_for_input}\pysiglinewithargsret{\code{procutil.}\bfcode{format\_molecule\_for\_input}}{\emph{mol}}{}
Function to return a string of the output of
{\hyperref[index:input.process_input]{\code{input.process\_input()}}} applied to the XYZ
format of molecule \emph{mol}. Used to capture molecule
information for distributed (sow/reap) input files.

\end{fulllineitems}

\index{format\_options\_for\_input() (in module procutil)}

\begin{fulllineitems}
\phantomsection\label{index:procutil.format_options_for_input}\pysiglinewithargsret{\code{procutil.}\bfcode{format\_options\_for\_input}}{}{}
Function to return a string of commands to replicate the
current state of user-modified options. Used to capture C++
options information for distributed (sow/reap) input files.

\begin{notice}{caution}{Caution:}
Some features are not yet implemented. Buy a developer a coffee.
\begin{itemize}
\item {} 
Does not cover local (as opposed to global) options.

\item {} 
Does not work with array-type options.

\end{itemize}
\end{notice}

\end{fulllineitems}

\index{get\_psifile() (in module procutil)}

\begin{fulllineitems}
\phantomsection\label{index:procutil.get_psifile}\pysiglinewithargsret{\code{procutil.}\bfcode{get\_psifile}}{\emph{fileno}, \emph{pidspace=`32433'}}{}
Function to return the full path and filename for psi file
\emph{fileno} (e.g., psi.32) in current namespace \emph{pidspace}.

\end{fulllineitems}

\index{kwargs\_lower() (in module procutil)}

\begin{fulllineitems}
\phantomsection\label{index:procutil.kwargs_lower}\pysiglinewithargsret{\code{procutil.}\bfcode{kwargs\_lower}}{\emph{kwargs}}{}
Function to rebuild and return \emph{kwargs} dictionary
with all keys made lowercase. Should be called by every
function that could be called directly by the user.

\end{fulllineitems}



\section{psiexceptions}
\label{index:module-psiexceptions}\label{index:psiexceptions}\index{psiexceptions (module)}
Module with non-generic exceptions classes.
\index{PsiException}

\begin{fulllineitems}
\phantomsection\label{index:psiexceptions.PsiException}\pysigline{\strong{exception }\code{psiexceptions.}\bfcode{PsiException}}
Error class for Psi.

\end{fulllineitems}

\index{ValidationError}

\begin{fulllineitems}
\phantomsection\label{index:psiexceptions.ValidationError}\pysiglinewithargsret{\strong{exception }\code{psiexceptions.}\bfcode{ValidationError}}{\emph{msg}}{}
Error called for problems with the input file. Prints
error message \emph{msg} to standard output stream and output file.

\end{fulllineitems}



\section{pubchem}
\label{index:pubchem}\label{index:module-pubchem}\index{pubchem (module)}
Queries the PubChem database using a compound name (i.e. 1,3,5-hexatriene)
to obtain a molecule string that can be passed to Molecule.

\begin{Verbatim}[commandchars=\\\{\}]
results = getPubChemObj("1,3,5-hexatriene")

Results is an array of results from PubChem matches to your query.
  for entry in results:
     entry["CID"]         =\textgreater{} PubChem compound identifer
     entry["IUPAC"]       =\textgreater{} IUPAC name for the resulting compound
     entry["PubChemObj"]  =\textgreater{} instance of PubChemObj for this compound

     entry["PubChemObj"].getMoleculeString()   =\textgreater{} returns a string compatible
                                                  with PSI4's Molecule creation
\end{Verbatim}
\index{PubChemObj (class in pubchem)}

\begin{fulllineitems}
\phantomsection\label{index:pubchem.PubChemObj}\pysiglinewithargsret{\strong{class }\code{pubchem.}\bfcode{PubChemObj}}{\emph{cid}, \emph{mf}, \emph{iupac}}{}~\index{getCartesian() (pubchem.PubChemObj method)}

\begin{fulllineitems}
\phantomsection\label{index:pubchem.PubChemObj.getCartesian}\pysiglinewithargsret{\bfcode{getCartesian}}{}{}
Function to return a string of the atom symbol and XYZ
coordinates of the PubChem object.

\end{fulllineitems}

\index{getMoleculeString() (pubchem.PubChemObj method)}

\begin{fulllineitems}
\phantomsection\label{index:pubchem.PubChemObj.getMoleculeString}\pysiglinewithargsret{\bfcode{getMoleculeString}}{}{}
Function to obtain a molecule string through
getCartesian() or fail.

\end{fulllineitems}

\index{getSDF() (pubchem.PubChemObj method)}

\begin{fulllineitems}
\phantomsection\label{index:pubchem.PubChemObj.getSDF}\pysiglinewithargsret{\bfcode{getSDF}}{}{}
Function to return the SDF (structure-data file) of the PubChem object.

\end{fulllineitems}

\index{getXYZFile() (pubchem.PubChemObj method)}

\begin{fulllineitems}
\phantomsection\label{index:pubchem.PubChemObj.getXYZFile}\pysiglinewithargsret{\bfcode{getXYZFile}}{}{}
Function to obtain preferentially a molecule string
through getCartesian() or a query string otherwise.

\end{fulllineitems}

\index{name() (pubchem.PubChemObj method)}

\begin{fulllineitems}
\phantomsection\label{index:pubchem.PubChemObj.name}\pysiglinewithargsret{\bfcode{name}}{}{}
Function to return the IUPAC name of the PubChem object.

\end{fulllineitems}


\end{fulllineitems}

\index{getPubChemResults() (in module pubchem)}

\begin{fulllineitems}
\phantomsection\label{index:pubchem.getPubChemResults}\pysiglinewithargsret{\code{pubchem.}\bfcode{getPubChemResults}}{\emph{name}}{}
Function to query the PubChem database for molecules matching the
input string. Builds a PubChem object if found.

\end{fulllineitems}



\section{qmmm}
\label{index:qmmm}\label{index:module-qmmm}\index{qmmm (module)}
Module with classes to integrate MM charges into
a QM calculation.
\index{Diffuse (class in qmmm)}

\begin{fulllineitems}
\phantomsection\label{index:qmmm.Diffuse}\pysiglinewithargsret{\strong{class }\code{qmmm.}\bfcode{Diffuse}}{\emph{molecule}, \emph{basisname}, \emph{ribasisname}}{}~\index{fitGeneral() (qmmm.Diffuse method)}

\begin{fulllineitems}
\phantomsection\label{index:qmmm.Diffuse.fitGeneral}\pysiglinewithargsret{\bfcode{fitGeneral}}{}{}
Function to perform a general fit of diffuse charges
to wavefunction density.

\end{fulllineitems}

\index{fitScf() (qmmm.Diffuse method)}

\begin{fulllineitems}
\phantomsection\label{index:qmmm.Diffuse.fitScf}\pysiglinewithargsret{\bfcode{fitScf}}{}{}
Function to run scf and fit a system of diffuse charges to
resulting density.

\end{fulllineitems}

\index{populateExtern() (qmmm.Diffuse method)}

\begin{fulllineitems}
\phantomsection\label{index:qmmm.Diffuse.populateExtern}\pysiglinewithargsret{\bfcode{populateExtern}}{\emph{extern}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{QMMM (class in qmmm)}

\begin{fulllineitems}
\phantomsection\label{index:qmmm.QMMM}\pysigline{\strong{class }\code{qmmm.}\bfcode{QMMM}}~\index{addChargeAngstrom() (qmmm.QMMM method)}

\begin{fulllineitems}
\phantomsection\label{index:qmmm.QMMM.addChargeAngstrom}\pysiglinewithargsret{\bfcode{addChargeAngstrom}}{\emph{Q}, \emph{x}, \emph{y}, \emph{z}}{}
Function to add a point charge of magnitude \emph{Q} at
position (\emph{x}, \emph{y}, \emph{z}) Angstroms.

\end{fulllineitems}

\index{addChargeBohr() (qmmm.QMMM method)}

\begin{fulllineitems}
\phantomsection\label{index:qmmm.QMMM.addChargeBohr}\pysiglinewithargsret{\bfcode{addChargeBohr}}{\emph{Q}, \emph{x}, \emph{y}, \emph{z}}{}
Function to add a point charge of magnitude \emph{Q} at
position (\emph{x}, \emph{y}, \emph{z}) Bohr.

\end{fulllineitems}

\index{addDiffuse() (qmmm.QMMM method)}

\begin{fulllineitems}
\phantomsection\label{index:qmmm.QMMM.addDiffuse}\pysiglinewithargsret{\bfcode{addDiffuse}}{\emph{diffuse}}{}
Function to add a diffuse charge field \emph{diffuse}.

\end{fulllineitems}

\index{populateExtern() (qmmm.QMMM method)}

\begin{fulllineitems}
\phantomsection\label{index:qmmm.QMMM.populateExtern}\pysiglinewithargsret{\bfcode{populateExtern}}{}{}
Function to define a charge field external to the
molecule through point and diffuse charges.

\end{fulllineitems}


\end{fulllineitems}



\section{text}
\label{index:text}\label{index:module-text}\index{text (module)}
Module with utility classes and functions related
to data tables and text.
\index{Table (class in text)}

\begin{fulllineitems}
\phantomsection\label{index:text.Table}\pysiglinewithargsret{\strong{class }\code{text.}\bfcode{Table}}{\emph{rows=()}, \emph{row\_label\_width=10}, \emph{row\_label\_precision=4}, \emph{cols=()}, \emph{width=16}, \emph{precision=10}}{}
Class defining a flexible Table object for storing data.
\index{absolute\_to\_relative() (text.Table method)}

\begin{fulllineitems}
\phantomsection\label{index:text.Table.absolute_to_relative}\pysiglinewithargsret{\bfcode{absolute\_to\_relative}}{\emph{Factor=627.5095}}{}
Function to shift the data of each column of the Table object
such that the lowest value is zero. A scaling factor of \emph{Factor} is applied.

\end{fulllineitems}

\index{copy() (text.Table method)}

\begin{fulllineitems}
\phantomsection\label{index:text.Table.copy}\pysiglinewithargsret{\bfcode{copy}}{}{}
Function to return a copy of the Table object.

\end{fulllineitems}

\index{format\_label() (text.Table method)}

\begin{fulllineitems}
\phantomsection\label{index:text.Table.format_label}\pysiglinewithargsret{\bfcode{format\_label}}{}{}
Function to pad the width of Table object labels.

\end{fulllineitems}

\index{format\_values() (text.Table method)}

\begin{fulllineitems}
\phantomsection\label{index:text.Table.format_values}\pysiglinewithargsret{\bfcode{format\_values}}{\emph{values}}{}
Function to pad the width of Table object data cells.

\end{fulllineitems}

\index{save() (text.Table method)}

\begin{fulllineitems}
\phantomsection\label{index:text.Table.save}\pysiglinewithargsret{\bfcode{save}}{\emph{file}}{}
Function to save string of the Table object to \emph{file}.

\end{fulllineitems}

\index{scale() (text.Table method)}

\begin{fulllineitems}
\phantomsection\label{index:text.Table.scale}\pysiglinewithargsret{\bfcode{scale}}{\emph{Factor=627.5095}}{}
Function to apply a scaling factor \emph{Factor} to the
data of the Table object.

\end{fulllineitems}


\end{fulllineitems}

\index{banner() (in module text)}

\begin{fulllineitems}
\phantomsection\label{index:text.banner}\pysiglinewithargsret{\code{text.}\bfcode{banner}}{\emph{text}, \emph{type=1}, \emph{width=35}}{}
Function to print \emph{text} to output file in a banner of
minimum width \emph{width} and minimum three-line height for
\emph{type} = 1 or one-line height for \emph{type} = 2.

\end{fulllineitems}

\index{print\_stderr() (in module text)}

\begin{fulllineitems}
\phantomsection\label{index:text.print_stderr}\pysiglinewithargsret{\code{text.}\bfcode{print\_stderr}}{\emph{stuff}}{}
Function to print \emph{stuff} to standard error stream.

\end{fulllineitems}

\index{print\_stdout() (in module text)}

\begin{fulllineitems}
\phantomsection\label{index:text.print_stdout}\pysiglinewithargsret{\code{text.}\bfcode{print\_stdout}}{\emph{stuff}}{}
Function to print \emph{stuff} to standard output stream.

\end{fulllineitems}



\section{util}
\label{index:util}\label{index:module-util}\index{util (module)}
Module with utility functions for use in input files.
\index{compare\_integers() (in module util)}

\begin{fulllineitems}
\phantomsection\label{index:util.compare_integers}\pysiglinewithargsret{\code{util.}\bfcode{compare\_integers}}{\emph{expected}, \emph{computed}, \emph{label}}{}
Function to compare two integers. Prints {\hyperref[index:util.success]{\code{util.success()}}}
when value \emph{computed} matches value \emph{expected}.
Performs a system exit on failure. Used in input files in the test suite.

\end{fulllineitems}

\index{compare\_matrices() (in module util)}

\begin{fulllineitems}
\phantomsection\label{index:util.compare_matrices}\pysiglinewithargsret{\code{util.}\bfcode{compare\_matrices}}{\emph{expected}, \emph{computed}, \emph{digits}, \emph{label}}{}
Function to compare two matrices. Prints {\hyperref[index:util.success]{\code{util.success()}}}
when elements of matrix \emph{computed} match elements of matrix \emph{expected} to
number of \emph{digits}. Performs a system exit on failure to match symmetry
structure, dimensions, or element values. Used in input files in the test suite.

\end{fulllineitems}

\index{compare\_strings() (in module util)}

\begin{fulllineitems}
\phantomsection\label{index:util.compare_strings}\pysiglinewithargsret{\code{util.}\bfcode{compare\_strings}}{\emph{expected}, \emph{computed}, \emph{label}}{}
Function to compare two strings. Prints {\hyperref[index:util.success]{\code{util.success()}}}
when string \emph{computed} exactly matches string \emph{expected}.
Performs a system exit on failure. Used in input files in the test suite.

\end{fulllineitems}

\index{compare\_values() (in module util)}

\begin{fulllineitems}
\phantomsection\label{index:util.compare_values}\pysiglinewithargsret{\code{util.}\bfcode{compare\_values}}{\emph{expected}, \emph{computed}, \emph{digits}, \emph{label}}{}
Function to compare two values. Prints {\hyperref[index:util.success]{\code{util.success()}}}
when value \emph{computed} matches value \emph{expected} to number of \emph{digits}.
Performs a system exit on failure. Used in input files in the test suite.

\end{fulllineitems}

\index{compare\_vectors() (in module util)}

\begin{fulllineitems}
\phantomsection\label{index:util.compare_vectors}\pysiglinewithargsret{\code{util.}\bfcode{compare\_vectors}}{\emph{expected}, \emph{computed}, \emph{digits}, \emph{label}}{}
Function to compare two vectors. Prints {\hyperref[index:util.success]{\code{util.success()}}}
when elements of vector \emph{computed} match elements of vector \emph{expected} to
number of \emph{digits}. Performs a system exit on failure to match symmetry
structure, dimension, or element values. Used in input files in the test suite.

\end{fulllineitems}

\index{get\_memory() (in module util)}

\begin{fulllineitems}
\phantomsection\label{index:util.get_memory}\pysiglinewithargsret{\code{util.}\bfcode{get\_memory}}{}{}
Function to return the total memory allocation.

\end{fulllineitems}

\index{get\_num\_threads() (in module util)}

\begin{fulllineitems}
\phantomsection\label{index:util.get_num_threads}\pysiglinewithargsret{\code{util.}\bfcode{get\_num\_threads}}{}{}
Function to return the number of threads to parallelize across.

\end{fulllineitems}

\index{set\_memory() (in module util)}

\begin{fulllineitems}
\phantomsection\label{index:util.set_memory}\pysiglinewithargsret{\code{util.}\bfcode{set\_memory}}{\emph{bytes}}{}
Function to reset the total memory allocation.

\end{fulllineitems}

\index{set\_num\_threads() (in module util)}

\begin{fulllineitems}
\phantomsection\label{index:util.set_num_threads}\pysiglinewithargsret{\code{util.}\bfcode{set\_num\_threads}}{\emph{nthread}}{}
Function to reset the number of threads to parallelize across.

\end{fulllineitems}

\index{success() (in module util)}

\begin{fulllineitems}
\phantomsection\label{index:util.success}\pysiglinewithargsret{\code{util.}\bfcode{success}}{\emph{label}}{}
Function to print a `\emph{label}...PASSED' line to screen.
Used by {\hyperref[index:util.compare_values]{\code{util.compare\_values()}}} family when functions pass.

\end{fulllineitems}



\section{wrappers}
\label{index:wrappers}\label{index:module-wrappers}\index{wrappers (module)}
Module with functions that call the four main {\hyperref[index:module-driver]{\code{driver}}}
functions: {\hyperref[index:driver.energy]{\code{driver.energy}}}, {\hyperref[index:driver.optimize]{\code{driver.optimize}}},
{\hyperref[index:driver.response]{\code{driver.response}}}, and {\hyperref[index:driver.frequency]{\code{driver.frequency}}}.
\index{call\_function\_in\_1st\_argument() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{index:wrappers.call_function_in_1st_argument}\pysiglinewithargsret{\code{wrappers.}\bfcode{call\_function\_in\_1st\_argument}}{\emph{funcarg}, \emph{**largs}}{}
Function to make primary function call to energy(), opt(), etc.
with options dictionary \emph{largs}.
Useful when \emph{funcarg} to call is stored in variable.

\end{fulllineitems}

\index{drop\_duplicates() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{index:wrappers.drop_duplicates}\pysiglinewithargsret{\code{wrappers.}\bfcode{drop\_duplicates}}{\emph{seq}}{}
Function that given an array \emph{seq}, returns an array without any duplicate
entries. There is no guarantee of which duplicate entry is dropped.

\end{fulllineitems}

\index{n\_body() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{index:wrappers.n_body}\pysiglinewithargsret{\code{wrappers.}\bfcode{n\_body}}{\emph{name}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{reconstitute\_bracketed\_basis() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{index:wrappers.reconstitute_bracketed_basis}\pysiglinewithargsret{\code{wrappers.}\bfcode{reconstitute\_bracketed\_basis}}{\emph{needarray}}{}
Function to reform a bracketed basis set string from a sequential series
of basis sets (e.g, form `cc-pv{[}q5{]}z' from array {[}cc-pvqz, cc-pv5z{]}). The
basis set array is extracted from the \emph{f\_basis} field of a \emph{NEED} dictionary in
{\hyperref[index:wrappers.complete_basis_set]{\code{wrappers.complete\_basis\_set()}}}. Result is used to print a nicely
formatted basis set string in the results table.

\end{fulllineitems}

\index{split\_menial() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{index:wrappers.split_menial}\pysiglinewithargsret{\code{wrappers.}\bfcode{split\_menial}}{\emph{menial}}{}
Function used by {\hyperref[index:wrappers.complete_basis_set]{\code{wrappers.complete\_basis\_set()}}} to separate
\emph{menial} `scftot' into {[}scf, tot{]} and `mp2corl' into {[}mp2, corl{]}.

\end{fulllineitems}

\index{tblhead() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{index:wrappers.tblhead}\pysiglinewithargsret{\code{wrappers.}\bfcode{tblhead}}{\emph{tbl\_maxrgt}, \emph{tbl\_delimit}, \emph{ttype}}{}
Function that prints the header for the changable-width results tables in db().
\emph{tbl\_maxrgt} is the number of reagent columns the table must plan for. \emph{tbl\_delimit}
is a string of dashes of the correct length to set off the table. \emph{ttype} is 1 for
tables comparing the computed values to the reference or 2 for simple tabulation
and sum of the computed values.

\end{fulllineitems}

\index{validate\_bracketed\_basis() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{index:wrappers.validate_bracketed_basis}\pysiglinewithargsret{\code{wrappers.}\bfcode{validate\_bracketed\_basis}}{\emph{basisstring}}{}
Function to transform and validate basis sets for cbs(). A basis set with no
paired square brackets is passed through with zeta level 0 (e.g., `6-31+G(d,p)'
is returned as {[}6-31+G(d,p){]} and {[}0{]}). A basis set with square brackets is
checked for sensible sequence and Dunning-ness and returned as separate basis
sets (e.g., `cc-pV{[}Q5{]}Z' is returned as {[}cc-pVQZ, cc-pV5Z{]} and {[}4, 5{]}). Note
that this function has no communication with the basis set library to check
if the basis actually exists. Used by {\hyperref[index:wrappers.complete_basis_set]{\code{wrappers.complete\_basis\_set()}}}.

\end{fulllineitems}

\index{validate\_scheme\_args() (in module wrappers)}

\begin{fulllineitems}
\phantomsection\label{index:wrappers.validate_scheme_args}\pysiglinewithargsret{\code{wrappers.}\bfcode{validate\_scheme\_args}}{\emph{functionname}, \emph{**largs}}{}
Function called by each extrapolation scheme in {\hyperref[index:wrappers.complete_basis_set]{\code{wrappers.complete\_basis\_set()}}}.
Checks that all the input arguments are present and suitable so that
the scheme function can focus on defining the extrapolation.

\end{fulllineitems}



\chapter{Indices and Tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}


\chapter{References}
\label{index:references}

\chapter{Glossary}
\label{index:glossary}

\section{SAPT}
\label{index:sapt}\begin{description}
\item[{\index{DEBUG|textbf}DEBUG}] \leavevmode\phantomsection\label{index:term-18}
Print lots of intermediate quantities that are not usually interesting.
For SAPT, it will also do additional work (which is not optimized for
large systems) so don't turn it on.
\begin{itemize}
\item {} 
\textbf{Type}: integer

\item {} 
\textbf{Default}: 0

\end{itemize}

\end{description}
\begin{description}
\item[{\index{XXX|textbf}XXX}] \leavevmode\phantomsection\label{index:term-xxx}
xxxxx
\begin{itemize}
\item {} 
\textbf{Type}:

\item {} 
\textbf{Possible Values}:

\item {} 
\textbf{Default}:

\end{itemize}

\end{description}
\begin{description}
\item[{\index{AIO-CPHF|textbf}AIO-CPHF}] \leavevmode\phantomsection\label{index:term-20}
Do disk I/O asynchronously during the solution of the CPHF equations.
This option may speed up the computation slightly, however its use
will cause PSI4 to spawn an additional thread.
\begin{itemize}
\item {} 
\textbf{Type}: {\hyperref[index:boolean]{boolean}}

\item {} 
\textbf{Default}: FALSE

\end{itemize}

\end{description}
\begin{description}
\item[{\index{AIO\_DF\_INTS|textbf}AIO\_DF\_INTS}] \leavevmode\phantomsection\label{index:term-21}
Do disk I/O asynchronously during the formation of the DF integrals.
This option may speed up the computation slightly, however its use
will cause PSI4 to spawn an additional thread.
\begin{itemize}
\item {} 
\textbf{Type}: {\hyperref[index:boolean]{boolean}}

\item {} 
\textbf{Default}: FALSE

\end{itemize}

\end{description}
\begin{description}
\item[{\index{BASIS|textbf}BASIS}] \leavevmode\phantomsection\label{index:term-22}
The basis set used to describe the monomer molecular orbitals.
\begin{itemize}
\item {} 
\textbf{Type}: string

\item {} 
\textbf{Possible Values}: \href{http://sirius.chem.vt.edu/trac/wiki/InstalledBasisSets}{Basis Sets}

\item {} 
\textbf{Default}: none

\end{itemize}

\end{description}
\begin{description}
\item[{\index{D\_CONVERGENCE|textbf}D\_CONVERGENCE}] \leavevmode\phantomsection\label{index:term-23}
Convergence of the residual of the CPHF coefficients needed for
the $E_{ind,resp}^{(20)}$.
\begin{itemize}
\item {} 
\textbf{Type}: {\hyperref[index:conv-double]{conv double}}

\item {} 
\textbf{Default}: $1.0 \times 10^{-8}$

\end{itemize}

\end{description}
\begin{description}
\item[{\index{DENOMINATOR\_ALGORITHM|textbf}DENOMINATOR\_ALGORITHM}] \leavevmode\phantomsection\label{index:term-24}
Should the energy denominators be approximated with Laplace
transformations or a Cholesky decomposition? We have found
Laplace transformations to be slightly more efficient.
\begin{itemize}
\item {} 
\textbf{Type}: string

\item {} 
\textbf{Possible Values}: LAPLACE, CHOLESKY

\item {} 
\textbf{Default}: LAPLACE

\end{itemize}

\end{description}
\begin{description}
\item[{\index{DENOMINATOR\_DELTA|textbf}DENOMINATOR\_DELTA}] \leavevmode\phantomsection\label{index:term-25}
The SAPT module uses approximate energy denominators for most of the
$E_{disp}^{(20)}$ and $E_{exch-disp}^{(20)}$ evaluation.
This option controls the maximum allowable error norm in the energy
denominator tensor.
\begin{itemize}
\item {} 
\textbf{Type}: double

\item {} 
\textbf{Default}: $1.0 \times 10^{-6}$

\end{itemize}

\end{description}
\begin{description}
\item[{\index{DF\_BASIS\_ELST|textbf}DF\_BASIS\_ELST}] \leavevmode\phantomsection\label{index:term-26}
Optionally, a different fitting basis can be used for the
$E_{elst}^{(10)}$ and $E_{exch}^{(10)}$ terms.
This may be important if heavier elements are involved.
\begin{itemize}
\item {} 
\textbf{Type}: string

\item {} 
\textbf{Default}: none

\end{itemize}

\end{description}
\begin{description}
\item[{\index{DF\_BASIS\_SAPT|textbf}DF\_BASIS\_SAPT}] \leavevmode\phantomsection\label{index:term-27}
The fitting basis to use for all two-electron integrals
in the SAPT computation. PSI4 will attempt to pick
a reasonable fitting basis if one is not provided.
\begin{itemize}
\item {} 
\textbf{Type}: string

\item {} 
\textbf{Default}: none

\end{itemize}

\end{description}
\begin{description}
\item[{\index{E\_CONVERGENCE|textbf}E\_CONVERGENCE}] \leavevmode\phantomsection\label{index:term-28}
Convergence of the energy change in the $E_{ind,resp}^{(20)}$
term during the solution of the CPHF equations (in hartrees).
\begin{itemize}
\item {} 
\textbf{Type}: {\hyperref[index:conv-double]{conv double}}

\item {} 
\textbf{Default}: $1.0 \times 10^{-10}$

\end{itemize}

\end{description}
\begin{description}
\item[{\index{FREEZE\_CORE|textbf}FREEZE\_CORE}] \leavevmode\phantomsection\label{index:term-29}
Sets the number of core orbitals to freeze in the evaluation
of the $E_{disp}^{(20)}$ and $E_{exch-disp}^{(20)}$
terms. It is recommended to freeze core in all SAPT computations.
\begin{itemize}
\item {} 
\textbf{Type}: string

\item {} 
\textbf{Possible Values}: TRUE, FALSE, SMALL, LARGE

\item {} 
\textbf{Default}: FALSE

\end{itemize}

\end{description}
\begin{description}
\item[{\index{INTS\_TOLERANCE|textbf}INTS\_TOLERANCE}] \leavevmode\phantomsection\label{index:term-30}
All three-index DF integrals and those contributing to four-index
integrals that fall below this Schwarz bound will be neglected.
The default is very conservative, however, there isn't much to
gain from loosening it.
\begin{itemize}
\item {} 
\textbf{Type}: {\hyperref[index:conv-double]{conv double}}

\item {} 
\textbf{Default}: $1.0 \times 10^{-12}$

\end{itemize}

\end{description}
\begin{description}
\item[{\index{MAXITER|textbf}MAXITER}] \leavevmode\phantomsection\label{index:term-31}
The maximum number of CPHF iterations.
\begin{itemize}
\item {} 
\textbf{Type}: integer

\item {} 
\textbf{Default}: 50

\end{itemize}

\end{description}
\begin{description}
\item[{\index{XXX|textbf}XXX}] \leavevmode\phantomsection\label{index:term-32}
xxxxx
\begin{itemize}
\item {} 
\textbf{Type}:

\item {} 
\textbf{Possible Values}:

\item {} 
\textbf{Default}:

\end{itemize}

\end{description}
\begin{description}
\item[{\index{XXX|textbf}XXX}] \leavevmode\phantomsection\label{index:term-33}
xxxxx
\begin{itemize}
\item {} 
\textbf{Type}:

\item {} 
\textbf{Possible Values}:

\item {} 
\textbf{Default}:

\end{itemize}

\end{description}
\begin{description}
\item[{\index{NO\_RESPONSE|textbf}NO\_RESPONSE}] \leavevmode\phantomsection\label{index:term-34}
Don't solve the CPHF equations, evaluate $E_{ind}^{(20)}$
and $E_{exch-ind}^{(20)}$ instead of their response-including
counterparts. Only turn on this option if you are not going to
use the induction energy.
\begin{itemize}
\item {} 
\textbf{Type}: {\hyperref[index:boolean]{boolean}}

\item {} 
\textbf{Default}: FALSE

\end{itemize}

\end{description}
\begin{description}
\item[{\index{XXX|textbf}XXX}] \leavevmode\phantomsection\label{index:term-35}
xxxxx
\begin{itemize}
\item {} 
\textbf{Type}:

\item {} 
\textbf{Possible Values}:

\item {} 
\textbf{Default}:

\end{itemize}

\end{description}
\begin{description}
\item[{\index{PRINT|textbf}PRINT}] \leavevmode\phantomsection\label{index:term-36}
The print level for the SAPT module. If set to 0, only the header
and final results are printed. If set to 1, some intermediate
quantities are also printed. For large SAPT computations, it is
advisable to set to 1 so the progress of the computation can be
tracked.
\begin{itemize}
\item {} 
\textbf{Type}: integer

\item {} 
\textbf{Default}: 1

\end{itemize}

\end{description}
\begin{description}
\item[{\index{SAPT\_LEVEL|textbf}SAPT\_LEVEL}] \leavevmode\phantomsection\label{index:term-37}
The level of theory for SAPT.
\begin{itemize}
\item {} 
\textbf{Type}: string

\item {} 
\textbf{Possible Values}: SAPT0, SAPT2, SAPT2+, SAPT2+3

\item {} 
\textbf{Default}: SAPT0

\end{itemize}

\end{description}
\begin{description}
\item[{\index{XXX|textbf}XXX}] \leavevmode\phantomsection\label{index:term-38}
xxxxx
\begin{itemize}
\item {} 
\textbf{Type}:

\item {} 
\textbf{Possible Values}:

\item {} 
\textbf{Default}:

\end{itemize}

\end{description}
\begin{description}
\item[{\index{SAPT\_OS\_SCALE|textbf}SAPT\_OS\_SCALE}] \leavevmode\phantomsection\label{index:term-39}
The SAPT module will print a decomposition of the $E_{disp}^{(20)}$
and $E_{exch-disp}^{(20)}$ terms into same-spin and opposite-spin
contributions, in analogy to the SCS-MP2 method of Stefan Grimme. This
option controls the scaling of the opposite-spin contributions.
\begin{itemize}
\item {} 
\textbf{Type}: double

\item {} 
\textbf{Default}: 6/5

\end{itemize}

\end{description}
\begin{description}
\item[{\index{SAPT\_SS\_SCALE|textbf}SAPT\_SS\_SCALE}] \leavevmode\phantomsection\label{index:term-40}
This option controls the scaling of the same-spin contributions.
\begin{itemize}
\item {} 
\textbf{Type}: double

\item {} 
\textbf{Default}: 1.0/3.0

\end{itemize}

\end{description}


\section{DUMMY}
\label{index:dummy}\begin{description}
\item[{\index{DEBUG|textbf}DEBUG}] \leavevmode\phantomsection\label{index:term-41}
Print lots of intermediate quantities that are not usually interesting.
For SAPT, it will also do additional work (which is not optimized for
large systems) so don't turn it on.
\begin{itemize}
\item {} 
\textbf{Type}: integer

\item {} 
\textbf{Default}: 0

\end{itemize}

\end{description}
\begin{description}
\item[{\index{XXX|textbf}XXX}] \leavevmode\phantomsection\label{index:term-42}
xxxxx
\begin{itemize}
\item {} 
\textbf{Type}:

\item {} 
\textbf{Possible Values}:

\item {} 
\textbf{Default}:

\end{itemize}

\end{description}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{a}
\item {\texttt{ACENES}}, \pageref{db:module-ACENES}
\item {\texttt{aliases}}, \pageref{index:module-aliases}
\indexspace
\bigletter{b}
\item {\texttt{BAKERJCC93}}, \pageref{db:module-BAKERJCC93}
\item {\texttt{BASIC}}, \pageref{db:module-BASIC}
\item {\texttt{BBI}}, \pageref{db:module-BBI}
\indexspace
\bigletter{c}
\item {\texttt{CFLOW}}, \pageref{db:module-CFLOW}
\item {\texttt{CORE}}, \pageref{db:module-CORE}
\indexspace
\bigletter{d}
\item {\texttt{driver}}, \pageref{index:module-driver}
\indexspace
\bigletter{f}
\item {\texttt{frac}}, \pageref{index:module-frac}
\indexspace
\bigletter{g}
\item {\texttt{G2}}, \pageref{db:module-G2}
\indexspace
\bigletter{h}
\item {\texttt{HBC6}}, \pageref{db:module-HBC6}
\item {\texttt{HSG}}, \pageref{db:module-HSG}
\item {\texttt{HTBH}}, \pageref{db:module-HTBH}
\indexspace
\bigletter{i}
\item {\texttt{input}}, \pageref{index:module-input}
\indexspace
\bigletter{j}
\item {\texttt{JSCH}}, \pageref{db:module-JSCH}
\indexspace
\bigletter{m}
\item {\texttt{molutil}}, \pageref{index:module-molutil}
\indexspace
\bigletter{n}
\item {\texttt{NBC10}}, \pageref{db:module-NBC10}
\item {\texttt{NHTBH}}, \pageref{db:module-NHTBH}
\indexspace
\bigletter{p}
\item {\texttt{physconst}}, \pageref{index:module-physconst}
\item {\texttt{proc}}, \pageref{index:module-proc}
\item {\texttt{procutil}}, \pageref{index:module-procutil}
\item {\texttt{psiexceptions}}, \pageref{index:module-psiexceptions}
\item {\texttt{pubchem}}, \pageref{index:module-pubchem}
\indexspace
\bigletter{q}
\item {\texttt{qmmm}}, \pageref{index:module-qmmm}
\indexspace
\bigletter{r}
\item {\texttt{RGC10}}, \pageref{db:module-RGC10}
\indexspace
\bigletter{s}
\item {\texttt{S22}}, \pageref{db:module-S22}
\item {\texttt{S22by5}}, \pageref{db:module-S22by5}
\item {\texttt{S66}}, \pageref{db:module-S66}
\item {\texttt{SSI}}, \pageref{db:module-SSI}
\indexspace
\bigletter{t}
\item {\texttt{text}}, \pageref{index:module-text}
\indexspace
\bigletter{u}
\item {\texttt{util}}, \pageref{index:module-util}
\indexspace
\bigletter{w}
\item {\texttt{wrappers}}, \pageref{index:module-wrappers}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
