# /usr/bin/env python
# vim:ft=python

# reap-sow helper script
# executed after the sow step
# AJ
import os
import re
import sys
import subprocess
import time

root_directory = os.path.dirname(os.path.realpath(__file__))


def sowList(first_out):
    """read the output from the 'sow' step to the list of files
    to run before the 'reap' step """
    find_cmd = re.compile("^#\s+ psi4\s+-i(?P<infile> (?P<tag>[a-zA-Z]+)-(?P<index>[0-9]+)\.in)")
    the_list = []
    master = ""
    with open(first_out,'r') as sow_out:
        for line in sow_out:
            #print line
            matchobj=find_cmd.match(line)
            if (matchobj):
                the_list.append(matchobj.group('infile'))
                master = "{0}-master.in".format(matchobj.group('tag'))


    return the_list,master


def storeTests(testDir):
    """Store the tests in array"""
    testFile = os.path.join(testDir,"tests")
    retTests = []
    with open(testFile) as F:
        for line in F:
            retTests.append(line.strip())

    return retTests

def addTests(theMaster,theTests):
    """ Append the tests to the master file, it must be created first"""
    with open(theMaster,'a') as F:
        for test in theTests:
            F.write("{}\n".format(test))
    pass



def runFiles(psi4,theFileList,testDir):
    """ run the input files generated by the first input """
    for infile in theFileList:
        thisFile=os.path.join(testDir,infile)
        cmd = [psi4,"-i",thisFile]
        subprocess.call(cmd)

def runMaster(psi4, theMasterFile,logfile):
    """ run the master file and record the output in the logfile,
    the same way that runtest.py does it."""
    cmd = [psi4,"-i",theMasterFile]
    try:
        loghandle = open(logfile, 'a')
    except IOError as e:
        print ("""I can't write to %s: %s""" %(logfile, e))
        sys.exit(1)
    try:
        retcode = subprocess.Popen(cmd, bufsize=0, stdout=subprocess.PIPE, universal_newlines=True)
    except OSError as e:
        sys.stderr.write('Command %s execution failed: %s\n' % cmd, e.strerror)
        sys.exit(1)
    p4out = ''
    while True:
        data = retcode.stdout.readline()
        if not data:
            break
        sys.stdout.write(data) # screen
        loghandle.write(data) # file
        loghandle.flush()
        p4out += data # string
    loghandle.close()
    while True:
        retcode.poll()
        exstat = retcode.returncode
        if exstat is not None:
            return exstat
        time.sleep(0.1)


def main(first_input,first_output,logfile, psi4):
    # check the psi4 path is there and is executable
    testing_dir = os.path.dirname(first_input)
    output_dir = os.path.dirname(first_output)
    if os.path.isfile(psi4) and os.access(psi4,os.X_OK):
        # get the list of intermediate input files
        # files list and master file are not abolute paths just names
        files_list,master_file= sowList(first_output)
        # get the commands from tests
        tests=storeTests(testing_dir)
        # set the "reapmode" master file full path
        reap_master=os.path.join(output_dir,master_file)
        # append the tests
        addTests(reap_master,tests)
        # run intermediates
        runFiles(psi4,files_list)
        # run the master
        runMaster(psi4,reap_master,logfile)
        # sucess
        sys.exit(0)
    else:
        print("""check psi4 path  %s is not executable, or was not found""" % (psi4))
        sys.exit(1)



if __name__=='__main__':
    main(sys.argv[1:])







