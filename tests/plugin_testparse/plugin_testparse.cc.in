#include "psi4-dec.h"
#include <liboptions/liboptions.h>
#include <libplugin/plugin.h>

INIT_PLUGIN

using namespace boost;

namespace psi{ namespace plugin_testparse{

extern "C" int
read_options(std::string name, Options &options){

    fprintf(outfile, "read_options() is being called with name %s\n", 
      name.c_str());

    if(name == "PLUGIN_TESTPARSE" || options.read_globals() ) {
        fprintf(outfile, "I'm inside the code block\n");
        options.add_int("OPT1", 1);
        options.add_int("OPT2", 1);
        options.add_int("OPT3", 1);
        options.add_str("REFERENCE", "");
        options.add_bool("TESTBOOL", true);
        options.add("INTARR", new ArrayType());
        options.add("DBLARR", new ArrayType());
        options.add("FOLLOW_VECTOR", new ArrayType());
    }

    return 1;
}


extern "C" PsiReturnType
plugin_testparse(Options &options)
{
    int opt1 = options.get_int("OPT1");
    int opt2 = options.get_int("OPT2");
    int opt3 = options.get_int("OPT3");
    // This will print out all of the user-provided options for this module
    options.print();
    fprintf(outfile, "opt1 (integer) = %d\n", opt1);
    fprintf(outfile, "opt2 (integer) = %d\n", opt2);
    fprintf(outfile, "opt3 (integer) = %d\n", opt3);
    
    // Test of trying to parse a boolean as an integer (backward
    // compatibility for some of the old PSI3 modules) 
    // int testbool = (int) options.get_bool("TESTBOOL");
    int testbool = options["TESTBOOL"].to_integer();
    fprintf(outfile, "testbool (integer) = %d\n", testbool);

    fprintf(outfile, "dblarr = [ ");
    for (int i=0; i<options["DBLARR"].size(); i++) {
      fprintf(outfile, "%5.2lf, ", options["DBLARR"][i].to_double());
    }
    fprintf(outfile, "]\n");
    
    int *intarr;
    int size = options["INTARR"].size();
    intarr = (int *) malloc(size*sizeof(int));
    options.fill_int_array("INTARR", intarr);
    fprintf(outfile, "intarr = [ ");
    for (int i=0; i<size; i++) {
      fprintf(outfile, "%d, ", intarr[i]);
    }
    fprintf(outfile, "]\n");
    free(intarr);

    fprintf(outfile, "FOLLOW_VECTOR = \n");
    size = options["FOLLOW_VECTOR"].size();
    for (int i=0; i<size; i++) {
      int isize = options["FOLLOW_VECTOR"][i].size();
      if (isize != 2) {
        fprintf(outfile, "Error: element %d has size %d, should be 2\n",
          i, isize);
        continue;
      }
      int iisize = options["FOLLOW_VECTOR"][i][0].size();
      if (iisize != 2) {
        fprintf(outfile, "Error: element %d has size %d, should be 2\n",
          i, isize);
        continue;
      }
      fprintf(outfile, "[%d, %d], %.2lf\n", 
        options["FOLLOW_VECTOR"][i][0][0].to_integer(),
        options["FOLLOW_VECTOR"][i][0][1].to_integer(),
        options["FOLLOW_VECTOR"][i][1].to_double());
    } /* end loop over FOLLOW_VECTOR */

    return Success;   
}

}} // End Namespaces
