#include <libmints/mints.h>
#include <libqt/qt.h>
#include <psi4-dec.h>

#include "fqdft.h"

using namespace psi;

namespace psi {

FQDFT::FQDFT() :
    Wavefunction(Process::environment.options,_default_psio_lib_) 
{
    common_init();
}
FQDFT::~FQDFT()
{
}
void FQDFT::common_init()
{
    reference_wavefunction_ = Process::environment.reference_wavefunction();
    
    if (!reference_wavefunction_) {
        throw PSIEXCEPTION("RBase: Run SCF first");
    }

    if (!reference_wavefunction_->same_a_b_dens()) {
        throw PSIEXCEPTION("RBase: Reference is not restricted");
    }
    
    copy(reference_wavefunction_);
}
void FQDFT::print_header() const 
{
    fprintf(outfile, "\n");
    fprintf(outfile, "         ------------------------------------------------------------\n");
    fprintf(outfile, "                                     FQDFT                          \n"); 
    fprintf(outfile, "                                  Rob Parrish                       \n"); 
    fprintf(outfile, "         ------------------------------------------------------------\n\n");
    
}
void FQDFT::integrals()
{
    SharedMatrix C = Ca_subset("AO","ALL");
    boost::shared_ptr<MintsHelper> mints(new MintsHelper());

    int nso = C->rowspi()[0];
    int nmo = C->colspi()[0];

    // One-electron bits
    SharedMatrix T_AO = mints->ao_kinetic();
    SharedMatrix V_AO = mints->ao_potential();

    T_ = SharedVector(new Vector("T (MO)", nmo));
    V_ = SharedVector(new Vector("V (MO)", nmo));
    H_ = SharedVector(new Vector("H (MO)", nmo));
    E_ = SharedVector(new Vector("E (MO)", nmo));

    double* temp = new double[nso*(ULI)nmo];
    C_DGEMM('T','N',nmo,nso,nso,1.0,C->pointer()[0],nmo,T_AO->pointer()[0],nso,0.0,temp,nso);
    for (int i = 0; i < nmo; i++) {
        T_->set(i, C_DDOT(nso,&C->pointer()[0][i],nmo,&temp[i*(ULI)nso],1));
    }
    C_DGEMM('T','N',nmo,nso,nso,1.0,C->pointer()[0],nmo,V_AO->pointer()[0],nso,0.0,temp,nso);
    for (int i = 0; i < nmo; i++) {
        V_->set(i, C_DDOT(nso,&C->pointer()[0][i],nmo,&temp[i*(ULI)nso],1));
    }
    for (int i = 0; i < nmo; i++) {
        H_->set(i,V_->get(i) + T_->get(i));
    }
    T_AO.reset();
    V_AO.reset();
    delete[] temp;
    
    // Two-electron bits
    J_ = SharedMatrix(new Matrix("J (MO)", nmo, nmo));
    K_ = SharedMatrix(new Matrix("K (MO)", nmo, nmo));
    G_ = SharedMatrix(new Matrix("G (MO)", nmo, nmo));

    SharedMatrix I_AO = mints->ao_eri();
    SharedMatrix K_AO(I_AO->clone());

    double** Ip = I_AO->pointer();
    double** Kp = K_AO->pointer();
    for (int i = 0; i < nso; i++) {
        for (int j = 0; j < nso; j++) {
            for (int k = 0; k < nso; k++) {
                for (int l = 0; l < nso; l++) {
                    Kp[i * (ULI) nso + k][j * (ULI) nso + l] = 
                    Ip[i * (ULI) nso + j][k * (ULI) nso + l];
                }
            }   
        }   
    }

    SharedMatrix Di(new Matrix("Di", nso, nso));
    SharedMatrix Dj(new Matrix("Dj", nso, nso));
    double* temp2 = new double[nso * (ULI) nso];
    double* temp3 = new double[nso * (ULI) nso];
    for (int i = 0; i < nmo; i++) {
        Di->zero();
        C_DGER(nso,nso,1.0,&C->pointer()[0][i],nmo,&C->pointer()[0][i],nmo,Di->pointer()[0],nso);
        C_DGEMV('N',nso*(ULI)nso,nso*(ULI)nso,1.0,I_AO->pointer()[0],nso*(ULI)nso,Di->pointer()[0],1,0.0,temp2,1);
        C_DGEMV('N',nso*(ULI)nso,nso*(ULI)nso,1.0,K_AO->pointer()[0],nso*(ULI)nso,Di->pointer()[0],1,0.0,temp3,1);

        for (int j = 0; j < nmo; j++) {
            Dj->zero();
            C_DGER(nso,nso,1.0,&C->pointer()[0][j],nmo,&C->pointer()[0][j],nmo,Dj->pointer()[0],nso);
            J_->set(i,j,C_DDOT(nso*(ULI)nso,temp2,1,Dj->pointer()[0],1));
            K_->set(i,j,C_DDOT(nso*(ULI)nso,temp3,1,Dj->pointer()[0],1));
        }
    }
    I_AO.reset();
    K_AO.reset();
    Di.reset();
    Dj.reset();
    delete[] temp2;
    delete[] temp3;

    G_->copy(J_);
    G_->scale(2.0);
    G_->subtract(K_);

    int nocc = nalpha_;
    for (int i = 0; i < nmo; i++) {
        double eval = H_->get(i);
        for (int j = 0; j < nocc; j++) {
            eval += G_->get(i,j);
        }
        E_->set(i,eval);
    }

    if (debug_) {
        T_->print();
        V_->print();
        H_->print();
        J_->print();
        K_->print();
        G_->print();
        E_->print();
    }
}
double FQDFT::compute_energy()
{
    print_header();

    integrals();

    int N = 100;
    for (int i = 0; i < N + 1; i++) {
        double f1 = i / (double) N;
        double f2 = 1.0 - f1; 
        f1 *= 2.0;
        f2 *= 2.0;
        double E = f1 * H_->get(0) + f2 * H_->get(1) + 0.5 * (f1 * f1 * G_->get(0,0) + f1 * f2 * G_->get(1,0) + f2 * f1 * G_->get(1,0) +  f2 * f2 * G_->get(1,1));
        fprintf(outfile, "\t%14.6E %24.16E\n", f1, E);

    } 

    return 0.0;
}

}
