#include <rqchf.h>
#include <libmints/view.h>
#include <libmints/mints.h>
#include <libfock/apps.h>
#include <libfock/jk.h>
#include <liboptions/liboptions.h>
#include <libciomr/libciomr.h>
#include <libqt/qt.h>

using namespace psi;

namespace psi{ namespace scf{

RQCHF::RQCHF(Options& options) 
    : RHF(options, _default_psio_lib_)
{
    chkpt_.reset();
    RHF::common_init();
    boost::shared_ptr<Wavefunction> wfn = Process::environment.reference_wavefunction();
    if(options.get_str("GUESS") == "READ")
        if(wfn) copy(wfn);
    density_threshold_ = options.get_double("D_CONVERGENCE");
    energy_threshold_ = options.get_double("E_CONVERGENCE");

}


RQCHF::~RQCHF()
{
}

/**
 * Given the unique (occ X vir) elements of the orbital rotation matrix, R,
 * performs a unitary rotation of the orbitals, rigorously maintaining orthogonality.
 *
 * @param X The occ X vir unique orbital rotation parameters
 */
void RQCHF::rotate_orbitals(SharedMatrix X)
{
#if 1
    // Transform using
    // U = 1 + R + 0.5 RR
    // then Schmidt orthogonalize U
    SharedMatrix R(new Matrix("R", nmopi_, nmopi_));
    for (int h = 0; h < nirrep_; ++h) {
        int ndocc = doccpi_[h];
        int nvirt = nmopi_[h] - doccpi_[h];
        if (!ndocc || !nvirt) continue;
        double** pR = R->pointer(h);
        double** pX = X->pointer(h);
        for (int i = 0; i < ndocc; ++i) {
            for(int a = 0; a < nvirt; ++a){
                pR[i][a + doccpi_[h]] = -pX[i][a];
                pR[a + doccpi_[h]][i] = pX[i][a];
            }
        }
    }
    SharedMatrix RR(new Matrix("RR", nmopi_, nmopi_));
    RR->gemm(false, false, 0.5, R, R, 0.0);
    R->add(RR);
    for(int h = 0; h < nirrep_; ++h){
        int dim = nmopi_[h];
        // Add the identity part in there
        for(int n = 0; n < nmopi_[h]; ++n) R->add(h, n, n, 1.0);
        schmidt(R->pointer(h), dim, dim, outfile);
    }
    // Rotate the orbitals
    SharedMatrix Cnew(new Matrix("C new", nsopi_, nmopi_));
    Cnew->gemm(false, false, 1.0, Ca_, R, 0.0);
    Ca_->copy(Cnew);
#else
    // Transform using
    // U = 1 + R
    // then iteratively orthonormalize the resulting C.  This looks like a bad method, so far.
    SharedMatrix R(new Matrix("R", nmopi_, nmopi_));
    R->identity();
    for (int h = 0; h < nirrep_; ++h) {
        int ndocc = doccpi_[h];
        int nvirt = nmopi_[h] - doccpi_[h];
        if (!ndocc || !nvirt) continue;
        double** pR = R->pointer(h);
        double** pX = X->pointer(h);
        for (int i = 0; i < ndocc; ++i) {
            for(int a = 0; a < nvirt; ++a){
                pR[i][a + doccpi_[h]] = -pX[i][a];
                pR[a + doccpi_[h]][i] = pX[a][i];
            }
        }
    }
    /*
     * Rotate the orbitals: Cnew = Ca (I + R)
     */
    SharedMatrix Cnew(new Matrix("C new", nsopi_, nmopi_));
    Cnew->gemm(false, false, 1.0, Ca_, R, 0.0);
    Ca_->copy(Cnew);

    /*
     * Purify the transformation, to restore orthogonality
     */
    double error = 0.0;
    do{
        // Ca(new) = 3/2 Ca(old)
        Cnew->copy(Ca_);
        Cnew->scale(1.5);
        // Ca(new) -= 0.5 C Ct S C
        // Recycle the R matrix from above to store the MO overlap
        R->transform(S_, Ca_);
        Cnew->gemm(false, false, -0.5, Ca_, R, 1.0);
        SharedMatrix delta(Cnew->clone());
        delta->set_name("Delta C");
        delta->subtract(Ca_);
        error = delta->rms();
        Ca_->copy(Cnew);
        fprintf(outfile, "\t\tOrthogonalization error is %16.10f (%16.10f)\n",
                error, density_threshold_);
    } while(error > density_threshold_);
#endif
}

double RQCHF::compute_energy()
{
    std::string reference = options_.get_str("REFERENCE");

    /*
     * Cheesy guess at an orthogonal set of MOs
     */
    form_H();
    form_Shalf();
    integrals();
    if(options_.get_str("GUESS") != "READ")
        guess();

    /*
     * Set up the CG solver
     */
    boost::shared_ptr<RCPHF> cphf(new RCPHF());
    cphf->preiterations();
    cphf->set_print(0);
    cphf->jk()->set_print(0);
    std::map<std::string, SharedMatrix>& tasks  = cphf->b();
    std::map<std::string, SharedMatrix>& results = cphf->x();

    iteration_ = 0;
    bool converged = false;
    if (Communicator::world->me() == 0) {
        fprintf(outfile, "  ==> Iterations <==\n\n");
        fprintf(outfile, "                        Total Energy        Delta E     Density RMS\n\n");
    }
    fflush(outfile);

    double absDE = 1.0;
    do{
        /*
         * Build the Fock matrix and assign the diagonal elements to epsilon
         */
        form_D();
        form_G();
        form_F();

        /*
         * Compute the gradient (Fia)
         */
        Dimension zerodim = Dimension(nirrep_);
        Dimension virtpi = nmopi_ - doccpi_;
#if 1
        // Obtain the eigenvalues exactly, and transform only the OV block
        // of the Fock matrix to compute the MO basis orbital gradient
        View oview(Ca_, nsopi_, doccpi_);
        View vview(Ca_, nsopi_, virtpi, zerodim, doccpi_);
        SharedMatrix Co = oview();
        Co->set_name("Occupied MO Coefficients");
        SharedMatrix Cv = vview();
        Cv->set_name("Virtual MO Coefficients");
        SharedMatrix temp(new Matrix("Temp doccXnso", doccpi_, nsopi_));
        temp->gemm(true, false, 1.0, Co, Fa_, 0.0);
        SharedMatrix grad(new Matrix("Orbital Gradient", doccpi_, virtpi));
        grad->gemm(false, false, 1.0, temp, Cv, 0.0);
        diag_F_temp_->transform(Fa_, X_);
        // Diagonalize, but get only the eigenvalues
        diag_F_temp_->diagonalize(temp, epsilon_a_, Matrix::EvalsOnlyAscending);
#else
        // Obtain the eigenvalues as the diagonals of the fock matrix
        SharedMatrix moF(new Matrix("F (MO)", nmopi_, nmopi_));
        moF->transform(Fa_, Ca_);
        for(int h = 0; h < nirrep_; ++h)
            for(int p = 0; p < nmopi_[h]; ++p)
                epsilon_a_->set(h, p, moF->get(h, p, p));
        View gradview(moF, doccpi_, virtpi, zerodim, doccpi_);
        SharedMatrix grad = gradview();
#endif

        /*
         * Compute/contract the hessian
         */
        grad->scale(-1.0);
        // Task and solve linear Equations
        tasks["Orbital Gradient"] = grad;
        cphf->set_convergence(sqrt(absDE) / 1000);
        cphf->set_reference(Process::environment.reference_wavefunction());
        cphf->compute_energy();
        SharedMatrix X = results["Orbital Gradient"];

        rotate_orbitals(X);
        Drms_ = grad->rms();
        Eold_ = E_;
        E_ = compute_E();

        std::string status;
        if (Communicator::world->me() == 0) {
            fprintf(outfile, "   @%s iter %3d: %20.14f   %12.5e   %-11.5e %s\n",
                              reference.c_str(), iteration_, E_, E_ - Eold_, Drms_, status.c_str());
            fflush(outfile);
        }
        converged = Drms_ < density_threshold_ && fabs(E_ - Eold_) < energy_threshold_;
        ++iteration_;
    }while (!converged && iteration_ < maxiter_ );

    // We're not guaranteed canonical orbitals, because o-o and v-v rotations are not considered.
    // This can be done by calling semicanonicalize() to diagonalize only subblocks, but for now
    // I'll just diagonalize the full matrix.
    Fa_->diagonalize(Ca_, epsilon_a_, Matrix::Ascending);

    return E_;
}

}} // Namespaces
