#include <libplugin/plugin.h>
#include <psi4-dec.h>
#include <libparallel/parallel.h>
#include <liboptions/liboptions.h>
#include <libpsio/psio.hpp>
#include <libchkpt/chkpt.hpp>
#include <libdpd/dpd.h>
#include <libtrans/integraltransform.h>
#include <libmints/wavefunction.h>
#include "ccfiles.h"
#include "psifiles.h"
// This allows us to be lazy in getting the spaces in DPD calls
#define ID(x) ints.DPD_ID(x)

INIT_PLUGIN

namespace psi{ namespace plugin_ccsort {

extern "C"
int read_options(std::string name, Options &options)
{
    if (name == "PLUGIN_CCSORT"|| options.read_globals()) {
        /*- The amount of information printed
            to the output file -*/
        options.add_int("PRINT", 1);
        /*- How to handle the <AB|CD> term in coupled cluster -*/
        options.add_str("AO_BASIS", "NONE", "NONE DISK DIRECT");
        /*- Should we semicanonicalize ROHF references" -*/
        options.add_bool("SEMICANONICAL", 0);
    }

    return true;
}


extern "C" 
PsiReturnType plugin_ccsort(Options &options)
{
    boost::shared_ptr<PSIO> psio(_default_psio_lib_);
    // Grab the global wavefunction; this should be SCF.
    boost::shared_ptr<Wavefunction> wfn = Process::environment.reference_wavefunction();
    if(!wfn) throw PSIEXCEPTION("SCF has not been run yet!");

    // Should we do the <AB|CD> integrals?
    bool do_abcd = options.get_str("AO_BASIS") == "NONE";
    std::vector<boost::shared_ptr<MOSpace> > spaces;
    spaces.push_back(MOSpace::occ);
    spaces.push_back(MOSpace::vir);
    // Is our reference function restricted?
    bool restricted;
    bool semicanonical = options.get_bool("SEMICANONICAL");
    // Figure out what type of transformation is needed
    IntegralTransform::TransformationType trans_type;
    if(wfn->same_a_b_orbs()){
        restricted = true;
        trans_type = IntegralTransform::Restricted;
        if(wfn->same_a_b_dens()){
             // Restricted (RHF)
        }else{
             // Restricted (ROHF)
             if(semicanonical){
                 wfn->semicanonicalize();
                 restricted = false;
                 trans_type = IntegralTransform::Unrestricted;
             }
        }
    }else{
        restricted = false;
        trans_type = IntegralTransform::Unrestricted;
        if(wfn->same_a_b_dens()){
            // Eh?
            throw PSIEXCEPTION("I have no idea what's going on here.");
        }else{
            // Unrestricted (UHF)
        }
    }

    IntegralTransform ints(wfn, spaces, trans_type);
    // Make sure libtrans preserves the presorted integrals, so successive transforms can use them
    ints.set_keep_dpd_so_ints(1);

    /*
     * Perform the actual transformations
     */
    ints.set_dpd_int_file(CC_AINTS);
    ints.set_aa_int_name("A <IJ|KL> (IK,JL)");
    ints.set_ab_int_name("A <Ij|Kl> (IK,jl)");
    ints.set_bb_int_name("A <ij|kl> (ik,jl)");
    ints.transform_tei(MOSpace::occ, MOSpace::occ, MOSpace::occ, MOSpace::occ, IntegralTransform::MakeAndKeep);
    
    ints.set_dpd_int_file(CC_CINTS);
    ints.set_aa_int_name("C <IA|JB> (IJ,AB)");
    ints.set_ab_int_name("C <Ia|Jb> (IJ,ab)");
    ints.set_bb_int_name("C <ia|jb> (ij,ab)");
    ints.transform_tei(MOSpace::occ, MOSpace::occ, MOSpace::vir, MOSpace::vir, IntegralTransform::ReadAndNuke);

    if(do_abcd){
        ints.set_dpd_int_file(CC_BINTS);
        ints.set_aa_int_name("B <AB|CD> (AC,BD)");
        ints.set_ab_int_name("B <Ab|Cd> (AC,bd)");
        ints.set_bb_int_name("B <ab|cd> (ac,bd)");
        ints.transform_tei(MOSpace::vir, MOSpace::vir, MOSpace::vir, MOSpace::vir);
    }


    ints.set_dpd_int_file(CC_DINTS);
    ints.set_aa_int_name("D <IJ|AB> (IA,jb)");
    ints.set_ab_int_name("D <Ij|Ab> (IA,jb)");
    ints.set_bb_int_name("D <ij|ab> (ia,jb)");
    ints.transform_tei(MOSpace::occ, MOSpace::vir, MOSpace::occ, MOSpace::vir);

    ints.set_dpd_int_file(CC_EINTS);
    ints.transform_tei(MOSpace::occ, MOSpace::occ, MOSpace::occ, MOSpace::vir);
    ints.set_aa_int_name("E <IJ|KA> (IK,JA)");
    ints.set_ab_int_name("E <Ij|Ka> (IK,ja)");
    ints.set_bb_int_name("E <ij|ka> (ik,ja)");
    if(!restricted){
        ints.transform_tei(MOSpace::occ, MOSpace::vir, MOSpace::occ, MOSpace::occ);
        ints.set_ab_int_name("E <Ji|Ak> (JA,ik)");
    }

    // Set this before the final transform, so that the half-transformed integrals are deleted
    //ints.set_keep_dpd_so_ints(0);

    ints.set_dpd_int_file(CC_FINTS);
    ints.transform_tei(MOSpace::occ, MOSpace::occ, MOSpace::occ, MOSpace::vir);
    ints.set_aa_int_name("F <IA|CB> (IC|AB)");
    ints.set_ab_int_name("F <Ia|Cb> (IC|ab)");
    ints.set_bb_int_name("F <ia|cb> (ic|ab)");
    if(!restricted){
        ints.transform_tei(MOSpace::vir, MOSpace::vir, MOSpace::occ, MOSpace::vir);
        ints.set_ab_int_name("E <Ai|Bc> (AB,ic)");
    }

    // The final flag here tells libtrans to skip the first half transform, using the previous intermdiates

    /*
     * Now that we're done with the transformations, sort the results to the desired order
     */


    dpdbuf4 I;

    // Use the IntegralTransform object's DPD instance, for convenience
    dpd_set_default(ints.get_dpd_id());

    // Open the files
    psio->open(PSIF_LIBTRANS_DPD, PSIO_OPEN_OLD);
    psio->open(CC_AINTS, PSIO_OPEN_OLD);
    psio->open(CC_BINTS, PSIO_OPEN_OLD);
    psio->open(CC_CINTS, PSIO_OPEN_OLD);
    psio->open(CC_DINTS, PSIO_OPEN_OLD);
    psio->open(CC_EINTS, PSIO_OPEN_OLD);
    psio->open(CC_FINTS, PSIO_OPEN_OLD);
  
    /* For now, we just generate the integrals in PSIF_LIBRTRANS_DPD, then copy them over to the CC files. */

    /*
     *  D Integrals
     */
    // (IB|JA) -> <IJ|AB>
    dpd_buf4_init(&I, CC_DINTS, 0, ID("[O,V]"), ID("[O,V]"),
                  ID("[O,V]"), ID("[O,V]"), 0, "D <IJ|AB> (IA,JB)");
    dpd_buf4_sort(&I, CC_DINTS, prqs, ID("[O,O]"), ID("[V,V]"), "D <IJ|AB>");
    dpd_buf4_close(&I);

    // <IJ|AB> -> <IJ||AB>
    dpd_buf4_init(&I, CC_DINTS, 0, ID("[O,O]"), ID("[V,V]"),
                  ID("[O,O]"), ID("[V,V]"), 1, "D <IJ|AB>");
    dpd_buf4_copy(&I, CC_DINTS, "D <IJ||AB>");
    dpd_buf4_close(&I);

    // <IJ|AB> -> <I>J||AB>
    dpd_buf4_init(&I, CC_DINTS, 0, ID("[O>O]-"), ID("[V,V]"),
                  ID("[O,O]"), ID("[V,V]"), 1, "D <IJ|AB>");
    dpd_buf4_copy(&I, CC_DINTS, "D <IJ||AB> (I>J,AB)");
    dpd_buf4_close(&I);

    // Add some extra spin cases for unrestricted transformations
    if(!restricted){
        /*
         *  D Integrals
         */
        // (IB|ja) -> <Ij|Ab>
        // (IB|ja) -> <iJ|aB>
        dpd_buf4_init(&I, CC_DINTS, 0, ID("[O,V]"), ID("[o,v]"),
                      ID("[O,V]"), ID("[o,v]"), 0, "D <Ij|Ab> (IA,jb)");
        dpd_buf4_sort(&I, CC_DINTS, prqs, ID("[O,o]"), ID("[V,v]"), "D <Ij|Ab>");
        dpd_buf4_sort(&I, CC_DINTS, rpsq, ID("[o,O]"), ID("[v,V]"), "D <iJ|aB>");
        dpd_buf4_close(&I);

        // (ib|ja) -> <ij|ab>
        dpd_buf4_init(&I, CC_DINTS, 0, ID("[o,v]"), ID("[o,v]"),
                      ID("[o,v]"), ID("[o,v]"), 0, "D <ij|ab> (ia,jb)");
        dpd_buf4_sort(&I, CC_DINTS, prqs, ID("[o,o]"), ID("[v,v]"), "D <ij|ab>");
        dpd_buf4_close(&I);

        // <ij|ab> -> <ij||ab>
        dpd_buf4_init(&I, CC_DINTS, 0, ID("[o,o]"), ID("[v,v]"),
                      ID("[o,o]"), ID("[v,v]"), 1, "D <ij|ab>");
        dpd_buf4_copy(&I, CC_DINTS, "D <ij||ab>");
        dpd_buf4_close(&I);

        // <ij|ab> -> <i>j||ab>
        dpd_buf4_init(&I, CC_DINTS, 0, ID("[o>o]-"), ID("[v,v]"),
                      ID("[o,o]"), ID("[v,v]"), 1, "D <ij|ab>");
        dpd_buf4_copy(&I, CC_DINTS, "D <ij||ab> (i>j,ab)");
        dpd_buf4_close(&I);
    }

    psio->close(PSIF_LIBTRANS_DPD, 1);
    psio->close(CC_AINTS, 1);
    psio->close(CC_BINTS, 1);
    psio->close(CC_CINTS, 1);
    psio->close(CC_DINTS, 1);
    psio->close(CC_EINTS, 1);
    psio->close(CC_FINTS, 1);
    return Success;
}

}} // End Namespaces
