/*! \file
    \ingroup LMP2
    \brief localized the SCF MO's
 */
#include "mpi.h"
#include <iostream>
#include <fstream>              // file I/O support
//#include <cstdio>
//#include <cstdlib>
//#include <cstring>
//#include <cmath>
//#include <libipv1/ip_lib.h>
#include <libciomr/libciomr.h>
//#include <libchkpt/chkpt.h>
//#include <libpsio/psio.h>
#include <libqt/qt.h>
//#include <libint/libint.h>
#include <libmints/basisset.h>
//#include <libmints/onebody.h>
#include <libmints/twobody.h>
#include <libmints/integral.h>
#include <libmints/factory.h>
#include <libmints/wavefunction.h>
#include <libparallel/parallel.h>

//#include <psifiles.h>
#define EXTERN
#include "globals.h"

namespace psi {

extern int myid;
extern int nprocs;

namespace lmp2 {

extern int myid_lmp2;
extern int nprocs_lmp2;

void LMP2::direct_transformation() {

    using namespace std;

    int i, j, a, b, ab, t, ij, ji;
    int k, v, mn, mn_pairs;
    int count;
    int *ij_owner, *ij_local, *mn_owner;
    int **MN_shell;
    int M, R, N, S;
    double ***eri_ao, ***eri_2, ***eri_2_mn;
    // MPI_Status stat;

    //  ****  These are required to utilize libmints  ****

    // Required for libmints, allocates and computes the following:
    // ioff, fac, df, bc
    Wavefunction::initialize_singletons();

    // Create a basis set object and initialize it using the checkpoint file.
    shared_ptr<BasisSet> basis(new BasisSet(chkpt));

    // Initialize an integral factory
    shared_ptr<IntegralFactory> integral(new IntegralFactory(basis, basis, basis, basis));

    // Create an integral object for ERIs
    shared_ptr<TwoBodyAOInt> eri(integral->eri());

    // Get the storage buffer from the eri object
    const double *buffer = eri->buffer();

    // **** Integral direct transformation ****

    //  **** Allocate memory for the first quarter integral transformation ****
    //  double *B1 = (double *) calloc(nso*nocc*nso*nocc , sizeof(double));

    ij_owner = get_ij_owner();
    ij_local = get_ij_local();

    if (ij_pairs % nprocs == 0) {
        eri_2 = (double ***) malloc((ij_pairs / nprocs) * sizeof (double **));
        for (ij = 0; ij < ij_pairs; ij++) {
            if (myid == ij_owner[ij])
                eri_2[ij_local[ij]] = block_matrix(nso, nso);
        }
    } else {
        if (myid < ij_pairs % nprocs) {
            eri_2 = (double ***) malloc(((ij_pairs / nprocs) + 1) * sizeof (double **));
            for (ij = 0; ij < ij_pairs; ij++) {
                if (myid == ij_owner[ij])
                    eri_2[ij_local[ij]] = block_matrix(nso, nso);
            }
        } else {
            eri_2 = (double ***) malloc(ij_pairs / nprocs * sizeof (double **));
            for (ij = 0; ij < ij_pairs; ij++) {
                if (myid == ij_owner[ij])
                    eri_2[ij_local[ij]] = block_matrix(nso, nso);
            }
        }
    }

    //num_unique_shells = get_num_unique_shells();

    num_unique_shells = 0;
    for (int M = 0; M < nshell; M++) {
        for (int N = 0; N <= M; N++) {
            num_unique_shells++;
        }
    }

    MN_shell = init_int_matrix(4, num_unique_shells);
    count = 0;
    for (int M = 0; M < nshell; M++) {
        int numm = basis->shell(M)->nfunction();
        for (int N = 0; N <= M; N++, count++) {
            int numn = basis->shell(N)->nfunction();
            MN_shell[0][count] = M;
            MN_shell[1][count] = numm;
            MN_shell[2][count] = N;
            MN_shell[3][count] = numn;
        }
    }
    sort_shell(MN_shell, num_unique_shells);

    int maxshell = MN_shell[1][0];
    //  std::cout << "maxshell = " << maxshell << std::endl;

    double **recv;
    recv = block_matrix(nso, nso);

    mn_owner = get_mn_owner(num_unique_shells);
    int num_mn_owned = get_mn_pairs(num_unique_shells);

    eri_2_mn = (double ***) calloc(ij_pairs, sizeof (double **));
    for (ij = 0; ij < ij_pairs; ij++) {
        eri_2_mn[ij] = block_matrix(nso, nso);
    }


    eri_ao = (double ***) calloc(maxshell*maxshell, sizeof (double **));
    for (i = 0; i < maxshell * maxshell; i++) {
        eri_ao[i] = block_matrix(nso, nso);
    }
    double **Y = block_matrix(nso, nso);

    //  **** Integral direct half AO-MO integral transformation
    for (count = 0; count < num_unique_shells; count++) {
        M = MN_shell[0][count];
        int numm = MN_shell[1][count];
        N = MN_shell[2][count];
        int numn = MN_shell[3][count];

        mn_pairs = numn*numm;

        if (myid == mn_owner[count]) {

            for (i = 0; i < maxshell * maxshell; i++)
                zero_mat(eri_ao[i], nso, nso);

            for (R = 0; R < nshell; R++) {
                int numr = basis->shell(R)->nfunction();
                for (S = 0; S < nshell; S++) {
                    int nums = basis->shell(S)->nfunction();

                    eri->compute_shell(M, R, N, S);

                    //  **** First quarter integral transformation ****
                    int index = 0;
                    for (int m = 0; m < numm; m++) {
                        int om = basis->shell(M)->function_index() + m;
                        for (int r = 0; r < numr; r++) {
                            int oor = basis->shell(R)->function_index() + r;
                            for (int n = 0; n < numn; n++) {
                                int oon = basis->shell(N)->function_index() + n;
                                for (int s = 0; s < nums; s++, index++) {
                                    int os = basis->shell(S)->function_index() + s;

                                    if (fabs(buffer[index]) > 1.0e-14) {
                                        if (numm >= numn)
                                            mn = n * numn + m;
                                        else
                                            mn = m * numm + n;

                                        eri_ao[mn][oor][os] = buffer[index];
                                    }
                                } // End of s loop
                            } // End of n loop
                        } // End of r loop
                    } // End of m loop
                } // End of S loop
            } // Enf of R loop

            for (mn = 0; mn < mn_pairs; mn++) {
                C_DGEMM('t', 'n', nocc, nso, nso, 1, &(C[0][0]),
                        nso, &(eri_ao[mn][0][0]), nso, 0, &(Y[0][0]), nso);
                C_DGEMM('n', 'n', nocc, nocc, nso, 1, &(Y[0][0]),
                        nso, &(C[0][0]), nso, 0, &(eri_ao[mn][0][0]), nso);
            }

            for (i = 0, ij = 0; i < nocc; i++) {
                for (j = 0; j <= i; j++, ij++) {
                    for (int m = 0; m < numm; m++) {
                        int om = basis->shell(M)->function_index() + m;
                        for (int n = 0; n < numn; n++) {
                            int oon = basis->shell(N)->function_index() + n;

                            if (numm >= numn)
                                mn = n * numn + m;
                            else
                                mn = m * numm + n;

                            if (myid == ij_owner[ij]) {
                                if (fabs(eri_ao[mn][i][j]) > 1.0e-14)
                                    eri_2[ij_local[ij]][om][oon] = eri_ao[mn][i][j];
                            } else {
                                if (fabs(eri_ao[mn][i][j]) > 1.0e-14)
                                    eri_2_mn[ij][om][oon] = eri_ao[mn][i][j];
                            }

                            if (M > N) {
                                if (myid == ij_owner[ij]) {
                                    if (fabs(eri_ao[mn][j][i]) > 1.0e-14)
                                        eri_2[ij_local[ij]][oon][om] = eri_ao[mn][j][i];
                                } else {
                                    if (fabs(eri_ao[mn][j][i]) > 1.0e-14)
                                        eri_2_mn[ij][oon][om] = eri_ao[mn][j][i];
                                }

                            }
                        }
                    }
                }
            }

        } // End of mn_owner

/*        for (ij = 0; ij < ij_pairs; ij++) {
            if ((myid == ij_owner[ij]) && (myid != mn_owner[count])) {
                zero_mat(recv, nso, nso);
                //MPI::COMM_WORLD.Recv(&(recv[0][0]), nso * nso, MPI::DOUBLE, mn_owner[count], ij);
                Communicator::world->recv(mn_owner[count], recv[0], nso * nso);

                M = MN_shell[0][count];
                int numm = MN_shell[1][count];
                N = MN_shell[2][count];
                int numn = MN_shell[3][count];

                for (int m = 0; m < numm; m++) {
                    int om = basis->shell(M)->function_index() + m;
                    for (int n = 0; n < numn; n++) {
                        int oon = basis->shell(N)->function_index() + n;

                        if (M > N) {
                            if (fabs(recv[om][oon]) > 1.0e-14)
                                eri_2[ij_local[ij]][om][oon] = recv[om][oon];
                            if (fabs(recv[oon][om]) > 1.0e-14)
                                eri_2[ij_local[ij]][oon][om] = recv[oon][om];
                        } else {
                            if (fabs(recv[om][oon]) > 1.0e-14)
                                eri_2[ij_local[ij]][om][oon] = recv[om][oon];
                        }
                    }
                }
            }
            else if ((myid != ij_owner[ij]) && (myid == mn_owner[count])) {
                //MPI::COMM_WORLD.Send(&(eri_2_mn[ij][0][0]), nso * nso, MPI::DOUBLE, ij_owner[ij], ij);
                Communicator::world->send(ij_owner[ij], eri_2_mn[ij][0], nso * nso);
            }
        }
*/
    } // End of count loop

    for (ij = 0; ij < ij_pairs; ij++) {
        for (count = 0; count < num_unique_shells; count++) {
            if ((myid == ij_owner[ij]) && (myid != mn_owner[count])) {
                zero_mat(recv, nso, nso);
                //MPI::COMM_WORLD.Recv(&(recv[0][0]), nso * nso, MPI::DOUBLE, mn_owner[count], ij);
                Communicator::world->recv(mn_owner[count], recv[0], nso * nso);

                M = MN_shell[0][count];
                int numm = MN_shell[1][count];
                N = MN_shell[2][count];
                int numn = MN_shell[3][count];

                for (int m = 0; m < numm; m++) {
                    int om = basis->shell(M)->function_index() + m;
                    for (int n = 0; n < numn; n++) {
                        int oon = basis->shell(N)->function_index() + n;

                        if (M > N) {
                            if (fabs(recv[om][oon]) > 1.0e-14)
                                eri_2[ij_local[ij]][om][oon] = recv[om][oon];
                            if (fabs(recv[oon][om]) > 1.0e-14)
                                eri_2[ij_local[ij]][oon][om] = recv[oon][om];
                        } else {
                            if (fabs(recv[om][oon]) > 1.0e-14)
                                eri_2[ij_local[ij]][om][oon] = recv[om][oon];
                        }
                    }
                }

            } else if ((myid != ij_owner[ij]) && (myid == mn_owner[count])) {
                //MPI::COMM_WORLD.Send(&(eri_2_mn[ij][0][0]), nso * nso, MPI::DOUBLE, ij_owner[ij], ij);
                Communicator::world->send(ij_owner[ij], eri_2_mn[ij][0], nso * nso);
            }
        }
    }

    //  **** Free the memory used for the first half integral transformation ****
    // Freeing the memory used by eri_2_mn, the map_m, and the buffers used in the communication
    for (ij = 0; ij < ij_pairs; ij++)
        free_block(eri_2_mn[ij]);
    free(eri_2_mn);
    //free(map_m);
    //free(map_buf);
    for (i = 0; i < maxshell * maxshell; i++)
        free_block(eri_ao[i]);
    free(eri_ao);
    free_block(recv);


    // Allocating the memory needed by Ktilde
    if (ij_pairs % nprocs == 0) {
        Ktilde = (double ***) malloc((ij_pairs / nprocs) * sizeof (double **));
        for (ij = 0; ij < ij_pairs; ij++) {
            if (myid == ij_owner[ij])
                Ktilde[ij_local[ij]] = block_matrix(pairdom_len[ij], pairdom_len[ij]);
        }
    } else {
        if (myid < ij_pairs % nprocs) {
            Ktilde = (double ***) malloc(((ij_pairs / nprocs) + 1) * sizeof (double **));
            for (ij = 0; ij < ij_pairs; ij++) {
                if (myid == ij_owner[ij])
                    Ktilde[ij_local[ij]] = block_matrix(pairdom_len[ij], pairdom_len[ij]);
            }
        } else {
            Ktilde = (double ***) malloc(ij_pairs / nprocs * sizeof (double **));
            for (ij = 0; ij < ij_pairs; ij++) {
                if (myid == ij_owner[ij])
                    Ktilde[ij_local[ij]] = block_matrix(pairdom_len[ij], pairdom_len[ij]);
            }
        }
    }

    double **Rt = block_matrix(nso, nso);

    for (ij = 0; ij < ij_pairs; ij++) {
        if (myid != ij_owner[ij]) continue;
        zero_mat(Rt, nso, nso);
        for (k = 0, b = 0; k < natom; k++) {
            if (pairdomain[ij][k]) {
                for (int l = aostart[k]; l <= aostop[k]; l++, b++) {
                    for (int m = 0; m < nso; m++) {
                        Rt[m][b] = Rt_full[m][l];
                    }
                }
            }
        }

        C_DGEMM('t', 'n', pairdom_len[ij], nso, nso, 1, &(Rt[0][0]),
                nso, &(eri_2[ij_local[ij]][0][0]), nso, 0, &(Y[0][0]), nso);
        C_DGEMM('n', 'n', pairdom_len[ij], pairdom_len[ij], nso, 1, &(Y[0][0]),
                nso, &(Rt[0][0]), nso, 0, &(Ktilde[ij_local[ij]][0][0]), pairdom_len[ij]);

    }

    // Freeing the memory used by eri_2
    if (ij_pairs % nprocs == 0) {
        for (ij = 0; ij < ij_pairs / nprocs; ij++)
            free_block(eri_2[ij]);
    } else {
        if (myid < ij_pairs % nprocs) {
            for (ij = 0; ij < (ij_pairs / nprocs) + 1; ij++)
                free_block(eri_2[ij]);
        } else {
            for (ij = 0; ij < ij_pairs / nprocs; ij++)
                free_block(eri_2[ij]);
        }
    }
    free(eri_2);
    free_block(Y);
    free_block(Rt);
    free(mn_owner);
    free(ij_owner);
    free(ij_local);

}

}
} // namespace psi::lmp2
