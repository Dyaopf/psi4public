/*! \file
    \ingroup LMP2
    \brief compute the mp2 amplitudes
*/
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <pthread.h>
#include <libipv1/ip_lib.h>
#include <libciomr/libciomr.h>
#include <libchkpt/chkpt.h>
#include <libpsio/psio.h>
#include <libqt/qt.h>
//#include <psifiles.h>
#define EXTERN
#include "globals.h"
extern pthread_mutex_t compute_mutex;

namespace psi{ namespace lmp2{

void amplitudes() {

  int i, j, v, kj, ik, l, k, m, n;
  int a, b, c, d, r, s, ij, L, M, K;
  int t, N, u, o, O;
  int nvir, nocc, natom, nso;
  int dom_kj, dom_ik;
  double **temp, **temp1, **temp_S, **X, **Y;
  double **Rtilde;
  double **Rbar, **Tbar, **T1;
  double **Rt, **St, **T, **Ft;
  
  nso = mo.nso;
  nocc = mo.nocc;
  nvir = nso - nocc;
  natom = mo.natom;

  if(lo.iter > 1 && params.fskip >= 1e-5) params.fskip *= 0.5;

  v=0;
  for(i=0, ij=0; i < nocc; i++) {
    for(j=0; j <= i; j++, ij++, v++) {

      zero_mat(lo.T[diis.div][ij], lo.pairdom_len[ij], lo.pairdom_len[ij]);
      if(v%params.nprocs != params.myid) 
        continue;

      /* Build the virtual space overlap and Fock matrices for this pair */
      St = block_matrix(lo.pairdom_len[ij],lo.pairdom_len[ij]);
      Ft = block_matrix(lo.pairdom_len[ij],lo.pairdom_len[ij]);
      for(r=0,K=0; r < natom; r++) {
        if(lo.pairdomain[ij][r]) {
          for(k=lo.aostart[r]; k <= lo.aostop[r]; k++,K++) {
            for(s=0,L=0; s < natom; s++) {
              if(lo.pairdomain[ij][s]) {
                for(l=lo.aostart[s]; l <= lo.aostop[s]; l++,L++) {

                  St[K][L] = pao.ovlp[k][l];
                  Ft[K][L] = pao.F[k][l];
                }
              }
            }
          }
        }
      }


        Rtilde = block_matrix(lo.pairdom_len[ij], lo.pairdom_len[ij]);
        temp = block_matrix(lo.pairdom_len[ij], lo.pairdom_len[ij]);
        Y = block_matrix(lo.pairdom_len[ij], lo.pairdom_len[ij]);

        if(lo.iter > 0) {

          C_DCOPY(lo.pairdom_len[ij]*lo.pairdom_len[ij], lo.Ktilde[ij][0], 1, Rtilde[0], 1);

          C_DGEMM('n', 'n', lo.pairdom_len[ij], lo.pairdom_len[ij], lo.pairdom_len[ij], 1, Ft[0], 
                  lo.pairdom_len[ij], lo.T[diis.dmat1][ij][0], lo.pairdom_len[ij], 0, temp[0], lo.pairdom_len[ij]);
          C_DGEMM('n', 'n', lo.pairdom_len[ij], lo.pairdom_len[ij], lo.pairdom_len[ij], 1, temp[0], 
                  lo.pairdom_len[ij], St[0], lo.pairdom_len[ij], 1, Rtilde[0], lo.pairdom_len[ij]);

          C_DGEMM('n', 'n', lo.pairdom_len[ij], lo.pairdom_len[ij], lo.pairdom_len[ij], 1, St[0], 
                  lo.pairdom_len[ij], lo.T[diis.dmat1][ij][0], lo.pairdom_len[ij], 0, temp[0], lo.pairdom_len[ij]);
          C_DGEMM('n', 'n', lo.pairdom_len[ij], lo.pairdom_len[ij], lo.pairdom_len[ij], 1, temp[0], 
                  lo.pairdom_len[ij], Ft[0], lo.pairdom_len[ij], 1, Rtilde[0], lo.pairdom_len[ij]);

          X = block_matrix(lo.pairdom_len[ij], lo.pairdom_len[ij]);
          for(k=0; k < nocc; k++) {
            if(k>j) kj = (k*(k+1))/2 + j;
            else kj = (j*(j+1))/2 + k;

            if(i>k) ik = (i*(i+1))/2 + k;
            else ik = (k*(k+1))/2 + i;

            if(fabs(lo.F[i][k]) > params.fskip) {
              temp_S = block_matrix(lo.pairdom_len[ij], lo.pairdom_len[kj]);
              temp1 = block_matrix(lo.pairdom_len[ij], lo.pairdom_len[kj]);

              for(r=0,L=0; r < natom; r++) {
                if(lo.pairdomain[ij][r]) {
                  for(l=lo.aostart[r]; l <= lo.aostop[r]; l++,L++) {
                    for(s=0,M=0; s < natom; s++) {
                      if(lo.pairdomain[kj][s]) {
                        for(m=lo.aostart[s]; m <= lo.aostop[s]; m++,M++) {
                          temp_S[L][M] = pao.ovlp[l][m];
                        }
                      }
                    }
                  }
                }
              }

              if(k <= j) {
                C_DGEMM('n', 't', lo.pairdom_len[ij], lo.pairdom_len[kj], lo.pairdom_len[kj], -lo.F[i][k],
                        temp_S[0], lo.pairdom_len[kj], lo.T[diis.dmat1][kj][0], lo.pairdom_len[kj],
                        0, temp1[0], lo.pairdom_len[kj]);
                C_DGEMM('n', 't', lo.pairdom_len[ij], lo.pairdom_len[ij], lo.pairdom_len[kj], 1,
                        temp1[0], lo.pairdom_len[kj], temp_S[0], lo.pairdom_len[kj], 1, X[0], lo.pairdom_len[ij]);
              }
              else {
                C_DGEMM('n', 'n', lo.pairdom_len[ij], lo.pairdom_len[kj], lo.pairdom_len[kj], -lo.F[i][k],
                        temp_S[0], lo.pairdom_len[kj], lo.T[diis.dmat1][kj][0], lo.pairdom_len[kj],
                        0, temp1[0], lo.pairdom_len[kj]);
                C_DGEMM('n', 't', lo.pairdom_len[ij], lo.pairdom_len[ij], lo.pairdom_len[kj], 1,
                        temp1[0], lo.pairdom_len[kj], temp_S[0], lo.pairdom_len[kj], 1, X[0], lo.pairdom_len[ij]);
              }

              free_block(temp_S);
              free_block(temp1);
            }


            if(fabs(lo.F[k][j]) > params.fskip) {
              temp_S = block_matrix(lo.pairdom_len[ij], lo.pairdom_len[ik]);
              temp1 = block_matrix(lo.pairdom_len[ij], lo.pairdom_len[ik]);

              for(r=0,L=0; r < natom; r++) {
                if(lo.pairdomain[ij][r]) {
                  for(l=lo.aostart[r]; l <= lo.aostop[r]; l++,L++) {
                    for(s=0,M=0; s < natom; s++) {
                      if(lo.pairdomain[ik][s]) {
                        for(m=lo.aostart[s]; m <= lo.aostop[s]; m++,M++) {
                          temp_S[L][M] = pao.ovlp[l][m];
                        }
                      }
                    }
                  }
                }
              }
 
              if(k >= i) {
                C_DGEMM('n', 't', lo.pairdom_len[ij], lo.pairdom_len[ik], lo.pairdom_len[ik], -lo.F[k][j],
                        temp_S[0], lo.pairdom_len[ik], lo.T[diis.dmat1][ik][0], lo.pairdom_len[ik],
                        0, temp1[0], lo.pairdom_len[ik]);
                C_DGEMM('n', 't', lo.pairdom_len[ij], lo.pairdom_len[ij], lo.pairdom_len[ik], 1,
                        temp1[0], lo.pairdom_len[ik], temp_S[0], lo.pairdom_len[ik], 1, X[0], lo.pairdom_len[ij]);
              }
              else {

                C_DGEMM('n', 'n', lo.pairdom_len[ij], lo.pairdom_len[ik], lo.pairdom_len[ik], -lo.F[k][j],
                        temp_S[0], lo.pairdom_len[ik], lo.T[diis.dmat1][ik][0], lo.pairdom_len[ik],
                        0, temp1[0], lo.pairdom_len[ik]);
                C_DGEMM('n', 't', lo.pairdom_len[ij], lo.pairdom_len[ij], lo.pairdom_len[ik], 1,
                        temp1[0], lo.pairdom_len[ik], temp_S[0], lo.pairdom_len[ik], 1, X[0], lo.pairdom_len[ij]);
              }

              free_block(temp_S);
              free_block(temp1);
            }

          }
//          fprintf(outfile, "\nX[%d]:\n", ij);
//          fprintf(outfile,   "======\n");
//          print_mat(X, lo.pairdom_len[ij], lo.pairdom_len[ij], outfile);
          
          add_mat(X, Rtilde, Rtilde, lo.pairdom_len[ij],lo.pairdom_len[ij]);

          free_block(X);
        }
        else {
          C_DCOPY(lo.pairdom_len[ij]*lo.pairdom_len[ij], lo.Ktilde[ij][0], 1, Rtilde[0], 1);
        }

        free_block(St);
        free_block(Ft);

//        fprintf(outfile, "\nRtilde[%d]:\n", ij);
//        fprintf(outfile,   "======\n");
//        print_mat(Rtilde, lo.pairdom_len[ij], lo.pairdom_len[ij], outfile);


        Rbar = block_matrix(lo.pairdom_nrlen[ij], lo.pairdom_nrlen[ij]);
        temp = block_matrix(lo.pairdom_nrlen[ij], lo.pairdom_len[ij]);

        // *** Transform the Rij matrices to an orthogonal basis
        C_DGEMM('t', 'n', lo.pairdom_nrlen[ij], lo.pairdom_len[ij], lo.pairdom_len[ij], 1, lo.W[ij][0], 
                lo.pairdom_nrlen[ij], Rtilde[0], lo.pairdom_len[ij], 0, temp[0], lo.pairdom_len[ij]);
        C_DGEMM('n', 'n', lo.pairdom_nrlen[ij], lo.pairdom_nrlen[ij], lo.pairdom_len[ij], 1, temp[0], 
                lo.pairdom_len[ij], lo.W[ij][0], lo.pairdom_nrlen[ij], 0, Rbar[0], lo.pairdom_nrlen[ij]);

//        fprintf(outfile, "\nRbar[%d]:\n", ij);
//        fprintf(outfile,   "======\n");
//        print_mat(Rbar, lo.pairdom_nrlen[ij], lo.pairdom_nrlen[ij], outfile);

        free_block(Rtilde);

        Tbar = block_matrix(lo.pairdom_nrlen[ij], lo.pairdom_nrlen[ij]);
        // *** Apply the denominator
        for(a=0; a < lo.pairdom_nrlen[ij]; a++) {
          for(b=0; b < lo.pairdom_nrlen[ij]; b++) {
//            if(fabs(Rbar[a][b]) > 1e-14) 
              Tbar[a][b] = -Rbar[a][b] / (lo.evals[ij][a] + lo.evals[ij][b] - lo.F[i][i] - lo.F[j][j]);
          }
        }
//        fprintf(outfile, "Tbar[%d] Matrix", ij);
//        print_mat(Tbar, lo.pairdom_nrlen[ij], lo.pairdom_nrlen[ij], outfile);
//        fprintf(outfile, "lo.F[%d][%d] = %20.12f\n", lo.F[i][i]);

        free_block(Rbar);

        if(lo.iter > 0) {
          C_DCOPY(lo.pairdom_len[ij]*lo.pairdom_len[ij], lo.T[diis.dmat1][ij][0], 1, lo.T[diis.div][ij][0], 1);
          C_DGEMM('n', 'n', lo.pairdom_len[ij], lo.pairdom_nrlen[ij], lo.pairdom_nrlen[ij], 1, lo.W[ij][0],
                  lo.pairdom_nrlen[ij], Tbar[0], lo.pairdom_nrlen[ij], 0, temp[0], lo.pairdom_nrlen[ij]);
          C_DGEMM('n', 't', lo.pairdom_len[ij], lo.pairdom_len[ij], lo.pairdom_nrlen[ij], 1, temp[0],
                  lo.pairdom_nrlen[ij], lo.W[ij][0], lo.pairdom_nrlen[ij], 1, lo.T[diis.div][ij][0],
                  lo.pairdom_len[ij]);
        }
        else {
          // *** Back Transform the amplitudes into the non-orthogonal basis ***
          C_DGEMM('n', 'n', lo.pairdom_len[ij], lo.pairdom_nrlen[ij], lo.pairdom_nrlen[ij], 1, lo.W[ij][0], 
                  lo.pairdom_nrlen[ij], Tbar[0], lo.pairdom_nrlen[ij], 0, temp[0], lo.pairdom_nrlen[ij]);
          C_DGEMM('n', 't', lo.pairdom_len[ij], lo.pairdom_len[ij], lo.pairdom_nrlen[ij], 1, temp[0], 
                  lo.pairdom_nrlen[ij], lo.W[ij][0], lo.pairdom_nrlen[ij], 0, lo.T[diis.div][ij][0],
                  lo.pairdom_len[ij]);
        }

//        fprintf(outfile, "\nT[%d]:\n", ij);
//        fprintf(outfile,   "======\n");
//        print_mat(lo.T[diis.div][ij], lo.pairdom_len[ij], lo.pairdom_len[ij], outfile);

        free_block(Tbar);
        free_block(temp);

//      }
//      v++;
    }
  }


  v=0;
  for(i=0, ij=0; i < nocc; i++) {
    for(j=0; j <= i; j++, ij++, v++) {

      // *** Redistribute Amplitudes to all procs ***
      MPI_Win Twin;
      if(params.myid == v%params.nprocs) {
        MPI_Win_create(lo.T[diis.div][ij][0], lo.pairdom_len[ij]*lo.pairdom_len[ij]*sizeof(double),
                       sizeof(double), MPI_INFO_NULL, MPI_COMM_WORLD, &Twin);
      }
      else {
        MPI_Win_create(NULL, 0, 1, MPI_INFO_NULL, MPI_COMM_WORLD, &Twin);
      }

      MPI_Win_fence(0, Twin);
      if(params.myid != v%params.nprocs) {
        MPI_Get(lo.T[diis.div][ij][0], lo.pairdom_len[ij]*lo.pairdom_len[ij], MPI_DOUBLE, v%params.nprocs, 0,
                lo.pairdom_len[ij]*lo.pairdom_len[ij], MPI_DOUBLE, Twin);
      }
      MPI_Win_fence(0, Twin);

      MPI_Win_free(&Twin);

    }
  }


}

}} // namespace psi::lmp2
