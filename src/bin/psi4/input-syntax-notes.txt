These are notes on the input format for PSI4.  Lori's original notes
are below.  Newer notes are on top.

C. David Sherrill, 7 August 2010

Here's the current basic idea which has evolved from conversations with
Jet, Andy, and Lori.  We'll have a fairly simple, user-friendly input
format which, optionally, can contain as much Python code as the user
wants.  Any Python code will be valid.  We will then convert the non-Python
code into Python code with a parser so that the entire input is run as a
script using Python exec() statements.  The reason we need to convert the
entire input (instead of some particular line or block) is that the user 
will surely want to embed some PSI directives inside the Python code block,
and we can ony call exec() on an entire block, not pieces of a code block
at a time.

Thus, we will develop a "PSI-Python" language which is just adding some
special PSI keywords/directives to Python.  The PSI-Python input is 
parsed and converted into valid Python (including PsiMod calls), and the
Python is executed by passing the whole thing to exec().  

Because we will parse the entire input all at once before executing, this
makes parsing a little easier because we can look for multi-line regexp's.
We actually need to parse the whole input at once (rather than
line-by-line) because that's probably the only way to look for special
things like z-matrix variable resets later in the script.  That's going to
be one of the tricky parts --- variables in a z-matrix specification may be
reset later in the script (think PES scans ala MOLPRO).  We can do that
but we will need to make a special list of all z-matrix variables, and then
look for them later in input.  When we see them being set, we need to call
some PsiMod function which will set them in the molecule (either the
default molecule or some named molecule if there are more than one).

So, what are the special PSI keywords in PsiPython?  Eventually we could
make all user options as keywords, but initially it's easier to set those
with a special "i'm about to set a PSI user option" keyword.  I propose to
initially do this with they syntax:

set {
  charge 0
  multiplicity 1
}

or

set charge 0
set multiplicity 1

or 

! charge 0
! multiplicity 1

User comments are marked by # symbols (already the Python comment symbol)

The other special section we need is for the molecule.  This can be

mol {
  [Cartesian or z-matrix goes in here]
}

I'm putting an example of this input style in example-input-1.in

What I need to figure out next is how to handle the "sectioning" of input
the way Jet has implemented it in PsiMod.

---CDS 8/7/10

Maybe we could do sectioning like this:

set (dfmp2) {
  no_input true
  basis 3-21G
  ri-basis cc-pvdz
}

The final special psi input would be specifying the modules to run.
Lori suggested things like

  sp ccsd(t)

I think this seems ok at first glance (the other option would just be to
say ccsd(t), but sp is good because alternatively it could say opt or
freq).

How will we do optimizations of composite or user-defined sequences?
Not sure, but perhaps we could have a user-defined wavefunction
(energy or grad) sequence, and then call sp/opt/freq on that...

  sp wfn1

wfn1 {
  scf     # module names?
  ccsd(t) # another module
  # probably need to be able to mix python code in here...
}

---CDS 8/9/10


Older notes:
-------------------------------------------------------------------------
LAB, Monday, January 10, 2009

Perspectives on Input Files (with Samples)
-------------------------------------------------------------
OPTIONS

[1]	Options naturally belong to one module or portion. Ways to indicate this are following.
	[a]	proximity with the module: cis(singlets,nstates=4,root=1)
	[b]	blocks in the input: $scf \n conv=7 \n $end
	[c]	input in one section with prefixes on keywords: scf_conv = 7
[2]	Problems with [1a] are that any array-type input like basis sets, optrot lengths,
	etc. must be supplied after the main input and geometry. Also, not one line
	per command, as convenient for perl input scripts. Currently, gaussian & gamess-us.
[3]	Problems with [1b] (like psi3 & nwchem are now) are that one-line directives can 
	get lost in the arrays, conv can mean different things depending on which block 
	its in, and the block specification starts to look untidy, lose where actual 
	execution directives are.
[4]	Problems with [1c] (like q-chem) is un-OOP-like in that the modules have to have their
	keywords assigned, rather than taking ownership of them in some member-like scheme.
[5]	Users here like writing input files with one piece of info per line- better for
	scripting, so no gaussian-type.
[6]	On the whole, think [1c] is best scheme. Users recognize through the names of
	keywords exactly what they're settings. Formatting is clear with one main keyword section,
	and no multiple valid locations for a given keyword. So, much like q-chem with
	all simple keywords and small arrays looking $rem-like. Cumbersome arrays, like
	$basis and $hess can be in separate sections.

MULTIJOBS

[7]	Even if no one quite approves of my running a curve all from one input file via *** links,
	specifying multiple jobs per file is quite necessary, say when a basis2 scf starter
	calc is needed for xdm. I see three schemes.
	[a]	nothing, like psi3 presently offers
	[b]	strictly formatted schemes (gaussian & q-chem) where separate jobs
		are clearly delimited by --link0-- or @@@ and basic info (molecule) is shared by
		read commands and any keywords are reset for each job.
	[c]	loosely formatted schemes (molpro & nwchem) where jobs are specified freely and
		basic info and keywords are maintained until overwritten.
[8]	Problem with [7b] is that flexibility to connect results between multiple jobs is
	very limited to what the package programmers think you ought to be doing. They might
	allow a set of bsse calculations or a pes scan, but the user may be more imaginative.
[9]	Problem with [7c] is that files get confusing with just a little complexity. It's difficult
	to quickly see what keyword's set at what at a given point and difficult to distinguish
	between modifiers and directives.
[10]	Interjected note. Common, two-part jobs where the second's validity depends on the first
	(i.e., opt+freq) (and shouldn't be run if the first fails) should be combined into a new
	jobtype. Those where steps are independent (e.g., scan along curve) should retain usual
	sequential control.
[11]	We definitely want the [7c] flexibility, but would like to make each job and its associated
	set or reset parameters more distinctive.

STYLE

[12]	For any multiline input (e.g., molecule or hessian), format should be sufficiently free
	to copy the main body directly, with any required brackets only on their own lines at the
	beginning and end.
[13]	Atom labels in the molecule section should permit labels such as "C", "C5", or "6".
[14]	The same information should never be required multiple times in an input shell (e.g.,
	ref_points).
[15]	For non-standard basis sets, should be able to use cc-pVDZ on all H and aug-cc-pVDZ on
	all O easily, like the following.
		C 0
		aug-cc-pVDZ
		****
		H 0
		cc-pVDZ
		****

FORMAT

[16]	Molcas defines a number of commands for interfacing with the Unix environment. Though one
	could just make systems calls, these are designed to be safe and sensible for multiple
	threads. Such wrappers could be useful to us.
		> export A = B		! sets environmental variable
		> exit			! ends program execution
		> include file
		> unix			! execute unix command
		> link file file
		> copy file file
		> rm file
		> eval A = B		! does simple math in shell
		> verbatim		! these two are actually for input, not environment,
		> end verbatim		!    but perhaps they would be appropriate elsewhere
[17]	If we like Molpro loop structure so much, it would be good to copy it exactly or 
	modify it only in an easy-to-remember-and-modify way. Below, I have only adjusted array
	variables to be ()-based.
[18]	Four types of lines:
	!  comment, first one taken as job title
	   modifiers, all the usual keywords, basis sets, etc.
	#  psi4 directive, e.g., opt mp2, sp dft-d, response ccsd
	>  system directive, handle unix commands over || nodes, call python scripts, etc.,
	   also input structure directive for loops, variables, etc.
[19]	Each # indicates point in input at which psi4 executes. Indicates some reinitiating
	of the program from $mol, even if a good deal is set from read (?).
[20]	This is perhaps far-fetched. Use number of >> as indicator of indent level when
	reinterpreted into python. NWchem seems concerned about this.


-------------------------------------------------------------
! optimization + frequency + freq w/alt isotopes

mol_coord	cartesian	! should be unnecc
mol_units	angstrom	! unlike q-chem, should actually permit au/bohr/ang/angstrom
nfrag		2

mol1 {				! need numbers (mol1, mol2), otherwise considered as
0 1				!    overwriting the molecule under consideration
C1        2.14005789      -0.20652795       0.00000000
H1        3.23921879      -0.31260333       0.00000000
O1        1.36379229      -1.15537668       0.00000000
O2        1.76438167       1.08605925       0.00000000
H2        0.78011615       1.11617462       0.00000000
}
mol2 {				! on the whole, let's minimize "="
0 1
C2       -2.14005789       0.20652795       0.00000000
H3       -3.23921879       0.31260333       0.00000000
O3       -1.36379229       1.15537668       0.00000000
O4       -1.76438167      -1.08605925       0.00000000
H4       -0.78011615      -1.11617462       0.00000000
}

basis		cc-pVDZ
opt_conv	verytight
opt_mode	rfo
opt_maxstep	0.2
freq_hessguess	Schlegel
freq_hessfate	file		! save hessian to standard filename, say job.hess

# optfreq mp2			! yes, I know, psi3 doesn't do this analytic freq but humor me
> copy job.hess job_default.hess

freq_hessguess	read		! read from std location, say job.hess
mol_isotopes 	13, 1, 16, 16, 1, 13, 1, 16, 16, 1
freq_hessfate	file		! save hessian to standard filename, say job.hess

# freq
> copy job.hess job_c13.hess

> copy job_default.hess job.hess
freq_hessguess	read		! read from std location, say job.hess
mol_isotopes 	12, 2, 16, 16, 2, 12, 2, 16, 16, 2
freq_hessfate	file		! save hessian to standard filename, say job.hess

# freq
> copy job.hess job_h2.hess

! we're pretending here that mw hessians are saved so all these files are actually different


-------------------------------------------------------------
! bsse-corrected interaction energy along surface

mol_coord	zmat		! need special "vzmat" for zmat w/variables?
mol_units	angstrom

mol1 {
O 
H1 O r1(i) 
H2 O r2(i) H1 theta(i)
Ar O 2.0   H1 (180.0 - theta(i)/2.0) H2 0.0
}

basis		6-31G*
reference	rhf

> angles = (100, 104, 110) 
> distances = (1.6, 1.7, 1.8, 1.9, 2.0) 
> i=0 
> do ith=1,#angles		! conflict between number-of-angles and # as directive?
>> do ir1=1,#distances 
>>> do ir2=1,ir1 
>>>> i=i+1 
>>>> r1(i) = distances(ir1) 
>>>> r2(i) = distances(ir2) 
>>>> theta(i) = angles(ith) 

#### sp ccsd(t)

>>>> escf_dimer(i) = energyscf 
>>>> eccsd_dimer(i) = energc 
>>>> eccsdt_dimer(i) = energy
 
     dummy	1, 2, 3

#### sp ccsd(t)

>>>> escf_ar(i) = energyscf 
>>>> eccsd_ar(i) = energc 
>>>> eccsdt_ar(i) = energy

     dummy	4

#### sp ccsd(t)

>>>> escf_water(i) = energyscf 
>>>> eccsd_water(i) = energc 
>>>> eccsdt_water(i) = energy

!    compute BSSE-corrected interaction energy
>>>> ie_cpc_escf(i) = 627.5095 * ( escf_dimer(i) - escf_ar(i) - escf_water(i) )
>>>> ie_cpc_eccsd(i) = 627.5095 * ( eccsd_dimer(i) - eccsd_ar(i) - eccsd_water(i) )
>>>> ie_cpc_eccsdt(i) = 627.5095 * ( eccsdt_dimer(i) - eccsdt_ar(i) - eccsdt_water(i) )

>>> enddo 
>> enddo 
> enddo

table		r1, r2, theta, ie_cpc_escf, ie_cpc_eccsd, ie_cpc_eccsdt 
head		r1, r2, theta, scf, ccsd, ccsd(t)
tablefate	file 		! save table to standard filename, say job.table


-------------------------------------------------------------
! multiexcitation optrot calc with two nonstandard basis sets for foxy CCSD DZ // CCSD(T) TZ

reference	rhf
freeze_core	true
basis		gen
memory		5 GB		! perhaps unit too complicated
mu_irreps	0, 0, 0
property	rotation
optrot_omega	900.0, 750.0, 633, 589.3, 546.07, 435.83, 365.02, 355, 296.73, 253.65
optrot_units	nm
optrot_gauge	both
mol_coord	zmat
mol_units	angstroms

mol1 {
C
C 1 B1
H 1 B2 2 A1
H 2 B3 1 A2 3 D1
H 2 B4 1 A3 3 D2
O 1 B5 2 A4 4 D3
F 1 B6 6 A5 2 D4
B1     1.451435869346493
B2     1.080342100494882
A1   124.637295644155785
B3     1.080275825235318
A2   117.589052084527367
D1   152.609213811208264
B4     1.080436892377453
A3   120.814488886066712
D2    -4.320890050725013
B5     1.380019589195488
A4    61.853894283054160
D3  -101.877655898744152
B6     1.356382389838422
A5   115.107679355666264
D4  -110.269896254303873
}

basis {
H 0
CC-PVTZ
****
C 0
D-AUG-CC-PVTZ
****
O 0
D-AUG-CC-PVTZ
****
F 0
D-AUG-CC-PVTZ
****
}

# response ccsd

basis {
H 0
CC-PVDZ
****
C 0
D-AUG-CC-PVDZ
****
O 0
D-AUG-CC-PVDZ
****
F 0
D-AUG-CC-PVDZ
****
}

# response ccsd


-------------------------------------------------------------
! a slightly offbeat calculation (hf xdm) ending with calling a script

mol_coord	cartesian
mol_units	angstrom
nfrag		2

mol1 {
0 1
C1        2.14005789      -0.20652795       0.00000000
H1        3.23921879      -0.31260333       0.00000000
O1        1.36379229      -1.15537668       0.00000000
O2        1.76438167       1.08605925       0.00000000
H2        0.78011615       1.11617462       0.00000000
}
mol2 {
0 1
C2       -2.14005789       0.20652795       0.00000000
H3       -3.23921879       0.31260333       0.00000000
O3       -1.36379229       1.15537668       0.00000000
O4       -1.76438167      -1.08605925       0.00000000
H4       -0.78011615      -1.11617462       0.00000000
}

basis		cc-pVDZ
xdm_method	1
xdm_mol1natoms	5
xdm_print	2
xdm_kai		200

# sp scf

> unix ~loriab/bin/xdm.pl job.out
> copy Rij.h k200_Rij.h

xdm_kai		400

# sp scf

> unix ~loriab/bin/xdm.pl job.out
> copy Rij.h k400_Rij.h

! granted, anyone who knows what xdm and these scripts do, Rij.h isn't going to be different
!    between kappa = 200 & 400


-------------------------------------------------------------

