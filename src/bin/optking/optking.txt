The "v3d" library is for operations on arrays with 3 elements (3D-vectors).
namespace opt::v3d
** scalar multiply 1 vector
inline void v3d_scm(const double a, double *A);

** compute norm of 1 vector
inline double v3d_norm(const double *A);

** take dot product of 2 vectors
inline double v3d_dot(const double *A, const double *B);

** distance between 2 points
inline double v3d_dist(const double *A, const double *B);

** Compute a*X + Y -> Z
inline void v3d_axpy(const double a, const double *X, const double *Y, double *Z);

** Normalize vector A. Return "false" and leave A unchanged if norm of A is less
** than min_norm or greater than max_norm
inline bool v3d_normalize(double *A, const double min_norm=1.0e-8, const double max_norm=1.0e8);

** Compute vector from A -> B.  Normalize eAB.  Return "false" and do not normalize eAB if
** norm is less than min_norm or greater than max_norm
inline bool v3d_eAB(const double *A, const double *B, double *eAB,
const double min_norm=1.0e-8, const double max_norm=1.0e15);

** Compute angle in radians A-B-C (between vector B->A and vector B->C)
inline bool v3d_angle(const double *A, const double *B, const double *C, double & angle);

The "mem.h" library in namespace opt provides
memory allocation and deallocation functions.

The "simple.h" header declares a simple internal coordinate base class containing
public:
get_stype() = the type of internal coordinate
get_natom() = the number of atoms used to define the coordinate
get_atom()  = the atoms used to define the coordinate (constructor allocates memory)
get_val()   = the value of the coordinate
protected:
s_type
s_natom
s_atom
s_val
necessary?
s_val(double) = set value
s_atom(int *) = set atoms 

Contains the following 5 virtual functions which must be provided by derived classes:
** compute value of coordinate
virtual void compute_val(const double **geom) = 0;
** compute s vector (xyz) for atom
virtual double * g_s(const double **geom, const int iatom) const = 0;
** print coordinates with values to text file
virtual void print(const FILE *fp) const = 0;
** print s vectors to text file
virtual void print_s(const FILE *fp, const double **geom) const = 0;
** Each derived class should have an equality operator that first checks
** types with g_stype() and then, if true, compares the internal coordinates
virtual bool operator==(const SIMPLE & s2) const  = 0;

Internal coordinate class declarations
stre.h bend.h

Fragment class (frag.h)
 natom
 atomic numbers
 nuclear masses 
 geometry 
 connectivity 
 vector<SIMPLE *> simples

Two constructor functions
 frag() allocate memory only
 frag(fin, label) read in geometry from file

other functions
 load_default_masses()
 print_geom(fout, print masses?)
 compute_intcos
 print_simples(fout)
 compute_B()
 update_connectivity_by_distances

