****************************************************************************
22 January 2008: CDS

I took out 
#include <unistd.h>
#include <sys/time.h>

from structs.h -- seems ok w/out it.
****************************************************************************
23 January 2008: CDS

I'm going to extract the remaining wreadw/wwritw calls over the next
few days.  As I'm working on this, I notice that there's a lot of
leftover junk having to do with file offsets that we used before we
had the convenience of keyword access with libpsio.  This code is (a)
confusing and (b) not used anymore.  This might be a good opportunity
to remove it to keep the code maintained in good shape.  Specifically,
a lot of this has to do with zero_blocks.  Now zero_blocks tries to
keep up with what blocks are zero and avoid unnecessary computations.
But it *also* tries to avoid unnecessary disk storage in MPn calculations.
The former is in and works and is all ok (and is NOT turned off
by Parameters.zero_blocks = 0).  The latter is what is controlled
by Parameters.zero_blocks, and it is all messed up and obsolete (I assume).
Let me try an MPn calculation with it turned on and see if I even
get the same answer.

Hm, I can't even do it, b/c file51 isn't opened properly for the old I/O.
While this could be fixed, I think it would be better to scrap this
Parameters.zero_blocks feature since it is essentially never used,
doesn't work now, and complicates the code.  I think it could be
re-implemented better if it became of interest again.

Before I go ripping this stuff out (as well as the presumably obsolete
file_offsets junk), let me make a couple more test cases that might
check the fancier versions of CIvect I/O; non-A1 open-shells states would
be perfect, as well as different icore options.

Ok, added several new test cases.  I then ripped out all I/O offset
and I/O-related zero block stuff.  Amazingly, all test cases seem
to pass.  This is actually somewhat surprising...

*************************************************************************
27 April 2015: CDS

Unified naming scheme for CI, MCSCF, and beyond

Per irrep:

----- read from input and just used to set up spaces below, not really
      especially meaningful to the CI:
docc           - Doubly occupied orbitals.
socc           - Singly occupied orbitals.

----- orbitals dropped from the CI, kept doubly occupied
frozen_docc    : truly frozen orbitals, no excitations or orbital rotations
rstr_docc      : Kept doubly occupied but orbital rotations ok in MCSCF
dropped_docc   : frozen_docc + rstr_docc , replaces old frozen_docc

----- orbitals active in the CI
ras_opi[ras]   : orbitals per irrep for RAS space "ras", ras=[0,1,2,3]
                 corresponding to RAS1, RAS2, RAS3, RAS4.  Same thing
                 it always meant. 

----- orbitals dropped from the CI, kept unoccupied
frozen_uocc    : absolutely frozen unoccupied orbitals
rstr_uocc      : kept unoccupied but orbital rotations ok in MCSCF
dropped_uocc   : frozen_uocc + rstr_uocc, replaces old frozen_uocc

Totals:
  CalcInfo.num_expl_cor_orbs = 0; // this isn't enabled anymore, zero it
  CalcInfo.num_fzc_orbs; // truly frozen core, sum(frozen_docc)
  CalcInfo.num_rsc_orbs; // restricted core, sum(rstr_docc)
  CalcInfo.num_fzv_orbs; // truly frozen virts, sum(frozen_uocc)
  CalcInfo.num_rsv_orbs; // restricted virtuals, sum(rstr_uocc)
  CalcInfo.num_drc_orbs; // dropped core  = num_fzc_orbs + num_rsc_orbs
  CalcInfo.num_drv_orbs; // dropped virts = num_fzv_orbs + num_rsv_orbs


In progress: 

  o Made updates to orbital space setup routine, ras_set3(), which replaces
ras_set2() and has a different signature.   Need to also put this in
transqt2() (2, right?) so that numbering is consistent.

  o Once above is checked, do a global replace of num_fzc_orbs with
num_drc_orbs and num_fzv_orbs with num_drv_orbs.

  o Likewise global replace of frozen_docc -> dropped_docc, 
frozen_uocc -> dropped_uocc

  o We should not be getting the guess frozen_per_irrep out of the 
current Process::environment.wavefunction()->frzcpi()[h].  Who knows where
that came from?  Need another mechanism to pass this information.  Maybe
generate it from the molecule itself... is SCF really necessary to get this
info?  See what the SCF does.

  o transqt2 is not currently allowing mixed frozen/restricted, it's either
or (see get_moinfo.cc)

  o 2 test cases fail right now for straight ci.  no tests of mcscf lately.
	228 - rasci-c2-active (Failed)
	229 - rasci-h2o (Failed)
Maybe these are the only ones with restricted so far, need to hardwire
the ci to handle restricted for now (rig back into fzc).  Yeah I suspect
this is the problem.

Hm, that fixes rasci-ne and rasci-h2o but not rasci-c2-active.. .maybe
the active keyword is off... no, it works.  TRANSQT2 dies in part2 of
this input ... ah, exactly because CI set the current wavefunction so
we can no longer get the frozen orbs because they weren't set properly
when the CI wavefunction became active?  (although we re-did the scf...)
Yeah, something like this... run part 2 by itself and it passes

