#include "libmatrix.h"

#include <libplugin/plugin.h>
#include <psi4-dec.h>
#include <libparallel/parallel.h>
#include <liboptions/liboptions.h>
#include <libmints/mints.h>
#include <libdist_matrix/dist_mat.h>
#include <libpsio/psio.hpp>

INIT_PLUGIN

namespace psi { namespace libmatrix {

extern "C" 
int read_options(std::string name, Options& options)
{
    if (name == "TEMPLATE_PLUGIN"|| options.read_globals()) {
    }

    return true;
}

extern "C" 
PsiReturnType template_plugin(Options& options)
{
    // NOTE: This will only initialize the "default" matrix type.
    matrix_globals::initialize(Process::arguments.argc(), Process::arguments.argv());

    printf("Using %s matrix interface\n", matrix_globals::interface_name.c_str());

    Dimension m(1), n(1);
    m[0] = n[0] = 10;

    // Generate default matrices.
    //    Either dist_matrix, serial_matrix, or elemental_matrix
    //    decided at configure/compile time.
    matrix a = create_matrix("A", m, n);
    matrix b = create_matrix("B", m, n);
    matrix c = create_matrix("C", m, n);
    a.fill(1.0);
    b.fill(2.0);
    c.gemm(false, false, 1.0, a, b, 0.0);
    c.print();

    // Create a dist_matrix:
    //     Generates compile error if madness is not available.
    //     NOTE: First error generated by the following line makes it obvious what the problem is.

//    dist_matrix c = create_specific_matrix<dist_matrix>("C", m, n);
//    c.print();

    // Create a serial_matrix
    //     serial_matrix is always available. Compiler errors should never be generated.
    printf("Using serial_matrix objects\n");
    serial_matrix d = create_specific_matrix<serial_matrix>("D", m, n);
    serial_matrix e = create_specific_matrix<serial_matrix>("E", m, n);
    serial_matrix f = create_specific_matrix<serial_matrix>("F", m, n);
    d.fill(1.0);
    e.fill(2.0);
    f.gemm(false, false, 1.0, d, e, 0.0);
    f.print();

//    d.add(c);    // throws at runtime

    // Create an elmental matrix
    //     Generates compile error if elemental is not available.
//    elemental_matrix e = create_specific_matrix<elemental_matrix>("E", m, n);

    return Success;
}

}} // End namespaces

