#include "sapt_dft.h"
#include <libutil/quad.h>

using namespace boost;

namespace psi { namespace sapt {

SAPT_DFT::SAPT_DFT(Options& options, shared_ptr<PSIO> psio, shared_ptr<Chkpt> chkpt)
    : SAPT0(options, psio, chkpt)
{
}

SAPT_DFT::~SAPT_DFT()
{
}

double SAPT_DFT::compute_energy()
{
    form_quadrature();
    form_J();
    form_S();
    form_D();
    form_W();
    form_X0();   
    form_XC();   

    std::vector<double> Edisp20U = casimirPolder(X0_A_, X0_B_);

    std::vector<double> Edisp20C = casimirPolder(X0_A_, X0_B_);

    fprintf(outfile, "\n");
    fprintf(outfile, "  ------------------------------------------------------------------------------\n");       
    fprintf(outfile, "   =======================> CASIMIR-POLDER INTEGRATION <=======================\n");       
    fprintf(outfile, "  ------------------------------------------------------------------------------\n");       
    fprintf(outfile, "   Point     Omega           Weight          E_UCHF [mH]         E_TDDFT [mH]\n");       
    fprintf(outfile, "  ------------------------------------------------------------------------------\n");       
    fflush(outfile);
   
    double E_UCHF = 0.0;
    double E_TDDFT = 0.0;
    double E_DeltaMP2C = 0.0;

    int n = 0;
    for (quad_->reset(); !quad_->isDone(); quad_->nextPoint() ) {
    
        double omega = quad_->getPoint();
        double weight = quad_->getWeight();
   
        double UCHF = Edisp20U[n] / weight;
        double TDDFT = Edisp20C[n] / weight;

        E_UCHF += Edisp20U[n];
        E_TDDFT += Edisp20C[n];
 
        n++;
        fprintf(outfile, "  %3d  %12.8E  %12.8E  %18.12f  %18.12f\n", \
           n, omega, weight, UCHF*1000.0,TDDFT*1000.0);       

    }

    E_DeltaMP2C = E_TDDFT - E_UCHF; 

    fprintf(outfile, "  ------------------------------------------------------------------------------\n");       
    fprintf(outfile, "   @ UCHF Dispersion Energy:  %18.12f [mH] %18.12f [kcal]\n", E_UCHF*1000.0, \
        E_UCHF*627.509);   
    fprintf(outfile, "   @ TDDFT Dispersion Energy: %18.12f [mH] %18.12f [kcal]\n", E_TDDFT*1000.0, \
        E_TDDFT*627.509);   
    fprintf(outfile, "   @ Delta MP2C Energy:       %18.12f [mH] %18.12f [kcal]\n", E_DeltaMP2C*1000.0, \
        E_DeltaMP2C*627.509);   
    fprintf(outfile, "  ------------------------------------------------------------------------------\n");       
    fflush(outfile); 
 
    return E_DeltaMP2C; 
}

shared_ptr<Matrix> SAPT_DFT::XC(shared_ptr<Matrix> X0,
                                shared_ptr<Matrix> W,
                                shared_ptr<Matrix> S,
                                shared_ptr<Matrix> Sinv)
{
    int N = X0->rowspi()[0];
    shared_ptr<Matrix> XC(new Matrix("XC",N,N));



    return XC;
}

shared_ptr<Matrix> SAPT_DFT::W(shared_ptr<BasisSet> aux,
                               shared_ptr<Matrix> J,
                               shared_ptr<Matrix> Jinv,
                               shared_ptr<Matrix> S,
                               shared_ptr<Matrix> D)
{
    int N = aux->nbf();
    int maxN = aux->max_function_per_shell();
    shared_ptr<Matrix> W(new Matrix("W",N,N));

    // Form the density coefficients
    shared_ptr<Vector> d (new Vector("d_Q", N));
    shared_ptr<Matrix> Qmn (new Matrix("(Q|mn)", maxN, nso_*(ULI)nso_));
    double** Qmnp = Qmn->pointer();
    double* dp = d->pointer(); 
    double** Dp = D->pointer();

    shared_ptr<IntegralFactory> fact(new IntegralFactory(aux,zero_,basisset_,basisset_));
    shared_ptr<TwoBodyAOInt> eri (fact->eri());
    const double* buffer = eri->buffer();

    for (int P = 0; P < aux->nshell(); P++) {
        int nP = aux->shell(P)->nfunction();
        int sP = aux->shell(P)->function_index();
        for (int M = 0; M < basisset_->nshell(); M++) {
            int nM = basisset_->shell(M)->nfunction();
            int sM = basisset_->shell(M)->function_index();
        } 

    }

    d.reset();
    Qmn.reset();
    fact.reset();
    eri.reset();
    
    
    return W;
} 

void SAPT_DFT::form_quadrature()
{
    quad_ = shared_ptr<Quadrature>(new ChebyshevIIQuadrature(options_.get_int("OMEGA_POINTS"),
        options_.get_double("OMEGA_CENTER"))); 

    if (debug_) {
        quad_->print();
    }
}

void SAPT_DFT::form_J()
{
    if (debug_) {
        int naux = ribasis_->nbf();
        shared_ptr<Matrix> J_test (new Matrix("J_test",naux,naux));
        double** Jp = J_test->pointer();

        shared_ptr<IntegralFactory> fact(new IntegralFactory(ribasis_,zero_,ribasis_,zero_));
        shared_ptr<TwoBodyAOInt> Qint(fact->eri());
        const double* buffer = Qint->buffer();
        
        for (int A = 0; A < ribasis_->nshell(); A++) {
            for (int B = 0; B <= A; B++) {
                int nA = ribasis_->shell(A)->nfunction();
                int nB = ribasis_->shell(B)->nfunction();
                int sA = ribasis_->shell(A)->function_index();
                int sB = ribasis_->shell(B)->function_index();
                Qint->compute_shell(A,0,B,0);
                for (int a = 0, index = 0; a < nA; a++) {
                    int oa = sA + a;
                    for (int b = 0; b < nB; b++, index++) {
                        int ob = sB + b;
                        Jp[oa][ob] = buffer[index];
                        Jp[ob][oa] = buffer[index];
                    }
                }
            }
        }
        Qint.reset();   
        fact.reset();
 
        if (debug_) {
            J_test->print();
        }
    }

    int NA = aux_A_->nbf();
    int NB = aux_B_->nbf();
    
    // ==> J_AB <== //
    J_AB_ = shared_ptr<Matrix> (new Matrix("J_AB",NA,NB));
    double** J_ABp = J_AB_->pointer();

    shared_ptr<IntegralFactory> ABfact(new IntegralFactory(aux_A_,zero_,aux_B_,zero_));
    shared_ptr<TwoBodyAOInt> ABint(ABfact->eri());
    const double* buffer = ABint->buffer();
    
    for (int A = 0; A < aux_A_->nshell(); A++) {
        for (int B = 0; B < aux_B_->nshell(); B++) {
            int nA = aux_A_->shell(A)->nfunction();
            int nB = aux_B_->shell(B)->nfunction();
            int sA = aux_A_->shell(A)->function_index();
            int sB = aux_B_->shell(B)->function_index();
            ABint->compute_shell(A,0,B,0);
            for (int a = 0, index = 0; a < nA; a++) {
                int oa = sA + a;
                for (int b = 0; b < nB; b++, index++) {
                    int ob = sB + b;
                    J_ABp[oa][ob] = buffer[index];
                }
            }
        }
    }
    ABint.reset();   
    ABfact.reset();
 
    if (debug_) {
        J_AB_->print();
    }

    // ==> J_A <== //
    J_A_inv_ = shared_ptr<Matrix> (new Matrix("J_A",NA,NA));
    double** J_Ap = J_A_inv_->pointer();

    shared_ptr<IntegralFactory> Afact(new IntegralFactory(aux_A_,zero_,aux_A_,zero_));
    shared_ptr<TwoBodyAOInt> Aint(Afact->eri());
    buffer = Aint->buffer();
    
    for (int A = 0; A < aux_A_->nshell(); A++) {
        for (int B = 0; B <= A; B++) {
            int nA = aux_A_->shell(A)->nfunction();
            int nB = aux_A_->shell(B)->nfunction();
            int sA = aux_A_->shell(A)->function_index();
            int sB = aux_A_->shell(B)->function_index();
            Aint->compute_shell(A,0,B,0);
            for (int a = 0, index = 0; a < nA; a++) {
                int oa = sA + a;
                for (int b = 0; b < nB; b++, index++) {
                    int ob = sB + b;
                    J_Ap[oa][ob] = buffer[index];
                    J_Ap[ob][oa] = buffer[index];
                }
            }
        }
    }
    Aint.reset();   
    Afact.reset();
 
    // ==> J_B <== //
    J_B_inv_ = shared_ptr<Matrix> (new Matrix("J_B",NB,NB));
    double** J_Bp = J_B_inv_->pointer();

    shared_ptr<IntegralFactory> Bfact(new IntegralFactory(aux_B_,zero_,aux_B_,zero_));
    shared_ptr<TwoBodyAOInt> Bint(Bfact->eri());
    buffer = Bint->buffer();
    
    for (int A = 0; A < aux_B_->nshell(); A++) {
        for (int B = 0; B <= A; B++) {
            int nA = aux_B_->shell(A)->nfunction();
            int nB = aux_B_->shell(B)->nfunction();
            int sA = aux_B_->shell(A)->function_index();
            int sB = aux_B_->shell(B)->function_index();
            Bint->compute_shell(A,0,B,0);
            for (int a = 0, index = 0; a < nA; a++) {
                int oa = sA + a;
                for (int b = 0; b < nB; b++, index++) {
                    int ob = sB + b;
                    J_Bp[oa][ob] = buffer[index];
                    J_Bp[ob][oa] = buffer[index];
                }
            }
        }
    }
    Bint.reset();   
    Bfact.reset();
 
    // ==> Pseudoinvert J_A and J_B <== //
    J_A_ = shared_ptr<Matrix> (new Matrix("J_A",NA,NA));
    J_B_ = shared_ptr<Matrix> (new Matrix("J_B",NB,NB));
    J_A_->copy(J_A_inv_);
    J_B_->copy(J_B_inv_);

    J_A_inv_->power(-1.0,1.0E-12);
    J_B_inv_->power(-1.0,1.0E-12);
    J_A_inv_->set_name("J_A^-1");
    J_B_inv_->set_name("J_B^-1");

    if (debug_) {
        J_A_->print();
        J_B_->print();
        J_A_inv_->print();
        J_B_inv_->print();
    }
    
}

void SAPT_DFT::form_S()
{
    int NA = aux_A_->nbf();
    int NB = aux_B_->nbf();
    
    // ==> S_A <== //
    S_A_ = shared_ptr<Matrix> (new Matrix("S_A",NA,NA));

    shared_ptr<IntegralFactory> Afact(new IntegralFactory(aux_A_,aux_A_,zero_,zero_));
    shared_ptr<OneBodyAOInt> Aint(Afact->ao_overlap());

    Aint->compute(S_A_);
    
    Afact.reset();
    Aint.reset();    

    if (debug_) {
        S_A_->print();
    }   
   
    // ==> S_B <== //
    S_B_ = shared_ptr<Matrix> (new Matrix("S_B",NB,NB));

    shared_ptr<IntegralFactory> Bfact(new IntegralFactory(aux_B_,aux_B_,zero_,zero_));
    shared_ptr<OneBodyAOInt> Bint(Bfact->ao_overlap());

    Bint->compute(S_B_);
    
    if (debug_) {
        S_B_->print();
    }   

    Bfact.reset();
    Bint.reset();

    S_A_inv_ = shared_ptr<Matrix> (new Matrix("S_A^-1",NA,NA)); 
    S_B_inv_ = shared_ptr<Matrix> (new Matrix("S_B^-1",NB,NB));

    S_A_inv_->copy(S_A_);
    S_B_inv_->copy(S_B_);

    S_A_inv_->power(-1.0,1.0E-12); 
    S_B_inv_->power(-1.0,1.0E-12);

    if (debug_) {
        S_A_inv_->print();
        S_B_inv_->print();
    } 
}

void SAPT_DFT::form_D()
{
    D_A_ = shared_ptr<Matrix>(new Matrix("D_A",nso_,nso_));
    D_B_ = shared_ptr<Matrix>(new Matrix("D_B",nso_,nso_));

    double** D_Ap = D_A_->pointer();
    double** D_Bp = D_B_->pointer();

    C_DGEMM('N','T',nso_,nso_,noccA_, 1.0, CA_[0], nmo_, CA_[0], nmo_, 0.0, D_Ap[0], nso_);
    C_DGEMM('N','T',nso_,nso_,noccB_, 1.0, CB_[0], nmo_, CB_[0], nmo_, 0.0, D_Bp[0], nso_);

    if (debug_) {
        D_A_->print();
        D_B_->print();
    }
}

void SAPT_DFT::form_W()
{
    W_A_ = W(aux_A_, J_A_, J_A_inv_, S_A_, S_A_inv_);
    W_B_ = W(aux_B_, J_B_, J_B_inv_, S_B_, S_B_inv_);
}

void SAPT_DFT::form_bases()
{
    // Can only handle dimers at the moment
    std::vector<int> zero;
    std::vector<int> one;
    std::vector<int> none;
    zero.push_back(0); 
    one.push_back(1); 

    shared_ptr<Molecule> molA = molecule_->extract_subsets(zero,none);
    shared_ptr<Molecule> molB = molecule_->extract_subsets(none,one);

    shared_ptr<BasisSetParser> parser(new Gaussian94BasisSetParser());
    
    // If the user doesn't spec a basis name, pick it yourself
    // TODO: Verify that the basis assign does not messs this up
    if (options_.get_str("RI_BASIS_SAPT") == "") {
        molA->set_basis_all_atoms(options_.get_str("BASIS") + "-RI", "RI_BASIS_SAPT");
        molB->set_basis_all_atoms(options_.get_str("BASIS") + "-RI", "RI_BASIS_SAPT");
    }

    aux_A_ = shared_ptr<BasisSet>(BasisSet::construct(parser, molA, 
      "RI_BASIS_SAPT"));
    aux_B_ = shared_ptr<BasisSet>(BasisSet::construct(parser, molB, 
      "RI_BASIS_SAPT"));

    aux_A_ = ribasis_;
    aux_B_ = ribasis_;

    if (debug_) {
        molA->print();
        molB->print();
        aux_A_->print_by_level(outfile,3);
        aux_B_->print_by_level(outfile,3);
    }

    parser.reset();
}

void SAPT_DFT::form_X0()
{
    int NA = aux_A_->nbf(); 
    int NB = aux_B_->nbf(); 

    std::vector<double> omega;
    std::vector<double> weight;

    for (quad_->reset(); !quad_->isDone(); quad_->nextPoint()) {
        omega.push_back(quad_->getPoint());
        weight.push_back(quad_->getWeight());
    }

    // ==> X0_A <== //
    int maxA = aux_A_->max_function_per_shell();
    shared_ptr<Matrix> QiaA (new Matrix("(Q|ia) A", NA, noccA_ * (ULI) nvirA_)); 
    shared_ptr<Matrix> QmnA (new Matrix("(Q|mn) A", maxA, nso_ * (ULI) nso_));
    shared_ptr<Matrix> QmiA (new Matrix("(Q|mi) A", maxA, noccA_ * (ULI) nso_));
    double** QiaAp = QiaA->pointer();
    double** QmnAp = QmnA->pointer();
    double** QmiAp = QmiA->pointer();
    
    shared_ptr<IntegralFactory> Afact(new IntegralFactory(aux_A_, zero_, basisset_, basisset_));
    shared_ptr<TwoBodyAOInt> Aeri (Afact->eri());
    const double* Abuffer = Aeri->buffer();

    for (int Q = 0; Q < aux_A_->nshell(); Q++) {
        int nQ = aux_A_->shell(Q)->nfunction();
        int sQ = aux_A_->shell(Q)->function_index();

        // ==> Integrals <== //
        for (int M = 0; M < basisset_->nshell(); M++) {
            int nM = basisset_->shell(M)->nfunction();
            int sM = basisset_->shell(M)->function_index();
            for (int N = 0; N <= M; N++) {
                int nN = basisset_->shell(N)->nfunction();
                int sN = basisset_->shell(N)->function_index();
                Aeri->compute_shell(Q,0,M,N);
                for (int dQ = 0, index = 0; dQ < nQ; dQ++) {
                    int oQ = sQ + dQ;
                    for (int dM = 0; dM < nM; dM++) {
                        int oM = sM + dM;
                        for (int dN = 0; dN < nN; dN++, index++) {
                            int oN = sN + dN;
                            QmnAp[dQ][oM*nso_ + oN] = Abuffer[index];
                            QmnAp[dQ][oN*nso_ + oM] = Abuffer[index];
                        }
                    }
                }
            } 
        } 

        if (debug_) {
            QmnA->print();
        }
    
        // First Half-transform
        C_DGEMM('N','N',nQ*(ULI)nso_,noccA_,nso_,1.0,QmnAp[0],nso_,CA_[0],nmo_,0.0,QmiAp[0],noccA_); 

        // Second Half-transform
        for (int dQ = 0; dQ < nQ; dQ++) {
            int oQ = sQ + dQ;
            C_DGEMM('T','N',noccA_,nvirA_,nso_,1.0,QmiAp[dQ],noccA_,&CA_[0][noccA_],nmo_,0.0,QiaAp[oQ],nvirA_); 
        }        
    }

    Afact.reset(); 
    Aeri.reset();

    if (debug_) {
        QiaA->print();
    }

    // ==> Lambda <== //
    shared_ptr<Matrix> LiaA (new Matrix("Lia A", omega.size(), noccA_*(ULI)nvirA_));
    double** LiaAp = LiaA->pointer();
    for (int om = 0; om < omega.size(); om++) {
        double OM = omega[om];
        for (int i = 0; i < noccA_; i++) {
            for (int a = 0; a < nvirA_; a++) {
                double eps_ia = evalsA_[a + noccA_] - evalsA_[i];
                LiaAp[om][i * nvirA_ + a] = sqrt(4.0 * eps_ia / (eps_ia * eps_ia + OM * OM)); 
            }
        }
    }

    if (debug_) {
        LiaA->print();
    }

    // ==> X0 <== //
    for (int om = 0; om < omega.size(); om++) {
        shared_ptr<Matrix> XA (new Matrix("XA", NA, NA));

        if (om == 0) {
            for (ULI ia = 0; ia < noccA_*(ULI)nvirA_; ia++) {
                C_DSCAL(NA,LiaAp[om][ia],&QiaAp[0][ia],noccA_*(ULI)nvirA_);
            }
        } else {
            for (ULI ia = 0; ia < noccA_*(ULI)nvirA_; ia++) {
                C_DSCAL(NA,LiaAp[om][ia]/LiaAp[om - 1][ia],&QiaAp[0][ia],noccA_*(ULI)nvirA_);
            }
        }

        XA->gemm(false,true,1.0,QiaA,QiaA,0.0);

        X0_A_.push_back(XA);
    }

    QiaA.reset();
    LiaA.reset();

    // ==> X0_B <== //
    int maxB = aux_B_->max_function_per_shell();
    shared_ptr<Matrix> QiaB (new Matrix("(Q|ia) B", NB, noccB_ * (ULI) nvirB_)); 
    shared_ptr<Matrix> QmnB (new Matrix("(Q|mn) B", maxB, nso_ * (ULI) nso_));
    shared_ptr<Matrix> QmiB (new Matrix("(Q|mi) B", maxB, noccB_ * (ULI) nso_));
    double** QiaBp = QiaB->pointer();
    double** QmnBp = QmnB->pointer();
    double** QmiBp = QmiB->pointer();
    
    shared_ptr<IntegralFactory> Bfact(new IntegralFactory(aux_B_, zero_, basisset_, basisset_));
    shared_ptr<TwoBodyAOInt> Beri (Bfact->eri());
    const double* Bbuffer = Beri->buffer();

    for (int Q = 0; Q < aux_B_->nshell(); Q++) {
        int nQ = aux_B_->shell(Q)->nfunction();
        int sQ = aux_B_->shell(Q)->function_index();

        // ==> Integrals <== //
        for (int M = 0; M < basisset_->nshell(); M++) {
            int nM = basisset_->shell(M)->nfunction();
            int sM = basisset_->shell(M)->function_index();
            for (int N = 0; N <= M; N++) {
                int nN = basisset_->shell(N)->nfunction();
                int sN = basisset_->shell(N)->function_index();
                Beri->compute_shell(Q,0,M,N);
                for (int dQ = 0, index = 0; dQ < nQ; dQ++) {
                    int oQ = sQ + dQ;
                    for (int dM = 0; dM < nM; dM++) {
                        int oM = sM + dM;
                        for (int dN = 0; dN < nN; dN++, index++) {
                            int oN = sN + dN;
                            QmnBp[dQ][oM*nso_ + oN] = Bbuffer[index];
                            QmnBp[dQ][oN*nso_ + oM] = Bbuffer[index];
                        }
                    }
                }
            } 
        } 
   
        if (debug_) {
            QmnB->print();
        }

        // First Half-transform
        C_DGEMM('N','N',nQ*(ULI)nso_,noccB_,nso_,1.0,QmnBp[0],nso_,CB_[0],nmo_,0.0,QmiBp[0],noccB_); 

        // Second Half-transform
        for (int dQ = 0; dQ < nQ; dQ++) {
            int oQ = sQ + dQ;
            C_DGEMM('T','N',noccB_,nvirB_,nso_,1.0,QmiBp[dQ],noccB_,&CB_[0][noccB_],nmo_,0.0,QiaBp[oQ],nvirB_); 
        }        
    }

    Bfact.reset(); 
    Beri.reset();

    if (debug_) {
        QiaB->print();
    }

    // ==> Lambda <== //
    shared_ptr<Matrix> LiaB (new Matrix("Lia B", omega.size(), noccB_*(ULI)nvirB_));
    double** LiaBp = LiaB->pointer();
    for (int om = 0; om < omega.size(); om++) {
        double OM = omega[om];
        for (int i = 0; i < noccB_; i++) {
            for (int a = 0; a < nvirB_; a++) {
                double eps_ia = evalsB_[a + noccB_] - evalsB_[i];
                LiaBp[om][i * nvirB_ + a] = sqrt(4.0 * eps_ia / (eps_ia * eps_ia + OM * OM)); 
            }
        }
    }

    if (debug_) {
        LiaB->print();
    }

    // ==> X0 <== //
    for (int om = 0; om < omega.size(); om++) {
        shared_ptr<Matrix> XB (new Matrix("XB", NB, NB));

        if (om == 0) {
            for (ULI ia = 0; ia < noccB_*(ULI)nvirB_; ia++) {
                C_DSCAL(NB,LiaBp[om][ia],&QiaBp[0][ia],noccB_*(ULI)nvirB_);
            }
        } else {
            for (ULI ia = 0; ia < noccB_*(ULI)nvirB_; ia++) {
                C_DSCAL(NB,LiaBp[om][ia]/LiaBp[om - 1][ia],&QiaBp[0][ia],noccB_*(ULI)nvirB_);
            }
        }

        XB->gemm(false,true,1.0,QiaB,QiaB,0.0);

        X0_B_.push_back(XB);
    }

    QiaB.reset();
    LiaB.reset();
}

void SAPT_DFT::form_XC()
{
    for (int k = 0; k < X0_A_.size(); k++) {
        XC_A_.push_back(XC(X0_A_[k], W_A_, J_A_, J_A_inv_));
        XC_B_.push_back(XC(X0_B_[k], W_B_, J_B_, J_B_inv_));
    }
}

std::vector<double> SAPT_DFT::casimirPolder(std::vector<shared_ptr<Matrix> > XA, std::vector<shared_ptr<Matrix> > XB)
{
    int NA = aux_A_->nbf(); 
    int NB = aux_B_->nbf(); 

    int nquad = XA.size();
    std::vector<double> weight;
    for (quad_->reset(); !quad_->isDone(); quad_->nextPoint()) {
        weight.push_back(quad_->getWeight());
    }
    
    std::vector<double> E;
    E.resize(nquad);

    for (int om = 0; om < nquad; om++) {

        shared_ptr<Matrix> T1A (new Matrix("T1A", NA, NA));
        shared_ptr<Matrix> T2A (new Matrix("T2A", NA, NA));
        shared_ptr<Matrix> T3A (new Matrix("T3A", NA, NB));
        T1A->gemm(false,false,1.0,XA[om],J_A_inv_,0.0); 
        T2A->gemm(false,false,1.0,J_A_inv_,T1A,0.0); 
        T3A->gemm(false,false,1.0,T2A,J_AB_,0.0);

        shared_ptr<Matrix> T1B (new Matrix("T1B", NB, NB));
        shared_ptr<Matrix> T2B (new Matrix("T2B", NB, NB));
        shared_ptr<Matrix> T3B (new Matrix("T3B", NA, NB));
        T1B->gemm(false,false,1.0,XB[om],J_B_inv_,0.0); 
        T2B->gemm(false,false,1.0,J_B_inv_,T1B,0.0); 
        T3B->gemm(false,false,1.0,J_AB_,T2B,0.0);

        // Vector dot
        E[om] = T3A->vector_dot(T3B);    

        // Fun factor of 1/(2\pi) * weight
        E[om] *= -1.0 / (2.0 * M_PI) * weight[om];
    }

    return E;
}

void SAPT_DFT::print_header()
{
  fprintf(outfile,"        SAPT-DFT  \n");
  fprintf(outfile,"      Ed Hohenstein\n"); 
  fprintf(outfile,"       Rob Parish\n") ;
  fprintf(outfile,"     13 April 2011\n") ;
  fprintf(outfile,"\n");
  fprintf(outfile,"    Orbital Information\n");
  fprintf(outfile,"  -----------------------\n");
  fprintf(outfile,"    NSO     = %9d\n",nso_);
  fprintf(outfile,"    NMO     = %9d\n",nmo_);
  fprintf(outfile,"    NRI     = %9d\n",ndf_);
  fprintf(outfile,"    NOCC A  = %9d\n",noccA_);
  fprintf(outfile,"    NOCC B  = %9d\n",noccB_);
  fprintf(outfile,"    FOCC A  = %9d\n",foccA_);
  fprintf(outfile,"    FOCC B  = %9d\n",foccB_);
  fprintf(outfile,"    NVIR A  = %9d\n",nvirA_);
  fprintf(outfile,"    NVIR B  = %9d\n",nvirB_);
  fprintf(outfile,"\n");
  fflush(outfile);
}

void SAPT_DFT::print_results()
{
}


}}
