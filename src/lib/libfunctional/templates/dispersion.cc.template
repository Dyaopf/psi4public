/**********************************************************
* dispersion.cc: definitions for -D for KS-DFT
* Robert Parrish, robparrish@gmail.com
* 09/01/2010
*
***********************************************************/

#include <libmints/molecule.h>
#include <libciomr/libciomr.h>
#include "dispersion.h"
#include "dispersion_defines.h"
#include <boost/algorithm/string.hpp>
#include <stdlib.h>
#include <string>
#include <vector>

using namespace psi;
using namespace boost;
using namespace std;

namespace psi { namespace functional {


Dispersion::Dispersion() 
{
}
Dispersion::~Dispersion()
{
}
boost::shared_ptr<Dispersion> Dispersion::createDispersion(const std::string & name, double s6)
{
    if (boost::to_upper_copy(name) == "") {
        boost::shared_ptr<Dispersion> disp;
        return disp;
    } else if (boost::to_upper_copy(name) == "-D1") {
        return shared_ptr<Dispersion> (new D1(s6));
    } else if (boost::to_upper_copy(name) == "-D2") {
        return shared_ptr<Dispersion> (new D2(s6));
    }
}
D1::D1(double s6) : Dispersion() 
{
    name_ = "-D1";
    description_ = "Grimme's -D1 Dispersion Correction";
    citation_ = "Grimme, S. (2004), J. Comp. Chem., 25: 1463-1473"; 

    d_ = 23.0; 
    RvdW_ = RvdW_D1_;
    C6_ = C6_D1_;
    s6_ = s6;
}
D1::~D1() 
{
}
double D1::computeEnergy(shared_ptr<Molecule> mol)
{
    double energy = 0.0;

    // Build Z, x, y, and z
    int natom = 0;

    int *Z = init_int_array(mol->natom());
    double *x = init_array(mol->natom());
    double *y = init_array(mol->natom());
    double *z = init_array(mol->natom());

    for (int i = 0; i < mol->natom(); i++) {
        if (mol->Z(i) == 0)
        continue;
        Z[natom] = mol->Z(i);
        x[natom] = mol->x(i);
        y[natom] = mol->y(i);
        z[natom] = mol->z(i);
        natom ++;
    }

    // Build C6 (C6_ij = C6_i*C6_j/(C6_i+C6_j) in -D1 )
    double **C6 = block_matrix(natom, natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            C6[i][j] = 2.0 * C6_[Z[i]] * C6_[Z[j]] / (C6_[Z[i]] + C6_[Z[j]]);
        }
    }

    // Build RvdW (sum of vdW radii)
    double **RvdW = block_matrix(natom, natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            RvdW[i][j] = RvdW_[Z[i]] + RvdW_[Z[j]];
        }
    }

    // Build r
    double **r = block_matrix(natom,natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            r[i][j] = sqrt((x[i]-x[j])*(x[i]-x[j]) + \
                           (y[i]-y[j])*(y[i]-y[j]) + \
                           (z[i]-z[j])*(z[i]-z[j]));
        }
    } 

    // Compute energy
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            ED1
        }
    }

    // Scale energy by s6_
    energy *= s6_;

    // Dispersion energy is always stabilizing
    energy *= -1.0;

    // Free stuff
    free_block(C6);
    free_block(RvdW);
    free_block(r);
    delete []Z;
    delete []x;
    delete []y;
    delete []z;

    return energy;
}
double* D1::computeGradient(shared_ptr<Molecule> mol)
{
    // Build Z, x, y, and z
    int natom = 0;

    int *Z = init_int_array(mol->natom());
    double *x = init_array(mol->natom());
    double *y = init_array(mol->natom());
    double *z = init_array(mol->natom());

    for (int i = 0; i < mol->natom(); i++) {
        if (mol->Z(i) == 0)
        continue;
        Z[natom] = mol->Z(i);
        x[natom] = mol->x(i);
        y[natom] = mol->y(i);
        z[natom] = mol->z(i);
        natom ++;
    }

    // gradient array in [x1 y1 z1 x2 y2 z2 ... ]
    double* grad = init_array(3*natom);
    
    // Build C6 (C6_ij = C6_i*C6_j/(C6_i+C6_j) in -D1 )
    double **C6 = block_matrix(natom, natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            C6[i][j] = 2.0 * C6_[Z[i]] * C6_[Z[j]] / (C6_[Z[i]] + C6_[Z[j]]);
        }
    }

    // Build RvdW (sum of vdW radii)
    double **RvdW = block_matrix(natom, natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            RvdW[i][j] = RvdW_[Z[i]] + RvdW_[Z[j]];
        }
    }

    // Build r
    double **r = block_matrix(natom,natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            r[i][j] = sqrt((x[i]-x[j])*(x[i]-x[j]) + \
                           (y[i]-y[j])*(y[i]-y[j]) + \
                           (z[i]-z[j])*(z[i]-z[j]));
        }
    } 

    // Compute gradient by perturbing nucleus i
    int Ax, Ay, Az;
    double f;
    for (int i = 0; i < natom; i++) {
        Ax = 3*i;
        Ay = 3*i + 1;
        Az = 3*i + 2;

        for (int j = 0; j < natom; j++) {
            if (i == j)
                continue;

            ED1_x
            ED1_y
            ED1_z
        }
    }

    // Scale gradient by -s6_
    // Dispersion energy is always stabilizing
    for (int A = 0; A < 3*natom; A++) {
        grad[A] *= -s6_;
    }

    // Free stuff
    free_block(C6);
    free_block(RvdW);
    free_block(r);
    delete []Z;
    delete []x;
    delete []y;
    delete []z;
    return grad;
}
double** D1::computeHessian(shared_ptr<Molecule> mol)
{
    // Build Z, x, y, and z
    int natom = 0;

    int *Z = init_int_array(mol->natom());
    double *x = init_array(mol->natom());
    double *y = init_array(mol->natom());
    double *z = init_array(mol->natom());

    for (int i = 0; i < mol->natom(); i++) {
        if (mol->Z(i) == 0)
        continue;
        Z[natom] = mol->Z(i);
        x[natom] = mol->x(i);
        y[natom] = mol->y(i);
        z[natom] = mol->z(i);
        natom ++;
    }

    // gradient array in [x1 y1 z1 x2 y2 z2 ... ]
    double** hess = block_matrix(3*natom,3*natom);
    
    // Build C6 (C6_ij = C6_i*C6_j/(C6_i+C6_j) in -D1 )
    double **C6 = block_matrix(natom, natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            C6[i][j] = 2.0 * C6_[Z[i]] * C6_[Z[j]] / (C6_[Z[i]] + C6_[Z[j]]);
        }
    }

    // Build RvdW (sum of vdW radii)
    double **RvdW = block_matrix(natom, natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            RvdW[i][j] = RvdW_[Z[i]] + RvdW_[Z[j]];
        }
    }

    // Build r
    double **r = block_matrix(natom,natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            r[i][j] = sqrt((x[i]-x[j])*(x[i]-x[j]) + \
                           (y[i]-y[j])*(y[i]-y[j]) + \
                           (z[i]-z[j])*(z[i]-z[j]));
        }
    } 

    int Ax, Ay, Az, Bx, By, Bz;
    double f;

    // Case 1: A A
    for (int i = 0; i < natom; i++) {
        Ax = 3*i;
        Ay = 3*i + 1;
        Az = 3*i + 2;

        for (int j = 0; j < natom; j++) {
            if (i == j) 
                continue;

            ED1_xA_xA
            ED1_xA_yA
            ED1_xA_zA
            ED1_yA_yA
            ED1_yA_zA
            ED1_zA_zA

        }
    }
    // Case 2: A B
    for (int i = 0; i < natom; i++) {
        Ax = 3*i;
        Ay = 3*i + 1;
        Az = 3*i + 2;

        for (int j = 0; j < natom; j++) {
            if (i == j) 
                continue;

            Bx = 3*i;
            By = 3*i + 1;
            Bz = 3*i + 2;
            
            ED1_xA_xB
            ED1_xA_yB
            ED1_xA_zB
            ED1_yA_yB
            ED1_yA_zB
            ED1_zA_zB

        }
    }

    // Scale gradient by -s6_
    // Dispersion energy is always stabilizing
    for (int A = 0; A < 3*natom; A++) {
        for (int B = 0; B < 3*natom; B++) {
            hess[A][B] *= -s6_;
        }
    }

    // Free stuff
    free_block(C6);
    free_block(RvdW);
    free_block(r);
    delete []Z;
    delete []x;
    delete []y;
    delete []z;
    return hess;
}
D2::D2(double s6) : Dispersion() 
{
    name_ = "-D2";
    description_ = "Grimme's -D2 Dispersion Correction";
    citation_ = "Grimme, S. (2006),  J. Comp. Chem., 27: 1787-1799";
    
    d_ = 20.0; 
    RvdW_ = RvdW_D2_;
    C6_ = C6_D2_;
    s6_ = s6;
}
D2::~D2() 
{
}
double D2::computeEnergy(shared_ptr<Molecule> mol)
{
    double energy = 0.0;

    // Build Z, x, y, and z
    int natom = 0;

    int *Z = init_int_array(mol->natom());
    double *x = init_array(mol->natom());
    double *y = init_array(mol->natom());
    double *z = init_array(mol->natom());

    for (int i = 0; i < mol->natom(); i++) {
        if (mol->Z(i) == 0)
        continue;
        Z[natom] = mol->Z(i);
        x[natom] = mol->x(i);
        y[natom] = mol->y(i);
        z[natom] = mol->z(i);
        natom ++;
    }

    // Build C6 (C6_ij = sqrt(C6_i*C6_j) in -D2) 
    double **C6 = block_matrix(natom, natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            C6[i][j] = sqrt( C6_[Z[i]] * C6_[Z[j]] );
        }
    }

    // Build RvdW (sum of vdW radii)
    double **RvdW = block_matrix(natom, natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            RvdW[i][j] = RvdW_[Z[i]] + RvdW_[Z[j]];
        }
    }

    // Build r
    double **r = block_matrix(natom,natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            r[i][j] = sqrt((x[i]-x[j])*(x[i]-x[j]) + \
                           (y[i]-y[j])*(y[i]-y[j]) + \
                           (z[i]-z[j])*(z[i]-z[j]));
        }
    } 

    // Compute energy
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            ED2
        }
    }

    // Scale energy by s6_
    energy *= s6_;

    // Dispersion energy is always stabilizing
    energy *= -1.0;

    // Free stuff
    free_block(C6);
    free_block(RvdW);
    free_block(r);
    delete []Z;
    delete []x;
    delete []y;
    delete []z;

    return energy;
}
double* D2::computeGradient(shared_ptr<Molecule> mol)
{
    // Build Z, x, y, and z
    int natom = 0;

    int *Z = init_int_array(mol->natom());
    double *x = init_array(mol->natom());
    double *y = init_array(mol->natom());
    double *z = init_array(mol->natom());

    for (int i = 0; i < mol->natom(); i++) {
        if (mol->Z(i) == 0)
        continue;
        Z[natom] = mol->Z(i);
        x[natom] = mol->x(i);
        y[natom] = mol->y(i);
        z[natom] = mol->z(i);
        natom ++;
    }

    // gradient array in [x1 y1 z1 x2 y2 z2 ... ]
    double* grad = init_array(3*natom);
    
    // Build C6 (C6_ij = C6_i*C6_j/(C6_i+C6_j) in -D1 )
    double **C6 = block_matrix(natom, natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            C6[i][j] = sqrt( C6_[Z[i]] * C6_[Z[j]] );
        }
    }

    // Build RvdW (sum of vdW radii)
    double **RvdW = block_matrix(natom, natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            RvdW[i][j] = RvdW_[Z[i]] + RvdW_[Z[j]];
        }
    }

    // Build r
    double **r = block_matrix(natom,natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            r[i][j] = sqrt((x[i]-x[j])*(x[i]-x[j]) + \
                           (y[i]-y[j])*(y[i]-y[j]) + \
                           (z[i]-z[j])*(z[i]-z[j]));
        }
    } 

    // Compute gradient by perturbing nucleus i
    int Ax, Ay, Az;
    double f;
    for (int i = 0; i < natom; i++) {
        Ax = 3*i;
        Ay = 3*i + 1;
        Az = 3*i + 2;

        for (int j = 0; j < natom; j++) {
            if (i == j)
                continue;

            ED2_x
            ED2_y
            ED2_z
        }
    }

    // Scale gradient by -s6_
    // Dispersion energy is always stabilizing
    for (int A = 0; A < 3*natom; A++) {
        grad[A] *= -s6_;
    }

    // Free stuff
    free_block(C6);
    free_block(RvdW);
    free_block(r);
    delete []Z;
    delete []x;
    delete []y;
    delete []z;
    return grad;
}
double** D2::computeHessian(shared_ptr<Molecule> mol)
{
    // Build Z, x, y, and z
    int natom = 0;

    int *Z = init_int_array(mol->natom());
    double *x = init_array(mol->natom());
    double *y = init_array(mol->natom());
    double *z = init_array(mol->natom());

    for (int i = 0; i < mol->natom(); i++) {
        if (mol->Z(i) == 0)
        continue;
        Z[natom] = mol->Z(i);
        x[natom] = mol->x(i);
        y[natom] = mol->y(i);
        z[natom] = mol->z(i);
        natom ++;
    }

    // gradient array in [x1 y1 z1 x2 y2 z2 ... ]
    double** hess = block_matrix(3*natom,3*natom);
    
    // Build C6 (C6_ij = C6_i*C6_j/(C6_i+C6_j) in -D1 )
    double **C6 = block_matrix(natom, natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            C6[i][j] = sqrt( C6_[Z[i]] * C6_[Z[j]] );
        }
    }

    // Build RvdW (sum of vdW radii)
    double **RvdW = block_matrix(natom, natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            RvdW[i][j] = RvdW_[Z[i]] + RvdW_[Z[j]];
        }
    }

    // Build r
    double **r = block_matrix(natom,natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            r[i][j] = sqrt((x[i]-x[j])*(x[i]-x[j]) + \
                           (y[i]-y[j])*(y[i]-y[j]) + \
                           (z[i]-z[j])*(z[i]-z[j]));
        }
    } 

    int Ax, Ay, Az, Bx, By, Bz;
    double f;

    // Case 1: A A
    for (int i = 0; i < natom; i++) {
        Ax = 3*i;
        Ay = 3*i + 1;
        Az = 3*i + 2;

        for (int j = 0; j < natom; j++) {
            if (i == j) 
                continue;

            ED2_xA_xA
            ED2_xA_yA
            ED2_xA_zA
            ED2_yA_yA
            ED2_yA_zA
            ED2_zA_zA

        }
    }
    // Case 2: A B
    for (int i = 0; i < natom; i++) {
        Ax = 3*i;
        Ay = 3*i + 1;
        Az = 3*i + 2;

        for (int j = 0; j < natom; j++) {
            if (i == j) 
                continue;

            Bx = 3*i;
            By = 3*i + 1;
            Bz = 3*i + 2;
            
            ED2_xA_xB
            ED2_xA_yB
            ED2_xA_zB
            ED2_yA_yB
            ED2_yA_zB
            ED2_zA_zB

        }
    }

    // Scale gradient by -s6_
    // Dispersion energy is always stabilizing
    for (int A = 0; A < 3*natom; A++) {
        for (int B = 0; B < 3*natom; B++) {
            hess[A][B] *= -s6_;
        }
    }

    // Free stuff
    free_block(C6);
    free_block(RvdW);
    free_block(r);
    delete []Z;
    delete []x;
    delete []y;
    delete []z;
    return hess;
}
D3::D3() 
{
    name_ = "-D3";
    description_ = "Grimme's -D3 Dispersion Correction";
    citation_ = "Grimme, S. (2010),  J.C.P., 132: 154104";
}
D3::~D3() 
{
}
double D3::computeEnergy(shared_ptr<Molecule> mol)
{
    double energy = 0.0;
    return energy;
}
double* D3::computeGradient(shared_ptr<Molecule> mol)
{
    double* grad;
    return grad;
}
double** D3::computeHessian(shared_ptr<Molecule> mol)
{
    double** hess;
    return hess;
}

}}
