/**********************************************************
* dispersion.cc: definitions for -D for KS-DFT
* Robert Parrish, robparrish@gmail.com
* 09/01/2010
*
***********************************************************/

#include <libmints/molecule.h>
#include <libciomr/libciomr.h>
#include "dispersion.h"
#include "dispersion_defines.h"
#include <boost/algorithm/string.hpp>
#include <stdlib.h>
#include <string>
#include <vector>

using namespace psi;
using namespace boost;
using namespace std;

namespace psi { namespace functional {


Dispersion::Dispersion() 
{
}
Dispersion::~Dispersion()
{
}
boost::shared_ptr<Dispersion> Dispersion::createDispersion(const std::string & name, double s6)
{
    if (boost::to_upper_copy(name) == "") {
        boost::shared_ptr<Dispersion> disp;
        return disp;
    } else if (boost::to_upper_copy(name) == "-D1") {
        return shared_ptr<Dispersion> (new D1(s6));
    } else if (boost::to_upper_copy(name) == "-D2") {
        return shared_ptr<Dispersion> (new D2(s6));
    }
}
D1::D1(double s6) : Dispersion() 
{
    name_ = "-D1";
    description_ = "Grimme's -D1 Dispersion Correction";
    citation_ = "Grimme, S. (2004), J. Comp. Chem., 25: 1463-1473"; 

    d_ = 23.0; 
    RvdW_ = RvdW_D1_;
    C6_ = C6_D1_;
    s6_ = s6;
}
D1::~D1() 
{
}
double D1::computeEnergy(shared_ptr<Molecule> mol)
{
    double energy = 0.0;

    // Build Z, x, y, and z
    int natom = 0;

    int *Z = init_int_array(mol->natom());
    double *x = init_array(mol->natom());
    double *y = init_array(mol->natom());
    double *z = init_array(mol->natom());

    for (int i = 0; i < mol->natom(); i++) {
        if (mol->Z(i) == 0)
        continue;
        Z[natom] = mol->Z(i);
        x[natom] = mol->x(i);
        y[natom] = mol->y(i);
        z[natom] = mol->z(i);
        natom ++;
    }

    // Build C6 (C6_ij = C6_i*C6_j/(C6_i+C6_j) in -D1 )
    double **C6 = block_matrix(natom, natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            C6[i][j] = 2.0 * C6_[Z[i]] * C6_[Z[j]] / (C6_[Z[i]] + C6_[Z[j]]);
        }
    }

    // Build RvdW (sum of vdW radii)
    double **RvdW = block_matrix(natom, natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            RvdW[i][j] = RvdW_[Z[i]] + RvdW_[Z[j]];
        }
    }

    // Build r
    double **r = block_matrix(natom,natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            r[i][j] = sqrt((x[i]-x[j])*(x[i]-x[j]) + \
                           (y[i]-y[j])*(y[i]-y[j]) + \
                           (z[i]-z[j])*(z[i]-z[j]));
        }
    } 

    // Compute energy
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            energy += C6[i][j]*pow(r[i][j],-6.0) / \
                (1.0 + exp(-d_*(r[i][j]/RvdW[i][j] - 1.0)));
        }
    }

    // Scale energy by s6_
    energy *= s6_;

    // Dispersion energy is always stabilizing
    energy *= -1.0;

    // Free stuff
    free_block(C6);
    free_block(RvdW);
    free_block(r);
    delete []Z;
    delete []x;
    delete []y;
    delete []z;

    return energy;
}
double* D1::computeGradient(shared_ptr<Molecule> mol)
{
    // Build Z, x, y, and z
    int natom = 0;

    int *Z = init_int_array(mol->natom());
    double *x = init_array(mol->natom());
    double *y = init_array(mol->natom());
    double *z = init_array(mol->natom());

    for (int i = 0; i < mol->natom(); i++) {
        if (mol->Z(i) == 0)
        continue;
        Z[natom] = mol->Z(i);
        x[natom] = mol->x(i);
        y[natom] = mol->y(i);
        z[natom] = mol->z(i);
        natom ++;
    }

    // gradient array in [x1 y1 z1 x2 y2 z2 ... ]
    double* grad = init_array(3*natom);
    
    // Build C6 (C6_ij = C6_i*C6_j/(C6_i+C6_j) in -D1 )
    double **C6 = block_matrix(natom, natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            C6[i][j] = 2.0 * C6_[Z[i]] * C6_[Z[j]] / (C6_[Z[i]] + C6_[Z[j]]);
        }
    }

    // Build RvdW (sum of vdW radii)
    double **RvdW = block_matrix(natom, natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            RvdW[i][j] = RvdW_[Z[i]] + RvdW_[Z[j]];
        }
    }

    // Build r
    double **r = block_matrix(natom,natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            r[i][j] = sqrt((x[i]-x[j])*(x[i]-x[j]) + \
                           (y[i]-y[j])*(y[i]-y[j]) + \
                           (z[i]-z[j])*(z[i]-z[j]));
        }
    } 

    // Compute gradient by perturbing nucleus A
    int Ax, Ay, Az;
    double f;
    for (int A = 0; A < natom; A++) {
        Ax = 3*A;
        Ay = 3*A + 1;
        Az = 3*A + 2;

        // Gradient x_i
        for (int j = 0; j < A; j++) {
            f = 1.0/(exp(-d_*(r[A][j]/RvdW[A][j] - 1.0)) + 1.0);
            grad[Ax] += 6.0*C6[A][j]*(x[A] - x[j])*pow(r[A][j],-8.0)*f + \
                C6[A][j]*d_*exp(-d_*(r[A][j]/RvdW[A][j] - 1.0))* \
                (x[A]-x[j])*f*f*pow(r[A][j], -7.0)/(RvdW[A][j]);      
            grad[Ay] += 6.0*C6[A][j]*(y[A] - y[j])*pow(r[A][j],-8.0)*f + \
                C6[A][j]*d_*exp(-d_*(r[A][j]/RvdW[A][j] - 1.0))* \
                (y[A]-y[j])*f*f*pow(r[A][j], -7.0)/(RvdW[A][j]);      
            grad[Az] += 6.0*C6[A][j]*(z[A] - z[j])*pow(r[A][j],-8.0)*f + \
                C6[A][j]*d_*exp(-d_*(r[A][j]/RvdW[A][j] - 1.0))* \
                (z[A]-z[j])*f*f*pow(r[A][j], -7.0)/(RvdW[A][j]);      
        }
        // Gradient x_j
        for (int i = A+1; i < natom; i++) {
            f = 1.0/(exp(-d_*(r[i][A]/RvdW[i][A] - 1.0)) + 1.0);
            grad[Ax] -= 6.0*C6[i][A]*(x[i] - x[A])*pow(r[i][A],-8.0)*f + \
                C6[i][A]*d_*exp(-d_*(r[i][A]/RvdW[i][A] - 1.0))* \
                (x[i]-x[A])*f*f*pow(r[i][A], -7.0)/(RvdW[i][A]);      
            grad[Ay] -= 6.0*C6[i][A]*(y[i] - y[A])*pow(r[i][A],-8.0)*f + \
                C6[i][A]*d_*exp(-d_*(r[i][A]/RvdW[i][A] - 1.0))* \
                (y[i]-y[A])*f*f*pow(r[i][A], -7.0)/(RvdW[i][A]);      
            grad[Az] -= 6.0*C6[i][A]*(z[i] - z[A])*pow(r[i][A],-8.0)*f + \
                C6[i][A]*d_*exp(-d_*(r[i][A]/RvdW[i][A] - 1.0))* \
                (z[i]-z[A])*f*f*pow(r[i][A], -7.0)/(RvdW[i][A]);      
        }
    }

    // Scale gradient by -s6_
    // Dispersion energy is always stabilizing
    for (int A = 0; A < 3*natom; A++) {
        grad[A] *= -s6_;
    }

    // Free stuff
    free_block(C6);
    free_block(RvdW);
    free_block(r);
    delete []Z;
    delete []x;
    delete []y;
    delete []z;
    return grad;
}
double** D1::computeHessian(shared_ptr<Molecule> mol)
{
    // Build Z, x, y, and z
    int natom = 0;

    int *Z = init_int_array(mol->natom());
    double *x = init_array(mol->natom());
    double *y = init_array(mol->natom());
    double *z = init_array(mol->natom());

    for (int i = 0; i < mol->natom(); i++) {
        if (mol->Z(i) == 0)
        continue;
        Z[natom] = mol->Z(i);
        x[natom] = mol->x(i);
        y[natom] = mol->y(i);
        z[natom] = mol->z(i);
        natom ++;
    }

    // gradient array in [x1 y1 z1 x2 y2 z2 ... ]
    double** hess = block_matrix(3*natom,3*natom);
    
    // Build C6 (C6_ij = C6_i*C6_j/(C6_i+C6_j) in -D1 )
    double **C6 = block_matrix(natom, natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            C6[i][j] = 2.0 * C6_[Z[i]] * C6_[Z[j]] / (C6_[Z[i]] + C6_[Z[j]]);
        }
    }

    // Build RvdW (sum of vdW radii)
    double **RvdW = block_matrix(natom, natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            RvdW[i][j] = RvdW_[Z[i]] + RvdW_[Z[j]];
        }
    }

    // Build r
    double **r = block_matrix(natom,natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            r[i][j] = sqrt((x[i]-x[j])*(x[i]-x[j]) + \
                           (y[i]-y[j])*(y[i]-y[j]) + \
                           (z[i]-z[j])*(z[i]-z[j]));
        }
    } 

    // Compute gradient by perturbing nucleus A
    int Ax, Ay, Az;
    double f;
    for (int A = 0; A < natom; A++) {
        Ax = 3*A;
        Ay = 3*A + 1;
        Az = 3*A + 2;

    }

    // Scale gradient by -s6_
    // Dispersion energy is always stabilizing
    for (int A = 0; A < 3*natom; A++) {
        for (int B = 0; B < 3*natom; B++) {
            hess[A][B] *= -s6_;
        }
    }

    // Free stuff
    free_block(C6);
    free_block(RvdW);
    free_block(r);
    delete []Z;
    delete []x;
    delete []y;
    delete []z;
    return hess;
}
D2::D2(double s6) : Dispersion() 
{
    name_ = "-D2";
    description_ = "Grimme's -D2 Dispersion Correction";
    citation_ = "Grimme, S. (2006),  J. Comp. Chem., 27: 1787-1799";
    
    d_ = 20.0; 
    RvdW_ = RvdW_D2_;
    C6_ = C6_D2_;
    s6_ = s6;
}
D2::~D2() 
{
}
double D2::computeEnergy(shared_ptr<Molecule> mol)
{
    double energy = 0.0;

    // Build Z, x, y, and z
    int natom = 0;

    int *Z = init_int_array(mol->natom());
    double *x = init_array(mol->natom());
    double *y = init_array(mol->natom());
    double *z = init_array(mol->natom());

    for (int i = 0; i < mol->natom(); i++) {
        if (mol->Z(i) == 0)
        continue;
        Z[natom] = mol->Z(i);
        x[natom] = mol->x(i);
        y[natom] = mol->y(i);
        z[natom] = mol->z(i);
        natom ++;
    }

    // Build C6 (C6_ij = sqrt(C6_i*C6_j) in -D2) 
    double **C6 = block_matrix(natom, natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            C6[i][j] = sqrt( C6_[Z[i]] * C6_[Z[j]] );
        }
    }

    // Build RvdW (sum of vdW radii)
    double **RvdW = block_matrix(natom, natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            RvdW[i][j] = RvdW_[Z[i]] + RvdW_[Z[j]];
        }
    }

    // Build r
    double **r = block_matrix(natom,natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            r[i][j] = sqrt((x[i]-x[j])*(x[i]-x[j]) + \
                           (y[i]-y[j])*(y[i]-y[j]) + \
                           (z[i]-z[j])*(z[i]-z[j]));
        }
    } 

    // Compute energy
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            energy += C6[i][j]*pow(r[i][j],-6.0) / \
                (1.0 + exp(-d_*(r[i][j]/RvdW[i][j] - 1.0)));
        }
    }

    // Scale energy by s6_
    energy *= s6_;

    // Dispersion energy is always stabilizing
    energy *= -1.0;

    // Free stuff
    free_block(C6);
    free_block(RvdW);
    free_block(r);
    delete []Z;
    delete []x;
    delete []y;
    delete []z;

    return energy;
}
double* D2::computeGradient(shared_ptr<Molecule> mol)
{
    // Build Z, x, y, and z
    int natom = 0;

    int *Z = init_int_array(mol->natom());
    double *x = init_array(mol->natom());
    double *y = init_array(mol->natom());
    double *z = init_array(mol->natom());

    for (int i = 0; i < mol->natom(); i++) {
        if (mol->Z(i) == 0)
        continue;
        Z[natom] = mol->Z(i);
        x[natom] = mol->x(i);
        y[natom] = mol->y(i);
        z[natom] = mol->z(i);
        natom ++;
    }

    // gradient array in [x1 y1 z1 x2 y2 z2 ... ]
    double* grad = init_array(3*natom);
    
    // Build C6 (C6_ij = C6_i*C6_j/(C6_i+C6_j) in -D1 )
    double **C6 = block_matrix(natom, natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            C6[i][j] = sqrt( C6_[Z[i]] * C6_[Z[j]] );
        }
    }

    // Build RvdW (sum of vdW radii)
    double **RvdW = block_matrix(natom, natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            RvdW[i][j] = RvdW_[Z[i]] + RvdW_[Z[j]];
        }
    }

    // Build r
    double **r = block_matrix(natom,natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            r[i][j] = sqrt((x[i]-x[j])*(x[i]-x[j]) + \
                           (y[i]-y[j])*(y[i]-y[j]) + \
                           (z[i]-z[j])*(z[i]-z[j]));
        }
    } 

    // Compute gradient by perturbing nucleus A
    int Ax, Ay, Az;
    double f;
    for (int A = 0; A < natom; A++) {
        Ax = 3*A;
        Ay = 3*A + 1;
        Az = 3*A + 2;

        // Gradient x_i
        for (int j = 0; j < A; j++) {
            f = 1.0/(exp(-d_*(r[A][j]/RvdW[A][j] - 1.0)) + 1.0);
            grad[Ax] += 6.0*C6[A][j]*(x[A] - x[j])*pow(r[A][j],-8.0)*f + \
                C6[A][j]*d_*exp(-d_*(r[A][j]/RvdW[A][j] - 1.0))* \
                (x[A]-x[j])*f*f*pow(r[A][j], -7.0)/(RvdW[A][j]);      
            grad[Ay] += 6.0*C6[A][j]*(y[A] - y[j])*pow(r[A][j],-8.0)*f + \
                C6[A][j]*d_*exp(-d_*(r[A][j]/RvdW[A][j] - 1.0))* \
                (y[A]-y[j])*f*f*pow(r[A][j], -7.0)/(RvdW[A][j]);      
            grad[Az] += 6.0*C6[A][j]*(z[A] - z[j])*pow(r[A][j],-8.0)*f + \
                C6[A][j]*d_*exp(-d_*(r[A][j]/RvdW[A][j] - 1.0))* \
                (z[A]-z[j])*f*f*pow(r[A][j], -7.0)/(RvdW[A][j]);      
        }
        // Gradient x_j
        for (int i = A+1; i < natom; i++) {
            f = 1.0/(exp(-d_*(r[i][A]/RvdW[i][A] - 1.0)) + 1.0);
            grad[Ax] -= 6.0*C6[i][A]*(x[i] - x[A])*pow(r[i][A],-8.0)*f + \
                C6[i][A]*d_*exp(-d_*(r[i][A]/RvdW[i][A] - 1.0))* \
                (x[i]-x[A])*f*f*pow(r[i][A], -7.0)/(RvdW[i][A]);      
            grad[Ay] -= 6.0*C6[i][A]*(y[i] - y[A])*pow(r[i][A],-8.0)*f + \
                C6[i][A]*d_*exp(-d_*(r[i][A]/RvdW[i][A] - 1.0))* \
                (y[i]-y[A])*f*f*pow(r[i][A], -7.0)/(RvdW[i][A]);      
            grad[Az] -= 6.0*C6[i][A]*(z[i] - z[A])*pow(r[i][A],-8.0)*f + \
                C6[i][A]*d_*exp(-d_*(r[i][A]/RvdW[i][A] - 1.0))* \
                (z[i]-z[A])*f*f*pow(r[i][A], -7.0)/(RvdW[i][A]);      
        }
    }

    // Scale gradient by -s6_
    // Dispersion energy is always stabilizing
    for (int A = 0; A < 3*natom; A++) {
        grad[A] *= -s6_;
    }

    // Free stuff
    free_block(C6);
    free_block(RvdW);
    free_block(r);
    delete []Z;
    delete []x;
    delete []y;
    delete []z;
    return grad;
}
double** D2::computeHessian(shared_ptr<Molecule> mol)
{
    // Build Z, x, y, and z
    int natom = 0;

    int *Z = init_int_array(mol->natom());
    double *x = init_array(mol->natom());
    double *y = init_array(mol->natom());
    double *z = init_array(mol->natom());

    for (int i = 0; i < mol->natom(); i++) {
        if (mol->Z(i) == 0)
        continue;
        Z[natom] = mol->Z(i);
        x[natom] = mol->x(i);
        y[natom] = mol->y(i);
        z[natom] = mol->z(i);
        natom ++;
    }

    // gradient array in [x1 y1 z1 x2 y2 z2 ... ]
    double** hess = block_matrix(3*natom,3*natom);
    
    // Build C6 (C6_ij = C6_i*C6_j/(C6_i+C6_j) in -D1 )
    double **C6 = block_matrix(natom, natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            C6[i][j] = sqrt( C6_[Z[i]] * C6_[Z[j]] );
        }
    }

    // Build RvdW (sum of vdW radii)
    double **RvdW = block_matrix(natom, natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            RvdW[i][j] = RvdW_[Z[i]] + RvdW_[Z[j]];
        }
    }

    // Build r
    double **r = block_matrix(natom,natom);
    for (int i = 1; i < natom; i++) {
        for (int j = 0; j < i; j++) {
            r[i][j] = sqrt((x[i]-x[j])*(x[i]-x[j]) + \
                           (y[i]-y[j])*(y[i]-y[j]) + \
                           (z[i]-z[j])*(z[i]-z[j]));
        }
    } 

    // Compute gradient by perturbing nucleus A
    int Ax, Ay, Az;
    double f;
    for (int A = 0; A < natom; A++) {
        Ax = 3*A;
        Ay = 3*A + 1;
        Az = 3*A + 2;

    }

    // Scale gradient by -s6_
    // Dispersion energy is always stabilizing
    for (int A = 0; A < 3*natom; A++) {
        for (int B = 0; B < 3*natom; B++) {
            hess[A][B] *= -s6_;
        }
    }

    // Free stuff
    free_block(C6);
    free_block(RvdW);
    free_block(r);
    delete []Z;
    delete []x;
    delete []y;
    delete []z;
    return hess;
}
D3::D3() 
{
    name_ = "-D3";
    description_ = "Grimme's -D3 Dispersion Correction";
    citation_ = "Grimme, S. (2010),  J.C.P., 132: 154104";
}
D3::~D3() 
{
}
double D3::computeEnergy(shared_ptr<Molecule> mol)
{
    double energy = 0.0;
    return energy;
}
double* D3::computeGradient(shared_ptr<Molecule> mol)
{
    double* grad;
    return grad;
}
double** D3::computeHessian(shared_ptr<Molecule> mol)
{
    double** hess;
    return hess;
}

}}
