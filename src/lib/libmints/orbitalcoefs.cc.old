#include <cmath>

#include "mints.h"

#include <string>
#include <sstream>
#include <iostream>

#include "orbitalcoefs.h"

using namespace std;
using namespace psi;
using namespace boost;

namespace psi {

OrbitalCoefs::OrbitalCoefs(shared_ptr<BasisSet> prim, 
                          shared_ptr<Matrix> Ca, 
                          shared_ptr<Vector> eps,
                          shared_ptr<Dimension> napi) :
                          restricted_(true),
                          primary_(prim),
                          Ca_(Ca), Cb_(Ca), 
                          eps_a_(eps), eps_b_(eps),
                          napi_(napi), nbpi_(napi)
{
    common_init();
}
OrbitalCoefs::OrbitalCoefs(shared_ptr<BasisSet> prim, 
                          shared_ptr<Matrix> Ca, 
                          shared_ptr<Matrix> Cb, 
                          shared_ptr<Vector> eps_a,
                          shared_ptr<Vector> eps_b,
                          shared_ptr<Dimension> napi, 
                          shared_ptr<Dimension> nbpi) :
                          restricted_(true),
                          primary_(prim),
                          Ca_(Ca), Cb_(Cb), 
                          eps_a_(eps_a), eps_b_(eps_b),
                          napi_(napi), nbpi_(nbpi)
{
    common_init();
}
OrbitalCoefs::~OrbitalCoefs()
{
}
void OrbitalCoefs::common_init()
{
    nmopi_ = shared_ptr<Dimension>(new Dimension(Ca_->nirrep(), "Nmopi"));    
    nsopi_ = shared_ptr<Dimension>(new Dimension(Ca_->nirrep(), "Nsopi"));    

    int* nmopip = nmopi_->pointer();
    int* nsopip = nsopi_->pointer();

    for (int h = 0; h < Ca_->nirrep(); h++) {
        nsopip[h] = Ca_->rowspi()[h]; 
        nmopip[h] = Ca_->colspi()[h]; 
    }

    if (!restricted_) {
        frzoapi_ = shared_ptr<Dimension>(new Dimension(Ca_->nirrep(),"Nfrzoapi"));
        frzobpi_ = shared_ptr<Dimension>(new Dimension(Ca_->nirrep(),"Nfrzobpi"));
        frzvapi_ = shared_ptr<Dimension>(new Dimension(Ca_->nirrep(),"Nfrzvapi"));
        frzvbpi_ = shared_ptr<Dimension>(new Dimension(Ca_->nirrep(),"Nfrzvbpi"));
        occ_a_ = shared_ptr<Vector>(new Vector("Alpha Occupation", Ca_->nirrep(), Ca_->colspi()));
        occ_b_ = shared_ptr<Vector>(new Vector("Beta Occupation", Ca_->nirrep(), Ca_->colspi()));
        for (int h = 0; h < Ca_->nirrep(); h++) {
            for (int n = 0; n < napi_[h]; n++)
                occ_a_->set(h,n,1.0);
        for (int h = 0; h < Ca_->nirrep(); h++) {
            for (int n = 0; n < nbpi_[h]; n++)
                occ_b_->set(h,n,1.0);
        }
    } else {
        frzoapi_ = shared_ptr<Dimension>(new Dimension(Ca_->nirrep(),"Nfrzoapi"));
        frzvapi_ = shared_ptr<Dimension>(new Dimension(Ca_->nirrep(),"Nfrzvapi"));
        occ_a_ = shared_ptr<Vector>(new Vector("Alpha Occupation"), Ca_->nirrep(), Ca_->colspi());
        for (int h = 0; h < Ca_->nirrep(); h++) {
            for (int n = 0; n < napi_[h]; n++)
                occ_a_->set(h,n,1.0);
        }
        frzobpi_ = frzoapi_;
        frzvbpi_ = frzvapi_;
        occ_b_ = occ_a_;
    }      
    
    determine_order(); 
}
void OrbitalCoefs::determine_order()
{
    order_a_.clear();
    order_b_.clear();
    if (!restricted_) {

        std::vector<std::pair<double, std::pair<int, int> > > pairs;
        for (int h=0; h<eps_a_->nirrep(); ++h) 
            for (int i=0; i<eps_a_->dimpi()[h]; ++i)
                pairs.push_back(make_pair(eps_a_->get(h, i), make_pair(h, i)));

        sort(pairs.begin(), pairs.end());

        for (int h=0, index = 0; h<eps_a_->nirrep(); ++h) 
            for (int i=0; i<eps_a_->dimpi()[h]; ++i, ++index)
                order_a_.push_back(pairs[index].second);

        pairs.clear();

        for (int h=0; h<eps_b_->nirrep(); ++h) 
            for (int i=0; i<eps_b_->dimpi()[h]; ++i)
                pairs.push_back(make_pair(eps_b_->get(h, i), make_pair(h, i)));

        sort(pairs.begin(), pairs.end());

        for (int h=0, index = 0; h<eps_b_->nirrep(); ++h) 
            for (int i=0; i<eps_b_->dimpi()[h]; ++i, ++index)
                order_a_.push_back(pairs[index].second);

    } else {

        std::vector<std::pair<double, std::pair<int, int> > > pairs;
        for (int h=0; h<eps_a_->nirrep(); ++h) 
            for (int i=0; i<eps_a_->dimpi()[h]; ++i)
                pairs.push_back(make_pair(eps_a_->get(h, i), make_pair(h, i)));

        sort(pairs.begin(), pairs.end());

        for (int h=0, index = 0; h<eps_a_->nirrep(); ++h) 
            for (int i=0; i<eps_a_->dimpi()[h]; ++i, ++index)
                order_a_.push_back(pairs[index].second);
        
        order_b_ = order_a_;        

    }
}
shared_ptr<OrbitalCoefs> OrbitalCoefs::pipek_mizey_LOs()
{
    throw FeatureNotImplemented("OrbitalCoefs", "pipek_mizey_LOs", __FILE__, __LINE__);
    return shared_ptr<OrbitalCoefs>(primary_, Ca_, napi_);
}
shared_ptr<OrbitalCoefs> OrbitalCoefs::boys_LOs()
{
    throw FeatureNotImplemented("OrbitalCoefs", "boys_LOs", __FILE__, __LINE__);
    return shared_ptr<OrbitalCoefs>(primary_, Ca_, napi_);
}
shared_ptr<OrbitalCoefs> OrbitalCoefs::cholesky_LOs()
{
    return shared_ptr<OrbitalCoefs>(primary_, Ca_, napi_);
}
void OrbitalCoefs::set_inactive_oa(int n)
{
    memset(static_cast<void*>(frzoapi_->pointer()), '\0', frzoapi_->nirrep()*sizeof(int));
    int* p = frzoapi_->pointer();
    for (int e = 0; e < n; e++)
        p[order_a_[e].first]++;
}
void OrbitalCoefs::set_inactive_ob(int n)
{
    memset(static_cast<void*>(frzobpi_->pointer()), '\0', frzobpi_->nirrep()*sizeof(int));
    int* p = frzobpi_->pointer();
    for (int e = 0; e < n; e++)
        p[order_b_[e].first]++;
}
void OrbitalCoefs::set_inactive_va(int n)
{
    memset(static_cast<void*>(frzvapi_->pointer()), '\0', frzvapi_->nirrep()*sizeof(int));
    int* p = frzvapi_->pointer();
    for (int e = order_a_.size() - 1; e >= order_a_.size() - n - 1; e--)
        p[order_a_[e].first]++;
}
void OrbitalCoefs::set_inactive_vb(int n)
{
    memset(static_cast<void*>(frzvbpi_->pointer()), '\0', frzvbpi_->nirrep()*sizeof(int));
    int* p = frzvbpi_->pointer();
    for (int e = order_b_.size() - 1; e >= order_b_.size() - n - 1; e--)
        p[order_b_[e].first]++;
}
shared_ptr<Matrix> OrbitalCoefs::Coa_act_so() 
{
    int dim[Ca_->nirrep()];
    for (int h = 0; h < Ca_->nirrep(); h++) {
        dim[h] = napi_[h] - fzoapi_[h];
    }
    
    shared_ptr<Matrix> Coa(new Matrix("C Occupied Alpha (SO Basis)", Ca_->nirrep(), nsopi_, dim));

    for (int h = 0; h < Ca_->nirrep(); h++) {
        if (dim[h] == 0 || nsopi_[h] == 0) continue;
        
        double** Cact = Coa->pointer(h);
        double** Cfull = Ca_->pointer(h);
        
        for (int i = 0; i < dim[h]; i++) {
            C_DCOPY(nsopi[h], &Cfull[0][frzoapi_[h]], nmopi_[h], &Cact[0][0], dim[h]);
        }
    }

    return Coa;
}
shared_ptr<Matrix> OrbitalCoefs::Cob_act_so() 
{
    int dim[Cb_->nirrep()];
    for (int h = 0; h < Cb_->nirrep(); h++) {
        dim[h] = nbpi_[h] - fzobpi_[h];
    }
    
    shared_ptr<Matrix> Cba(new Matrix("C Occupied Beta (SO Basis)", Cb_->nirrep(), nsopi_, dim));

    for (int h = 0; h < Cb_->nirrep(); h++) {
        if (dim[h] == 0 || nsopi_[h] == 0) continue;
        
        double** Cact = Cob->pointer(h);
        double** Cfull = Cb_->pointer(h);
        
        for (int i = 0; i < dim[h]; i++) {
            C_DCOPY(nsopi[h], &Cfull[0][frzobpi_[h]], nmopi_[h], &Cact[0][0], dim[h]);
        }
    }

    return Cob;
}
shared_ptr<Matrix> OrbitalCoefs::Cva_act_so() 
{
    int dim[Ca_->nirrep()];
    for (int h = 0; h < Ca_->nirrep(); h++) {
        dim[h] = nmopi_[h] - napi_[h] - fzvapi_[h];
    }
    
    shared_ptr<Matrix> Coa(new Matrix("C Virtual Alpha (SO Basis)", Ca_->nirrep(), nsopi_, dim));

    for (int h = 0; h < Ca_->nirrep(); h++) {
        if (dim[h] == 0 || nsopi_[h] == 0) continue;
        
        double** Cact = Coa->pointer(h);
        double** Cfull = Ca_->pointer(h);
        
        for (int i = 0; i < dim[h]; i++) {
            C_DCOPY(nsopi[h], &Cfull[0][napi_[h] + i], nmopi_[h], &Cact[0][0], dim[h]);
        }
    }

    return Coa;
}
shared_ptr<Matrix> OrbitalCoefs::Cvb_act_so() 
{
    int dim[Cb_->nirrep()];
    for (int h = 0; h < Cb_->nirrep(); h++) {
        dim[h] = nmopi_[h] - nbpi_[h] - fzvbpi_[h];
    }
    
    shared_ptr<Matrix> Cob(new Matrix("C Virtual Beta (SO Basis)", Cb_->nirrep(), nsopi_, dim));

    for (int h = 0; h < Cb_->nirrep(); h++) {
        if (dim[h] == 0 || nsopi_[h] == 0) continue;
        
        double** Cact = Cob->pointer(h);
        double** Cfull = Cb_->pointer(h);
        
        for (int i = 0; i < dim[h]; i++) {
            C_DCOPY(nsopi[h], &Cfull[0][nbpi_[h] + i], nmopi_[h], &Cact[0][0], dim[h]);
        }
    }

    return Cob;
}

}
