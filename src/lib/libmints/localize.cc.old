#include <cmath>

#include <libmints/matrix.h>
#include <libmints/molecule.h>
#include <libmints/basisset.h>
#include <libmints/gshell.h>
#include <libciomr/libciomr.h>
#include <libqt/qt.h>

#include <string>
#include <sstream>
#include <iostream>

#include "localize.h"

using namespace std;
using namespace psi;

namespace psi {

Localizer::Localizer(shared_ptr<Matrix> C) : 
    C_(C), localized_(false), print_(0)
{
    L_ = shared_ptr<Matrix>(new Matrix("Localized Orbitals", C->nirreps(), C->rowspi(), C->colspi()));
    Lref_ = shared_ptr<Matrix>(new Matrix("Reference Localized Orbitals", C->nirreps(), C->rowspi(), C->colspi()));
    if (C_->nirreps() != 1)
        throw std::domain_error("Localization must be run in C1");
}
Localizer::~Localizer()
{
}
shared_ptr<Matrix> Localizer::update_localize(shared_ptr<Matrix> S)
{
    if (localized_)
        return localize();

    // Pertubative update (assumes C_ has changed)
    int* nsopi = C_->rowspi();
    int* noccpi = C_->colspi();

    for (int h = 0; h < C_->nirreps(); h++) {
        int nso = nsopi[h];
        int nocc = noccpi[h];

        double** C = C_->get_pointer(h);
        double** L = L_->get_pointer(h);
        double** Lref = Lref_->get_pointer(h);
        double** Sp = S->get_pointer(h);

        double** Temp1 = block_matrix(nso, nocc);
        double** W = block_matrix(nocc, nocc);
        
        C_DGEMM('N', 'N', nso, nocc, nso, 1.0, &Sp[0][0], nso, &Lref[0][0], nocc, 0.0, &Temp1[0][0], nocc);
        C_DGEMM('T', 'N', nocc, nocc, nso, 1.0, &C[0][0], nocc, &Temp1[0][0], nocc, 0.0, &W[0][0], nocc);

        free_block(Temp1);

        double** Wm12 = block_matrix(nocc, nocc);
        double** W2 = block_matrix(nocc, nocc);
        C_DGEMM('T', 'N', nocc, nocc, nocc, 1.0, W[0], nocc, W[0], nocc, 0.0, Wm12[0], nocc);
        
        // Wm12
        double* eigval = init_array(nocc);
        int lwork = nocc * 3;
        double* work = init_array(lwork);
        int stat = C_DSYEV('v','u', nocc, Wm12[0], nocc, eigval, work,lwork);
        if (stat != 0) {
            fprintf(outfile, "C_DSYEV failed\n");
            exit(PSI_RETURN_FAILURE);
        }
        free(work);

        double **J_copy = block_matrix(nocc, nocc);
        C_DCOPY(nocc*nocc,Wm12[0],1,J_copy[0],1); 

        for (int i=0; i<nocc; i++) {
            if (eigval[i] < 1.0E-15)
                eigval[i] = 0.0;
            else 
                eigval[i] = 1.0 / sqrt(eigval[i]);

            // scale one set of eigenvectors by the diagonal elements j^{-1/2}
            C_DSCAL(nocc, eigval[i], Wm12[i], 1);
        }
        free(eigval);

        // J_mhalf = J_copy(T) * J
        C_DGEMM('t','n',nocc,nocc,nocc,1.0,
            J_copy[0],nocc,Wm12[0],nocc,0.0,W2[0],nocc);

        free_block(J_copy);
        free_block(Wm12);
 
        double** U = block_matrix(nocc, nocc);
        C_DGEMM('N', 'N', nocc, nocc, nocc, 1.0, W[0], nocc, W2[0], nocc, 0.0, U[0], nocc);

        free_block(W);
        free_block(W2);

        C_DGEMM('N', 'N', nso, nocc, nocc, 1.0, C[0], nocc, U[0], nocc, 0.0, L[0], nocc);

        free_block(U); 
    }   
 
    return L_;         
}
PipekMezeyLocalizer::PipekMezeyLocalizer(shared_ptr<Matrix> C, shared_ptr<Matrix> S, shared_ptr<BasisSet> b) :
    Localizer(C), S_(S), basis_(b),
    converged_(false), iteration_(-1), maxiter_(1000), convergence_(1.0E-12)
{
    int natom = basis_->molecule()->natom();
    atom_starts_.resize(natom);
    atom_sizes_.resize(natom);

    for (int A = 0; A < natom; A++)
        atom_sizes_[A] = 0;

    for (int Q = basis_->nshell(); Q >= 0; Q--) {
        int center = basis_->shell(Q)->ncenter();
        int nfun = basis_->shell(Q)->nfunction();
        int index = basis_->shell(Q)->function_index();
        atom_starts_[center] = index;
        atom_sizes_[center] += nfun;    
    }
}
PipekMezeyLocalizer::~PipekMezeyLocalizer()
{
}
BoysLocalizer::BoysLocalizer(shared_ptr<Matrix> C, shared_ptr<Matrix> dip_x, 
    shared_ptr<Matrix> dip_y, shared_ptr<Matrix> dip_z) :
    Localizer(C), dip_x_(dip_x), dip_y_(dip_y), dip_z_(dip_z),
    converged_(false), iteration_(-1), maxiter_(1000), convergence_(1.0E-12)
{
}
BoysLocalizer::~BoysLocalizer()
{
}
CholeskyLocalizer::CholeskyLocalizer(shared_ptr<Matrix> C, shared_ptr<Matrix> D) :
    Localizer(C), D_(D)
{
}
CholeskyLocalizer::~CholeskyLocalizer()
{
}
shared_ptr<Matrix> PipekMezeyLocalizer::localize()
{
    int* nsopi = C_->rowspi();
    int* noccpi = C_->colspi();
    
    for (int h = 0; h < C_->nirreps(); h++) {
        int nso = nsopi[h];
        int nocc = noccpi[h];
        int natom = basis_->molecule()->natom();

        double** C = C_->get_pointer(h);
        double** L = L_->get_pointer(h);
        double** S = S_->get_pointer(h);
        double* swap = init_array(nso);

        C_DCOPY(nocc * (unsigned long int) nso, C[0], 1, L[0], 1); 

        if (print_) {
            fprintf(outfile, "\tIter     Pop. Localization   Max. Rotation Angle \n"); 
            fprintf(outfile, "\t-------------------------------------------------\n"); 
        }

        double Pss, Ptt, Pst;
        double Ast, Bst;
        double cos4a, den, cosa, sina, alpha;
        double P;
        
        double alphamax = 0.0;;
        converged_ = false;
        iteration_ = 0;
        do {
            alphamax = 0.0; 
            for (int s = 0; s < nocc; s++) {
                for (int t = s + 1; t < nocc; t++) {
                    Ast = 0.0;
                    Bst = 0.0;
                    for (int A = 0; A < natom; A++) {

                        C_DGEMV('N', nso, atom_sizes_[A], 1.0, &S[0][atom_starts_[A]], nso,
                            &C[atom_starts_[A]][s], nocc, 0.0, swap, 1);
                        
                        Pss = C_DDOT(nso, &C[0][s], nocc, swap, 1);
                        Pst = 0.5 * C_DDOT(nso, &C[0][t], nocc, swap, 1);

                        C_DGEMV('N', nso, atom_sizes_[A], 1.0, &S[0][atom_starts_[A]], nso,
                            &C[atom_starts_[A]][t], nocc, 0.0, swap, 1);
                        
                        Ptt = C_DDOT(nso, &C[0][t], nocc, swap, 1);
                        Pst += 0.5 * C_DDOT(nso, &C[0][s], nocc, swap, 1);

                        Ast += Pst * Pst - 0.25 * (Pss - Ptt) * (Pss - Ptt);
                        Bst += Pst * (Pss - Ptt);
                    }

                    den = sqrt(Ast * Ast + Bst * Bst);
                    cos4a = -Ast / den;
                    alpha = (den > 0.0 ? 0.25 * acos(cos4a) : 0.0);
                    alphamax = (alpha > alphamax ? alpha : alphamax); 
                
                    cosa = cos(alpha);
                    sina = sin(alpha);
                    C_DROT(nso, &C[0][s], nocc, &C[0][t], nocc, cosa, sina);                

                }
            }

            converged_ = (alphamax < convergence_ ? true : false);
            iteration_++;

            if (print_) {
                P = 0.0;
                for (int s = 0; s < nocc; s++) {
                    for (int A = 0; A < natom; A++) {
                        C_DGEMV('N', nso, atom_sizes_[A], 1.0, &S[0][atom_starts_[A]], nso,
                            &C[atom_starts_[A]][s], nocc, 0.0, swap, 1);
                        Pss = C_DDOT(nso, &C[0][s], nocc, swap, 1);
                        P += Pss * Pss;
                    } 
                }
                fprintf(outfile, "\t%4d  %20.10f  %20.10E\n", iteration_, P, alphamax); 
            }

        } while (! converged_ && iteration_ < maxiter_);   
        free(swap);
        localized_ = true;

        double** Lref = Lref_->get_pointer(h);
        C_DCOPY(nso * (unsigned long int) nocc, L[0], 1, Lref[0], 1);
    }

    return L_;
}
shared_ptr<Matrix> BoysLocalizer::localize()
{
    int* nsopi = C_->rowspi();
    int* noccpi = C_->colspi();

    for (int h = 0; h < C_->nirreps(); h++) { 
        int nso = nsopi[h];
        int nocc = noccpi[h];

        double** C = C_->get_pointer(h);
        double** L = L_->get_pointer(h);
        double** dx = dip_x_->get_pointer(h);
        double** dy = dip_y_->get_pointer(h);
        double** dz = dip_z_->get_pointer(h);
        double* swap = init_array(nso);

        C_DCOPY(nocc * (unsigned long int) nso, C[0], 1, L[0], 1); 

        if (print_) {
            fprintf(outfile, "\tIter     Pop. Localization   Max. Rotation Angle \n"); 
            fprintf(outfile, "\t-------------------------------------------------\n"); 
        }

        double Pss_x, Ptt_x, Pst_x;
        double Pss_y, Ptt_y, Pst_y;
        double Pss_z, Ptt_z, Pst_z;
        double Ast, Bst;
        double cos4a, den, cosa, sina, alpha;
        double P;
        
        double alphamax = 0.0;;
        converged_ = false;
        iteration_ = 0;
        do {
            alphamax = 0.0; 
            for (int s = 0; s < nocc; s++) {
                for (int t = s + 1; t < nocc; t++) {
                    Ast = 0.0;
                    Bst = 0.0;
                    
                    C_DGEMV('N', nso, nso, 1.0, &dx[0][0], nso, &C[0][s], nocc, 0.0, swap, 1);
                    Pss_x = C_DDOT(nso, &C[0][s], nocc, swap, 1);
                    Pst_x = C_DDOT(nso, &C[0][t], nocc, swap, 1);
                    C_DGEMV('N', nso, nso, 1.0, &dx[0][0], nso, &C[0][t], nocc, 0.0, swap, 1);
                    Ptt_x = C_DDOT(nso, &C[0][t], nocc, swap, 1);
                
                    C_DGEMV('N', nso, nso, 1.0, &dy[0][0], nso, &C[0][s], nocc, 0.0, swap, 1);
                    Pss_y = C_DDOT(nso, &C[0][s], nocc, swap, 1);
                    Pst_y = C_DDOT(nso, &C[0][t], nocc, swap, 1);
                    C_DGEMV('N', nso, nso, 1.0, &dy[0][0], nso, &C[0][t], nocc, 0.0, swap, 1);
                    Ptt_y = C_DDOT(nso, &C[0][t], nocc, swap, 1);
                
                    C_DGEMV('N', nso, nso, 1.0, &dz[0][0], nso, &C[0][s], nocc, 0.0, swap, 1);
                    Pss_z = C_DDOT(nso, &C[0][s], nocc, swap, 1);
                    Pst_z = C_DDOT(nso, &C[0][t], nocc, swap, 1);
                    C_DGEMV('N', nso, nso, 1.0, &dz[0][0], nso, &C[0][t], nocc, 0.0, swap, 1);
                    Ptt_z = C_DDOT(nso, &C[0][t], nocc, swap, 1);

                    Ast = Pst_x * Pst_x + Pst_y * Pst_y + Pst_z * Pst_z - 0.25 
                        * ((Pss_x - Ptt_x) * (Pss_x - Ptt_x) + 
                           (Pss_y - Ptt_y) * (Pss_y - Ptt_y) + 
                           (Pss_z - Ptt_z) * (Pss_z - Ptt_z));

                    // Not quite as sure here, probably
                    Bst = Pst_x * (Pss_x - Ptt_x) + Pst_y * (Pss_y - Ptt_y) + Pst_z * (Pss_z - Ptt_z); 
                
                    den = sqrt(Ast * Ast + Bst * Bst);
                    cos4a = -Ast / den;
                    alpha = (den > 0.0 ? 0.25 * acos(cos4a) : 0.0);
                    alphamax = (alpha > alphamax ? alpha : alphamax); 
                
                    cosa = cos(alpha);
                    sina = sin(alpha);
                    C_DROT(nso, &C[0][s], nocc, &C[0][t], nocc, cosa, sina);                

                }
            }

            converged_ = (alphamax < convergence_ ? true : false);
            iteration_++;

            if (print_) {
                P = 0.0;
                for (int s = 0; s < nocc; s++) {
                    C_DGEMV('N', nso, nso, 1.0, &dx[0][0], nso, &C[0][s], nocc, 0.0, swap, 1);
                    Pss_x = C_DDOT(nso, &C[0][s], nocc, swap, 1);
                    C_DGEMV('N', nso, nso, 1.0, &dy[0][0], nso, &C[0][s], nocc, 0.0, swap, 1);
                    Pss_y = C_DDOT(nso, &C[0][s], nocc, swap, 1);
                    C_DGEMV('N', nso, nso, 1.0, &dz[0][0], nso, &C[0][s], nocc, 0.0, swap, 1);
                    Pss_z = C_DDOT(nso, &C[0][s], nocc, swap, 1);

                    P += Pss_x * Pss_x + Pss_y * Pss_y + Pss_z * Pss_z;
                }
                fprintf(outfile, "\t%4d  %20.10f  %20.10E\n", iteration_, P, alphamax); 
            }

        } while (! converged_ && iteration_ < maxiter_);   
        free(swap);
        localized_ = true;
        double** Lref = Lref_->get_pointer(h);
        C_DCOPY(nso * (unsigned long int) nocc, L[0], 1, Lref[0], 1);
    }

    return L_;
}
shared_ptr<Matrix> CholeskyLocalizer::localize()
{
    int* dimpi = D_->rowspi();
    int* noccpi = L_->colspi();
    int max_n = 0;
    for (int h = 0; h < D_->nirreps(); h++)
    {
        if (dimpi[h] > max_n)
            max_n = dimpi[h];
    }
    double** Q = block_matrix(max_n, max_n);
    double* swap = init_array(max_n);
    int* pivots = init_int_array(max_n);
    
    for (int h = 0; h < D_->nirreps(); h++)
    {
        int n = dimpi[h];
        int nocc = noccpi[h];
        double** D = D_->get_pointer(h);
        double** L = D_->get_pointer(h);
        
        // Copy D block into Q
        for (int i = 0; i < n; i++)
            C_DCOPY(n, &D[i][0], 1, &Q[i][0], 1);    

        // Initialize pivot
        for (int i = 0; i < n; i++)
            pivots[i] = i;

        // Perform full pivoting (all the way for safety)
        for (int i = 0; i < n; i++) {
            double max_val = 0.0;
            int max_ind = 0;
            for (int j = i; j < n; j++) {
                if (Q[j][j] > max_val) {
                    max_val = Q[j][j];
                    max_ind = j;
                }
            }
            // Swap row i and row j
            C_DCOPY(n, Q[i], 1, swap, 1);
            C_DCOPY(n, Q[max_ind], 1, Q[i], 1);
            C_DCOPY(n, swap, 1, Q[max_ind], 1);
            
            // Swap column i and column j
            C_DCOPY(n, &Q[0][i], max_n, swap, 1);
            C_DCOPY(n, &Q[0][max_ind], max_n, &Q[0][i], max_n);
            C_DCOPY(n, swap, max_n, &Q[0][max_ind], 1);
            
            // Update pivots
            int temp = pivots[i];
            pivots[i] = pivots[max_ind];
            pivots[max_ind] = pivots[i]; 
        }
        
        // Perform the incomplete Cholesky docomposition
        // (stops automatically when rank deficent)
        int err = C_DPOTRF('U', n, &Q[0][0], max_n);
        if (err < 0)
            throw std::domain_error("Cholesky argument is bad");
        if (err > 0 && err != nocc + 1)
            throw std::domain_error("Rank does not equal nocc");

        // Unpivot rows and place in L_
        // Also ensure the triangular pattern is cool
        for (int i = 0; i < n; i++) {
            int piv = pivots[i];
            C_DCOPY(i, &Q[i][0], 1, &L[piv][0], 1);
            if (i < nocc)
                memset((void*) &L[piv][i + 1], '\0', (nocc - i - 1) * sizeof(double));
        }
        double** Lref = Lref_->get_pointer(h);
        C_DCOPY(n * (unsigned long int) nocc, L[0], 1, Lref[0], 1);
    }   

    free_block(Q);
    free(swap);
    free(pivots);
    localized_ = true;
 

    return L_;
}
static shared_ptr<Matrix> extract_occupieds(shared_ptr<Matrix> C, int* nocc, int* nfzc)
{
    shared_ptr<Matrix> L;
    if (nfzc == NULL) {
        L = shared_ptr<Matrix>(new Matrix(C->nirreps(), C->rowspi(), nocc));
    } else {
        int nact[C->nirreps()];
        for (int h = 0; h < C->nirreps(); h++)
            nact[h] = nocc[h] - nfzc[h]; 
        L = shared_ptr<Matrix>(new Matrix(C->nirreps(), C->rowspi(), nact));
    }   
    int* nsopi = C->rowspi();
    
    if (nfzc == NULL) { 
        for (int h = 0; h < C->nirreps(); h++) {
            double** Cp = C->get_pointer(h);
            double** Lp = L->get_pointer(h);
            for (int m = 0; m < nsopi[h]; m++)
                C_DCOPY(nocc[h], &Cp[m][0], 1, &Lp[m][0], 1);
        }
    } else {
        for (int h = 0; h < C->nirreps(); h++) {
            double** Cp = C->get_pointer(h);
            double** Lp = L->get_pointer(h);
            for (int m = 0; m < nsopi[h]; m++)
                C_DCOPY(nocc[h] - nfzc[h], &Cp[m][nfzc[h]], 1, &Lp[m][0], 1);
        }
    }

    return L;
} 
static shared_ptr<Matrix> extract_virtuals(shared_ptr<Matrix> C, int* nvirt, int* nfzv)
{
    shared_ptr<Matrix> L;
    if (nfzv == NULL) {
        L = shared_ptr<Matrix>(new Matrix(C->nirreps(), C->rowspi(), nvirt));
    } else {
        int nact[C->nirreps()];
        for (int h = 0; h < C->nirreps(); h++)
            nact[h] = nvirt[h] - nfzv[h]; 
        L = shared_ptr<Matrix>(new Matrix(C->nirreps(), C->rowspi(), nact));
    }   
    int* nsopi = C->rowspi();
    int* nmopi = C->colspi();
    
    if (nfzv == NULL) { 
        for (int h = 0; h < C->nirreps(); h++) {
            double** Cp = C->get_pointer(h);
            double** Lp = L->get_pointer(h);
            for (int m = 0; m < nsopi[h]; m++)
                C_DCOPY(nvirt[h], &Cp[m][nmopi[h] - nvirt[h]], 1, &Lp[m][0], 1);
        }
    } else {
        for (int h = 0; h < C->nirreps(); h++) {
            double** Cp = C->get_pointer(h);
            double** Lp = L->get_pointer(h);
            for (int m = 0; m < nsopi[h]; m++)
                C_DCOPY(nvirt[h] - nfzv[h], &Cp[m][nmopi[h] - nvirt[h]], 1, &Lp[m][0], 1);
        }
    }

    return L;
} 
static void place_occupieds_C_to_L(shared_ptr<Matrix> C, shared_ptr<Matrix> L, int* nfzc)
{
    int* nsopi = C->rowspi();
    int* nocc = L->colspi();
    
    if (nfzc == NULL) { 
        for (int h = 0; h < C->nirreps(); h++) {
            double** Cp = C->get_pointer(h);
            double** Lp = L->get_pointer(h);
            for (int m = 0; m < nsopi[h]; m++)
                C_DCOPY(nocc[h], &Cp[m][0], 1, &Lp[m][0], 1);
        }
    } else {
        for (int h = 0; h < C->nirreps(); h++) {
            double** Cp = C->get_pointer(h);
            double** Lp = L->get_pointer(h);
            for (int m = 0; m < nsopi[h]; m++)
                C_DCOPY(nocc[h] - nfzc[h], &Cp[m][nfzc[h]], 1, &Lp[m][0], 1);
        }
    }
} 
static void place_virtuals_C_to_L(shared_ptr<Matrix> C, shared_ptr<Matrix> L, int* nfzv)
{
    int* nsopi = C->rowspi();
    int* nmopi = C->colspi();
    int* nvirt = L->colspi();
    
    if (nfzv == NULL) { 
        for (int h = 0; h < C->nirreps(); h++) {
            double** Cp = C->get_pointer(h);
            double** Lp = L->get_pointer(h);
            for (int m = 0; m < nsopi[h]; m++)
                C_DCOPY(nvirt[h], &Cp[m][nmopi[h] - nvirt[h]], 1, &Lp[m][0], 1);
        }
    } else {
        for (int h = 0; h < C->nirreps(); h++) {
            double** Cp = C->get_pointer(h);
            double** Lp = L->get_pointer(h);
            for (int m = 0; m < nsopi[h]; m++)
                C_DCOPY(nvirt[h] - nfzv[h], &Cp[m][nmopi[h] - nvirt[h]], 1, &Lp[m][0], 1);
        }
    }
} 
static void place_occupieds_L_to_C(shared_ptr<Matrix> C, shared_ptr<Matrix> L, int* nfzc)
{
    int* nsopi = C->rowspi();
    int* nocc = L->colspi();
    
    if (nfzc == NULL) { 
        for (int h = 0; h < C->nirreps(); h++) {
            double** Cp = C->get_pointer(h);
            double** Lp = L->get_pointer(h);
            for (int m = 0; m < nsopi[h]; m++)
                C_DCOPY(nocc[h], &Lp[m][0], 1, &Cp[m][0], 1);
        }
    } else {
        for (int h = 0; h < C->nirreps(); h++) {
            double** Cp = C->get_pointer(h);
            double** Lp = L->get_pointer(h);
            for (int m = 0; m < nsopi[h]; m++)
                C_DCOPY(nocc[h] - nfzc[h], &Lp[m][0], 1, &Cp[m][nfzc[h]], 1);
        }
    }
} 
static void place_virtuals_L_to_C(shared_ptr<Matrix> C, shared_ptr<Matrix> L, int* nfzv)
{
    int* nsopi = C->rowspi();
    int* nmopi = C->colspi();
    int* nvirt = L->colspi();
    
    if (nfzv == NULL) { 
        for (int h = 0; h < C->nirreps(); h++) {
            double** Cp = C->get_pointer(h);
            double** Lp = L->get_pointer(h);
            for (int m = 0; m < nsopi[h]; m++)
                C_DCOPY(nvirt[h], &Lp[m][0], 1, &Cp[m][nmopi[h] - nvirt[h]], 1);
        }
    } else {
        for (int h = 0; h < C->nirreps(); h++) {
            double** Cp = C->get_pointer(h);
            double** Lp = L->get_pointer(h);
            for (int m = 0; m < nsopi[h]; m++)
                C_DCOPY(nvirt[h] - nfzv[h], &Lp[m][0], 1, &Cp[m][nmopi[h] - nvirt[h]], 1);
        }
    }
} 
LocalDomain::LocalDomain(int nocc, shared_ptr<BasisSet> prim, shared_ptr<BasisSet> aux, shared_ptr<BasisSet> pois) :
    nocc_(nocc), primary_(prim), auxiliary_(aux), poisson_(pois), print_(0), pois_(true)
{
    common_init();
}
LocalDomain::LocalDomain(int nocc, shared_ptr<BasisSet> prim, shared_ptr<BasisSet> aux) :
    nocc_(nocc), primary_(prim), auxiliary_(aux), print_(0), pois_(false)
{
    common_init();
}
void LocalDomain::common_init()
{
    I_ = block_matrix(nocc_, primary_->molecule()->natom());
    domain_ = init_int_matrix(nocc_, primary_->molecule()->natom());

    primary_nfuns_ = init_int_array(nocc_);
    primary_nshells_ = init_int_array(nocc_);
    auxiliary_nfuns_ = init_int_array(nocc_);
    auxiliary_nshells_ = init_int_array(nocc_);
    if (pois_) {
        primary_nfuns_ = init_int_array(nocc_);
        primary_nshells_ = init_int_array(nocc_);
    }

    int nshells = primary_->nshell();
    int nfuns = primary_->nbf(); 
    primary_funs_forward_ = init_int_matrix(nocc_, nfuns);
    primary_funs_reverse_ = init_int_matrix(nocc_, nfuns);
    primary_shells_forward_ = init_int_matrix(nocc_, nshells);
    primary_shells_reverse_ = init_int_matrix(nocc_, nshells);
    nshells = auxiliary_->nshell();
    nfuns = auxiliary_->nbf(); 
    auxiliary_funs_forward_ = init_int_matrix(nocc_, nfuns);
    auxiliary_funs_reverse_ = init_int_matrix(nocc_, nfuns);
    auxiliary_shells_forward_ = init_int_matrix(nocc_, nshells);
    auxiliary_shells_reverse_ = init_int_matrix(nocc_, nshells);
    if (pois_) {
        nshells = poisson_->nshell();
        nfuns = poisson_->nbf(); 
        poisson_funs_forward_ = init_int_matrix(nocc_, nfuns);
        poisson_funs_reverse_ = init_int_matrix(nocc_, nfuns);
        poisson_shells_forward_ = init_int_matrix(nocc_, nshells);
        poisson_shells_reverse_ = init_int_matrix(nocc_, nshells);
    }

    int natom = primary_->molecule()->natom();
    atom_prim_fun_starts_.resize(natom);
    atom_prim_fun_sizes_.resize(natom);
    atom_prim_shell_starts_.resize(natom);
    atom_prim_shell_sizes_.resize(natom);
    atom_aux_fun_starts_.resize(natom);
    atom_aux_fun_sizes_.resize(natom);
    atom_aux_shell_starts_.resize(natom);
    atom_aux_shell_sizes_.resize(natom);
    if (pois_) {
        atom_pois_fun_starts_.resize(natom);
        atom_pois_fun_sizes_.resize(natom);
        atom_pois_shell_starts_.resize(natom);
        atom_pois_shell_sizes_.resize(natom);
    }
    for (int A = 0; A < natom; A++) {
        atom_prim_fun_sizes_[A] = 0;
        atom_prim_shell_sizes_[A] = 0;
        atom_aux_fun_sizes_[A] = 0;
        atom_aux_shell_sizes_[A] = 0;
        if (pois_) {
            atom_pois_fun_sizes_[A] = 0;
            atom_pois_shell_sizes_[A] = 0;
        } 
    }

    for (int Q = primary_->nshell(); Q >= 0; Q--) {
        int center = primary_->shell(Q)->ncenter();
        int nfun = primary_->shell(Q)->nfunction();
        int index = primary_->shell(Q)->function_index();
        atom_prim_fun_starts_[center] = index;
        atom_prim_fun_sizes_[center] += nfun;    
        atom_prim_shell_starts_[center] = Q;
        atom_prim_shell_sizes_[center] ++;    
    }
    for (int Q = auxiliary_->nshell(); Q >= 0; Q--) {
        int center = auxiliary_->shell(Q)->ncenter();
        int nfun = auxiliary_->shell(Q)->nfunction();
        int index = auxiliary_->shell(Q)->function_index();
        atom_aux_fun_starts_[center] = index;
        atom_aux_fun_sizes_[center] += nfun;    
        atom_aux_shell_starts_[center] = Q;
        atom_aux_shell_sizes_[center] ++;    
    }
    if (pois_) {
        for (int Q = poisson_->nshell(); Q >= 0; Q--) {
            int center = poisson_->shell(Q)->ncenter();
            int nfun = poisson_->shell(Q)->nfunction();
            int index = poisson_->shell(Q)->function_index();
            atom_pois_fun_starts_[center] = index;
            atom_pois_fun_sizes_[center] += nfun;    
            atom_pois_shell_starts_[center] = Q;
            atom_pois_shell_sizes_[center] ++;    
        }
    }
}
LocalDomain::~LocalDomain()
{
    free_block(I_);
    free_int_matrix(domain_);

    free(primary_nfuns_);
    free(primary_nshells_);
    free(auxiliary_nfuns_);
    free(auxiliary_nshells_);
    if (pois_) {
        free(poisson_nfuns_);
        free(poisson_nshells_);
    }

    free_int_matrix(primary_funs_forward_);
    free_int_matrix(primary_shells_forward_);
    free_int_matrix(primary_funs_reverse_);
    free_int_matrix(primary_shells_reverse_);
    free_int_matrix(auxiliary_funs_forward_);
    free_int_matrix(auxiliary_shells_forward_);
    free_int_matrix(auxiliary_funs_reverse_);
    free_int_matrix(auxiliary_shells_reverse_);
    if (pois_) {
        free_int_matrix(poisson_funs_forward_);
        free_int_matrix(poisson_shells_forward_);
        free_int_matrix(poisson_funs_reverse_);
        free_int_matrix(poisson_shells_reverse_);
    }

}
void LocalDomain::form_domains_Lowdin(shared_ptr<Matrix> L, shared_ptr<Matrix> Sp12, double charge_cutoff, double R_cutoff)
{
    int* noccpi = L->colspi();
    int* nsopi = L->rowspi();
    int nocc = noccpi[0];
    int nso = nsopi[0];
    int natom = primary_->molecule()->natom();

    double** S12 = Sp12->get_pointer(0);
    double** Lp = L->get_pointer(0);
    double** Temp = block_matrix(nocc, nso);
    
    C_DGEMM('T', 'N', nocc, nso, nso, 1.0, &Lp[0][0], nocc, &S12[0][0], nso, 0.0, &Temp[0][0], nso);
    for (unsigned long int Q = 0; Q < nso * (unsigned long int) nocc; Q++)
        Temp[0][Q] *= Temp[0][Q];

    memset((void*) I_, '\0', nocc * (unsigned long int) natom * sizeof(double));
    for (int A = 0; A < natom; A++) {
        for (int Q = 0; Q < atom_prim_fun_sizes_[A]; Q++) {
            C_DAXPY(nocc, 1.0, &Temp[0][atom_prim_fun_starts_[A] + Q], nso, &I_[0][A], natom);
        } 
    }
    free_block(Temp);

    shared_ptr<Molecule> mol = primary_->molecule();    
    memset((void*) domain_, '\0', nocc * (unsigned long int) natom * sizeof(int));
    for (int i = 0; i < nocc; i++) {
        for (int A = 0; A < natom; A++)
            domain_[i][A] = (I_[i][A] > charge_cutoff ? 1 : 0);
        for (int A = 0; A < natom; A++) {
            if (domain_[i][A] == 1) {
                for (int B = 0; B < natom; B++) {
                    if (domain_[i][B] == 0 && mol->xyz(A).distance(mol->xyz(B)) < R_cutoff) {
                        domain_[i][B] = 2;
                    }
                }
            }
        }
    }
   
    form_indexing(); 
}
void LocalDomain::form_indexing()
{
    int natom = primary_->molecule()->natom();
    int nocc = nocc_;
    int offset;

    memset((void*) primary_nfuns_, '\0', nocc*sizeof(int));
    memset((void*) primary_nshells_, '\0', nocc*sizeof(int));
    memset((void*) auxiliary_nfuns_, '\0', nocc*sizeof(int));
    memset((void*) auxiliary_nshells_, '\0', nocc*sizeof(int));
    if (pois_) {
        memset((void*) poisson_nfuns_, '\0', nocc*sizeof(int));
        memset((void*) poisson_nshells_, '\0', nocc*sizeof(int));
    }

    for (int i = 0; i < nocc; i++) {
        int nshell = primary_->nshell();
        int nfun = primary_->nbf(); 
        for (int Q = 0; Q < nfun; Q++) {
            primary_funs_forward_[i][Q] = -1;
            primary_funs_reverse_[i][Q] = -1;
        } 
        for (int Q = 0; Q < nshell; Q++) {
            primary_shells_forward_[i][Q] = -1;
            primary_shells_reverse_[i][Q] = -1;
        } 
        nshell = auxiliary_->nshell();
         nfun = auxiliary_->nbf(); 
        for (int Q = 0; Q < nfun; Q++) {
            auxiliary_funs_forward_[i][Q] = -1;
            auxiliary_funs_reverse_[i][Q] = -1;
        } 
        for (int Q = 0; Q < nshell; Q++) {
            auxiliary_shells_forward_[i][Q] = -1;
            auxiliary_shells_reverse_[i][Q] = -1;
        }
        if (pois_) { 
            nshell = poisson_->nshell();
            nfun = poisson_->nbf(); 
            for (int Q = 0; Q < nfun; Q++) {
                poisson_funs_forward_[i][Q] = -1;
                poisson_funs_reverse_[i][Q] = -1;
            } 
            for (int Q = 0; Q < nshell; Q++) {
                poisson_shells_forward_[i][Q] = -1;
                poisson_shells_reverse_[i][Q] = -1;
            } 
        }
    }

    for (int i = 0 ; i < nocc; i++) {
        int prim_fun_counter = 0;
        int prim_shell_counter = 0;
        int aux_fun_counter = 0;
        int aux_shell_counter = 0;
        int pois_fun_counter = 0;
        int pois_shell_counter = 0;
        for (int A = 0; A < natom; A++) {
            if (domain_[i][A] > 0) {
                primary_nfuns_[i] += atom_prim_fun_sizes_[A];
                primary_nshells_[i] += atom_prim_shell_sizes_[A];
                auxiliary_nfuns_[i] += atom_aux_fun_sizes_[A];
                auxiliary_nshells_[i] += atom_aux_shell_sizes_[A];
                if (pois_) {
                    poisson_nfuns_[i] += atom_pois_fun_sizes_[A];
                    poisson_nshells_[i] += atom_pois_shell_sizes_[A];
                }
                
                offset = atom_prim_fun_starts_[A];
                for (int Q = 0; Q < atom_prim_fun_sizes_[A]; Q++) {
                    primary_funs_forward_[i][prim_fun_counter] = offset + Q;
                    primary_funs_reverse_[i][offset + Q] = prim_fun_counter;   
                    prim_fun_counter++;        
                }
                offset = atom_prim_shell_starts_[A];
                for (int Q = 0; Q < atom_prim_shell_sizes_[A]; Q++) {
                    primary_shells_forward_[i][prim_shell_counter] = offset + Q;
                    primary_shells_reverse_[i][offset + Q] = prim_shell_counter;   
                    prim_shell_counter++;        
                }
                offset = atom_aux_fun_starts_[A];
                for (int Q = 0; Q < atom_aux_fun_sizes_[A]; Q++) {
                    auxiliary_funs_forward_[i][aux_fun_counter] = offset + Q;
                    auxiliary_funs_reverse_[i][offset + Q] = aux_fun_counter;   
                    aux_fun_counter++;        
                }
                offset = atom_aux_shell_starts_[A];
                for (int Q = 0; Q < atom_aux_shell_sizes_[A]; Q++) {
                    auxiliary_shells_forward_[i][aux_shell_counter] = offset + Q;
                    auxiliary_shells_reverse_[i][offset + Q] = aux_shell_counter;   
                    aux_shell_counter++;        
                }
                if (pois_) {
                    offset = atom_pois_fun_starts_[A];
                    for (int Q = 0; Q < atom_pois_fun_sizes_[A]; Q++) {
                        poisson_funs_forward_[i][pois_fun_counter] = offset + Q;
                        poisson_funs_reverse_[i][offset + Q] = pois_fun_counter;   
                        pois_fun_counter++;        
                    }
                    offset = atom_pois_shell_starts_[A];
                    for (int Q = 0; Q < atom_pois_shell_sizes_[A]; Q++) {
                        poisson_shells_forward_[i][pois_shell_counter] = offset + Q;
                        poisson_shells_reverse_[i][offset + Q] = pois_shell_counter;   
                        pois_shell_counter++;        
                    }
                }
            }
        }
    }    
}

}
